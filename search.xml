<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《大型网站技术架构》学习笔记（一）]]></title>
    <url>%2F2021%2F12%2F21%2Farchitecture%2Farchitecture_one%2F</url>
    <content type="text"><![CDATA[简介趁周末时间膜拜了大佬写的《大型网站技术架构》一书，也是对系统架构有了一些入门级的了解。看了前面三章，感觉通熟易懂，受益匪浅，想以笔记的方式记录一下。 大型网站架构的演化发展历程初始阶段的网站架构应用程序、文件、数据库 LAMP=linux+apache+mysql+php 存在的问题 越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。 应用服务和数据服务分离特点 应用和数据分离后，不通特征的服务器承担不通的服务角色，网站的并发处理能力和数据存储空间得到很大改善 存在的问题 随着用户逐渐增多，数据库压力太大导致访问延迟 使用缓存改善网站性能特点 淘宝买家浏览的商品集中在少部分成交数多、评价良好的商品上；百度搜索关键词集中在少部分热门词汇上；只有经常登陆的用户才会发微博、刷微博。就像二八定律，80%的业务访问集中在20%的数据上，既然大部分业务访问集中在一小部分数据上，那么就把这一小部分数据缓存在内存中，就可以见上数据库的访问压力。 应用本地缓存 本地缓存访问的速度更快一些，但是受应用服务器内存的影响，其缓存数据量有限，而且会和应用程序争用内存的情况。 分布式缓存 远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以在理论上做到不受内存容器限制的缓存服务。 存在的问题 但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。 使用应用服务器集群改善网站的并发处理能力特点 使用集群是网站解决高并发、海量数据问题的常用手段。当一台服务器处理能力、存储空间不足时，不要企图去更换更强大的服务器，对大型网站而言，不管多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问及存储压力。（同时采用集群部署的方式提升系统的伸缩性） 依赖项 需要引入负载均衡调度服务器，将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上。 仍存在的问题 缓存的使用，使绝大部分数据读操作访问可以不用通过数据库完成，但仍有一部分读操作（缓存访问不命中，缓存过期）和全部的写操作需要访问数据库，在网站的用户达到一定的规模后，数据库因为负载压力过高而成为网站的瓶颈。 数据库读写分离特点 目前大部分主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新到另一台服务器上。网站利用数据库的这一功能，实现数据读写分离，从而改善数据库负载压力。 依赖项 为了便于应用程序访问读写分离后的数据库，通常在应用服务器使用专门的数据访问模块，使数据库读写分离对应用透明（读写分离，一般需要中间件或者AOP，对性能有一定的损耗） 使用反向代理和CDN加速网站响应特点 CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的是反向代理服务器，如果反向代理服务器中缓存着用户的请求资源，就将资源直接返回给用户。 作用 使用CDN和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。 使用分布式系统和分布式数据库特点 分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据库部署在不同的服务器上。 使用NoSQL和搜索引擎特点 NoSQL和搜索引擎都是源自互联网技术手段，对可伸缩的分布式特性具有良好的支持。对应用服务器在通过一个统一的数据访问模块访问各种数据，减轻应用程序管理诸多数据的麻烦。 业务拆分特点 根据业务对应用服务进行拆分，分不同的产品线，交由不同的业务团队和技术团队负责。 依赖项 服务注册中心或者消息队列，进行应用服务间的业务通信 分布式服务特点 将不同模块的公共业务提取出来，作为公共业务服务，独立部署。比如连接数据库，应用缓存等操作都维护在这个服务中，然后以集群多实例的方式进行部署。 演化价值观 网站的价值在于它能给用户提供什么价值，在于网站能做什么，而不在于它是怎么做的。 大型网站都是从小型网站发展而来，小型网站要做的就是为用户提供好的服务来创造价值，得到用户的认可，野蛮生长。 驱动大型网站技术发展的主要力量是网站的业务发展。是业务成就了技术，是事业成就了人，而不是相反。 所以网站架构师应该对成就自己技术成绩的网站事业心存感激，并努力提高技术反馈业务。 网站架构设计误区 一味追随大公司的解决方案 为了技术而技术 企图用技术解决所有的问题 12306真正的问题其实不在于它的技术架构，而在于它的业务架构（比如整点售票） 技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决。 大型网站的架构模式分层（横向分，比如应用层、服务层、数据层） 分割（纵向分，按业务功能进行分） 分布式：分布式事务带来数据不一致问题，可用性降低 集群：提高可用性 缓存：改善性能 异步：生产消费者模式，提高可用性、加快网站响应，削峰填谷 冗余：数据灾备（冷备份、热备份） 自动化：自动化测试、自动化部署，自动化监控报警 安全：防止XSS攻击、SQL注入 大型网站核心架构要素什么是架构 最高层次的规划，难以改变的决定 除了当前系统的功能需求外，软件架构还需要关注性能，可用性，伸缩性、扩展性和安全性 性能定义 衡量网站的性能有一系列指标，重要的有响应时间，TPS，系统性能计数器等 浏览器端 CDN缓存 应用服务端缓存 异步 集群多实例 多线程 数据库 可用性 应用服务器 存储服务器 软件开发过程中的质量保证（持续交互） 伸缩性定义 通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求 应用服务器集群 缓存服务器集群（较难） 扩展性定义 不同于其他架构要素关注非功能性需求，网站的扩展性架构直接关注网站的功能需求，衡量的主要标准是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品。 事件驱动架构 分布式服务 安全性定义 衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略。]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信心、乐观和勇气]]></title>
    <url>%2F2021%2F06%2F20%2Fdailylog%2Fconfidence-optimism-courage%2F</url>
    <content type="text"><![CDATA[题记 &emsp;&emsp;长大才发现，原来风筝只有逆着风，它才能慢慢的往上飞。愿风筝如你，一切安好！ &emsp;&emsp;生之，幸也，消失半年的陈三多终于又回来了。曾几何时，面临失业的惶恐而信念动摇，有了要离开北京的想法；曾几何时，由于冬训跑量过大引发膝盖的疼痛，濒临于崩溃放弃的边缘。曾几何时，连续几个月断断续续的失眠，让自己又回到那种浴火重生的状态。但庆幸的是，在经历社会的毒打后的我又活了过来，就像生命重生一样，带着对未来的期待，我对生活，对北京这个城市有了新的迷恋和喜爱。 &emsp;&emsp;今天刚好是入职网易满两个月的时间，貌似一切都有了更好的安排。曾经以为会留下遗憾的，终究不是真正的遗憾。原来只要心中有一道信念，那你就能与美好的自己相遇。很感谢经历这一切的自己，没有选择放弃离开的自己，没有被事实打败而是调整心态，重新接纳选择重新出发的自己。想必这一切的经历就是人生路上的炼金石，是人一生中最伟大的精神财富。 &emsp;&emsp;就好比自己是一粒种子，种子生根发芽才能生长，但没有哪棵树是没有阳光雨露，狂风暴雨就能长成的。这半年里面，我也经历这各种各样的环境，有来自感情方面的，有来自工作方面的，有来自身体方面的。如果自己信念不深，就如种子扎根不够深的话，你所处环境随时的一阵风，就可以把你刮跑，只有真正持守到底的，根才能扎得更深，才能从泥土中汲取更多的养分，成为一棵参天大树。 &emsp;&emsp;或许2021年已经过去了一半，但年初的梦想并没有忘记。人只有从经历中才能更好的了解自己，了解自己想要的是什么。尽管我的家人也经历着生离死别，但2021年必将是信心不变即将得胜的一年。我知道我这样的付出不是为了自己，而是为了我的家人们，我身边的人以及我的后代。人一旦有了信念，知道自己想要做的，才会对自己对目标产生更大的认同感，才能够抵制诱惑，才能义无反顾的开始行动，将更多的精力和时间放在自己坚信的事情上面。 阅读原文]]></content>
      <categories>
        <category>dailylog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈希表的进化，从HashMap到ConcurrentHashMap]]></title>
    <url>%2F2020%2F10%2F14%2Fcollection%2Fhashmap_concurrentMap%2F</url>
    <content type="text"><![CDATA[引言我们熟知，一般数组和链表不能满足我们常用的业务场景，比如说，我想存一种key-val类型的数据结构，其实来说，ArrayList也可以看成一种简单的哈希结构，只是key只能取int类型。那么为什么要有哈希结构呢？就是为了弥补数组与链表之间查询与修改的性能存在问题。 基于数组的顺序表ArrayList 由于占用的是一块连续的内存，故查询修改较快，插入删除较慢。基于Node节点的双向链表LinkedList 由于当前节点指向下一节点的方式，各个节点在内存中不是连续的，故插入删除较快，查询修改较慢。 为了弥补这两种数据结构的短板，哈希结构的数据类型应运而生，最先开始的是Hashtable，由于当时考虑到线程安全，这个类一上来就加synchronized锁，加锁必然消耗性能，但是，我们更多场景的是不需要锁的，所以才有了HashMap。HashMap是一个性能很不错的哈希表，但是线程不安全的。后来又有了线程安全的ConcurrentHashMap，并且他俩在jdk1.8进行了一次较大的升级，接下来的文章，我们就根据jdk1.7 和 jdk1.8 的源码来分析一下 HashMap 和ConcurrenthashMap。 HashMapjdk1.7结构初始化123456789101112131415161718public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); -- 默认初始化大小16、负载因子0.75&#125; public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) -- MAXIMUM_CAPACITY = 1 &lt;&lt; 30 initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();&#125; 实例变量123456789101112131415161718static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;transient int size;// If table == EMPTY_TABLE then this is the initial capacity at which the// table will be created when inflated.int threshold;final float loadFactor; java1.7 的hashMap结构如下图： Entry结构12345678910111213141516static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125;&#125; put方法思考：往HashMap 添加1000个元素需要扩容多少次？ (Add first)—&gt; 16 —&gt;以后都是两倍的扩容210=1024 ,还需要6次扩容 123456789101112131415161718192021222324public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); // 默认方式扩容 &#125; if (key == null) return putForNullKey(value); // key值为空处理 int hash = hash(key); // 找到key的hash值 int i = indexFor(hash, table.length); // 找到位于哪个哈希槽，即数组的下标 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 遍历哈希桶里的元素，如果有相等的key，直接替换val，返回原来的val if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 否则，将元素插入下标为i的哈希桶 addEntry(hash, key, value, i); return null;&#125; addEntry方法12345678910111213void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 校验是否需要扩容,个数大于阀值并且哈希槽里面已经有了元素 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 对数组进行两倍的扩容 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; // 扩容完之后重新获取桶的下标 bucketIndex = indexFor(hash, table.length); &#125; // 添加元素 createEntry(hash, key, value, bucketIndex);&#125; createEntry方法12345678// 插入元素时，应插入哈希桶的头部，而不是尾部void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 取出槽里的元素 Entry&lt;K,V&gt; e = table[bucketIndex]; // （第一处） // 将当前新生成的Entry放在槽里，next节点指向之前槽里的元素 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; resize方法12345678910111213141516171819void resize(int newCapacity) &#123; Entry[] oldTable = table; // 原数组的长度 int oldCapacity = oldTable.length; // 注意MAXIMUM_CAPACITY=1 &lt;&lt; 30，如果1&lt;&lt;31 则成 Intager 的最小值：-2147483648 if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建数组 Entry[] newTable = new Entry[newCapacity]; //（第四处） // 根据hash重新定位元素下标，从旧表迁移到新表 transfer(newTable, initHashSeedAsNeeded(newCapacity)); //（第二处） // 赋值内部数组（在此步骤完成前，旧表依然可以添加元素，导致数据丢失） table = newTable; //（第三处） // 修改阀值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; get方法1234567public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125; getEntry方法12345678910111213final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != null;e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; hash方法1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; indexFor方法1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1);&#125; remove(key)方法1234567891011121314151617181920212223242526272829303132333435363738public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value);&#125;final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); // 找到位于哪个桶 Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; // next指向下一个节点 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; // 如果在桶里，则将下个节点放入桶里 if (prev == e) table[i] = next; else // 否则，前节点的next节点指向删除节点的next节点 prev.next = next; e.recordRemoval(this); return e; &#125; // 不等的话，逐个遍历 prev = e; e = next; &#125; return e;&#125; 并发问题对象丢失问题123456789101112131415161718192021222324252627282930313233343536373839404142public class MapApplication &#123; private static Map hashMap = new HashMap(); public static void main(String[] args) throws InterruptedException &#123; MapApplication mp = new MapApplication(); Thread1 t1 = mp.new Thread1(); Thread2 t2 = mp.new Thread2(); Thread thread1 = new Thread(t1); Thread thread2 = new Thread(t2); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(hashMap.size()); &#125; class Thread1 implements Runnable &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 100000; i++) &#123; hashMap.put(i, i); &#125; &#125; &#125; class Thread2 implements Runnable &#123; @Override public void run() &#123; for (int i = 100001; i &lt;= 200000; i++) &#123; hashMap.put(i, i); &#125; &#125; &#125;&#125; 通过程序发现，当每个线程添加元素数据量在1000时，得到的结果并不是2000，而总是小于2000。 说明并发情况下，会导致数据丢失的问题。导致的原因之一是在createEntry方法中的第一处，一个线程的赋值被另一个线程的覆盖了。 同时在resize方法的第二处和第三处也会导致数据丢失。第二处遍历的时候如果有另一个线程将数据插入到已经遍历的桶里面，在步骤（第三处）赋值完也会导致数据丢失。 同时，如果两个线程同时进入到resize的（第四处）代码，newTable = new Entry[newCapacity]，由于是局部变量线程不可见，在resize完赋值之后会覆盖其他线程的操作，导致在“新表”中插入的元素无情的丢失。 原因总结 并发赋值时被覆盖 已遍历区间新增元素会丢失 “新表”被覆盖 当数据量在100000时，执行程序就不能永远退出，是因为扩容的时候导致死链的问题。 死链问题123456789101112131415161718192021222324252627282930public class ResizeMapApplication &#123; public static void main(String[] args) &#123; Map hashMap = new HashMap(); // 扩容的阀值是16*0.75=12 // 第一次扩容发生put第13个元素时 for (int i = 1; i &lt;= 13; i++) &#123; hashMap.put(new UserKey(), i); &#125; Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = hashMap.entrySet(); for (Map.Entry&lt;Integer, Integer&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + "---" + entry.getValue()); &#125; &#125;&#125;class UserKey &#123; @Override public int hashCode() &#123; // 保证在同一个槽 return 1; &#125; @Override public boolean equals(Object obj) &#123; // 保证不是相同的元素 return false; &#125;&#125; 根据源码可以追踪扩容前内部元素的情况 由于所有的元素都会位于table[1]的哈希桶里，所以只需跟踪table[1]的元素 扩容前：数组的长度为16，阀值为12 12—&gt;11—&gt;10 … … —&gt;2—&gt;1 扩容后：数组的长度为32，阀值为24 13—&gt;1—&gt;2—&gt;3… —&gt;11—&gt;12 当两个线程同时进入resize方法的第二处时，会重新rehash每一个哈希桶里的元素，具体实现如下： 1234567891011121314151617void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; // 使用foreach遍历整个数组下标 for (Entry&lt;K,V&gt; e : table) &#123; // 如果槽上存在元素，则遍历哈希桶，直到e==null，退出循环 while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 产生问题的根源是next的指针被并发线程修改。 jdk1.8在jdk1.8中，HashMap做了比较大的升级，关于升级的内容我们通过源码来验证一下。 jdk1.7是先扩容，再插入元素。而jdk1.8是，先插入元素，再扩容。 jdk1.7HashMap当链表长度过长时，存在遍历性能的问题。jdk1.8引入了红黑树，解决了该问题。 jdk1.7扩容时，哈希桶里的元素会重新rehash，顺序会颠倒。而jdk1.8是不一样的。 结构123456789101112131415161718192021222324252627282930313233343536373839404142434445static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;// jdk1.8 使用的是 Node节点，代替1.7的Entry,但叫法不一样，结构是一样的static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125; put方法123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; hash方法12345static final int hash(Object key) &#123; int h; // 加入高位运算，到数组的length比较小的时候，保证高地位bit参到计算中 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; putVal方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) // 默认扩容，获取数组的长度 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // 哈希槽为空，直接插入 tab[i] = newNode(hash, key, value, null); else &#123; // 否则，先判断哈希槽里的元素 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; // 如果key与哈希桶里的key相等，则找到了 e = p; &#125;else if (p instanceof TreeNode) // 哈希槽是否是TreeNode结构，是的话，进行插入 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 遍历哈希桶里的元素 for (int binCount = 0; ; ++binCount) &#123; // 如果遍历到最后的节点 if ((e = p.next) == null) &#123; // 追加在最后的节点末尾 p.next = newNode(hash, key, value, null); // 如果链表的长度大于等于7（除去哈希槽的元素，由于加上了next指针，这时的长度已经是8了） if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 将链表转化成红黑树 treeifyBin(tab, hash); break; &#125; // 找到相同的key if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; break; &#125; // 指向next指针 p = e; &#125; &#125; // 如果找到相同的key,返回原始val if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 判断size+1是否大于阀值 if (++size &gt; threshold) // 大于的话就进行扩容 resize(); afterNodeInsertion(evict); return null;&#125; 可以看到，在jdk1.8中 jdk1.8是，先插入元素，再扩容。 引入了红黑树，且哈希槽里放的是树的TreeNode结构 如果哈希桶是链表结构，长度不大于8的话，则追加的节点在链表的末尾。 到此，验证一、验证二 已经得到验证，现在来验证三。 resize方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 数组不能超过1&lt;&lt;30 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 阀值设置为最大值 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 容量、阀值也两倍扩容 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults // 如果默认初始化，则设置默认容量 newCap = DEFAULT_INITIAL_CAPACITY; // 默认的阀值 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 重新置阀值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 初始化新的table Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 扩容前的table不为空 if (oldTab != null) &#123; // 逐个遍历哈希桶 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 哈希槽指针 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 哈希槽里只有一个元素，则重新hash即可 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果哈希槽是TreeNode节点，则按照树的方式处理 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 是链表结构，则逐个遍历处理 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; jdk1.8中在计算新位置的时候并没有跟1.7中一样重新进行hash运算，而是用了原位置+原数组长度这样一种很巧妙的方式，而这个结果与hash运算得到的结果是一致的，只是会更快。 get方法1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; getNode方法1234567891011121314151617181920212223final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断哈希槽里的元素 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; return first; &#125; // 如果哈希槽里的元素不为空 if ((e = first.next) != null) &#123; // 判断是否是树结构，是的话，按照树去获取 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; // 遍历链表的元素 if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; return e; &#125; &#125; while ((e = e.next) != null); &#125; &#125; // 否则，返回 null return null;&#125; 简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题） ConcurrentHashMapjdk1.7由于HashMap是线程不安全的，在多线程下会出现安全问题，故引入了ConcurrentHashMap，支持多并发的场景。 结构123456789101112131415161718192021222324252627282930313233343536static final int MIN_SEGMENT_TABLE_CAPACITY = 2; static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative// Mask value for indexing into segments. // The upper bits of a key's hash code are used to choose the segment.final Segment&lt;K,V&gt;[] segments;// Shift value for indexing within segments.final int segmentMask;final int segmentShift; static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125;static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; transient volatile HashEntry&lt;K,V&gt;[] table; transient int count; transient int threshold; final float loadFactor; Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123; this.loadFactor = lf; this.threshold = threshold; this.table = tab; &#125; // PUT方法 // REMOVE方法&#125; java1.7 的ConcurentHashMap结构如下图： 初始化12345678910111213141516171819202122232425262728293031323334353637// 无参构造方法 默认值分别为：16，0.75，16public ConcurrentHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; // 参数校验 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; &#125; get方法12345678910111213141516171819public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); // 根据hash找到哪个Segment long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; // 如果不为空，遍历分段锁桶里面的元素 for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; get方法是非常高效的，因为没有加锁。是通过HashEntry的value加了volatile修饰符，保证了内存的可见性。 put方法12345678910111213public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // 找到分段锁桶的位置 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); // 往分段锁桶里put值 return s.put(key, hash, value, false);&#125; Segment.put方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 尝试获取锁 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); // 获取失败，说明有线程竞争，则自旋获取锁（默认64） V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; // 找到哈希槽下标 int index = (tab.length - 1) &amp; hash; // 获取哈希桶 HashEntry&lt;K,V&gt; first = entryAt(tab, index); // 遍历哈希桶里的元素 for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; // 遍历是否存在相同的key值 if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; // 有的话就替换 oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; // 退出循环 break; &#125; e = e.next; &#125; else &#123; // 遍历完发现没有相同的key,如果node节点不为空，直接将node节点的next指向哈希桶的第一个节点 if (node != null) node.setNext(first); else // 为空的话，就生成新的节点 node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) // 扩容 rehash(node); else // 重新放置HashEntry在桶里 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; remove方法123456public V remove(Object key) &#123; int hash = hash(key); Segment&lt;K,V&gt; s = segmentForHash(hash); // 注意这里传的value值是空 return s == null ? null : s.remove(key, hash, null);&#125; Segment.remove方法123456789101112131415161718192021222324252627282930313233343536373839404142final V remove(Object key, int hash, Object value) &#123; // 尝试获取锁 if (!tryLock()) // 阻塞性获取锁 scanAndLock(key, hash); V oldValue = null; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; // 获取哈希槽 HashEntry&lt;K,V&gt; e = entryAt(tab, index); HashEntry&lt;K,V&gt; pred = null; while (e != null) &#123; K k; // 下一个节点 HashEntry&lt;K,V&gt; next = e.next; // 找到要删除的key if ((k = e.key) == key ||(e.hash == hash &amp;&amp; key.equals(k))) &#123; V v = e.value; // 这里在干嘛，应该是兼容指定value删除 if (value == null || value == v || value.equals(v)) &#123; // 如果哈希桶为空，置空 if (pred == null) setEntryAt(tab, index, next); else // 否则，指向pred下一个指针 pred.setNext(next); ++modCount; --count; // 返回原始val oldValue = v; &#125; break; &#125; pred = e; e = next; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 参考crossoverJie文章]]></content>
      <categories>
        <category>collection</category>
        <category>hashmap</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode系列：合并两个有序数组]]></title>
    <url>%2F2020%2F10%2F04%2Falgorithm%2Fleetcode-088%2F</url>
    <content type="text"><![CDATA[描述给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 思路解一由于nums1已经是排序了的，我们能参考插入排序的思想，将nums2中的元素，逐个与nums1末尾的元素进行比较，直到找到合适的位置插入为止。 123456789101112131415161718192021class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; assert nums1 != null &amp;&amp; nums2 != null; for (int i = 0; i &lt; n &amp;&amp; m &lt; nums1.length; i++, m++) &#123; nums1[m] = nums2[i]; for (int j = m; j &gt; 0; j--) &#123; if (nums1[j] &gt;= nums1[j - 1]) &#123; break; &#125; else &#123; swapArr(nums1, j, j - 1); &#125; &#125; &#125; &#125; private static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 该算法的时间复杂度不理想，时间复杂度为 O（N*M） 解二双指针思想 p为nums1的末尾，q为新插入的位置。 从后面开始遍历数组nums2，逐个比较nums[i] 与 nums1[p] 的值 如果 nums1[p] &gt; nums2[i] ，交换p,q指标的值，一直循环到nums1[p] &lt;= nums2[i]，将大的值nums2[i]放置q位置 123456789101112131415161718192021222324252627public class MergeArr &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; assert nums1 != null &amp;&amp; nums2 != null; // 为nums1的末尾指针 int p = m - 1; // 找到比较后应该插入的位置，起初为m + n - 1 int q = m + n - 1; // 从后面开始遍历数组nums2 for (int i = n - 1; i &gt;= 0; i--) &#123; // 如果nums1[p] &gt; nums2[i] while (p &gt;= 0 &amp;&amp; nums1[p] &gt; nums2[i]) &#123; // 交换这两个值，交换后p，q往前移一位 swapArr(nums1, p--, q--); &#125; // 否则，将大的值放置q位置，q往前移一位 nums1[q--] = nums2[i]; &#125; &#125; private static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 时间复杂度为O（N+M），空间复杂度为O（1） 参考参一直接使用jdk源码数组拷贝 123456class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; System.arraycopy(nums2, 0, nums1, m, n); Arrays.sort(nums1); &#125;&#125; 参二逐个比较，比较大的放置后面，只是末尾需要额外的复制，最坏情况下，时间复杂度为O((n+m)log(n+m)) 123456789101112131415161718class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // two get pointers for nums1 and nums2 int p1 = m - 1; int p2 = n - 1; // set pointer for nums1 int p = m + n - 1; // while there are still elements to compare while ((p1 &gt;= 0) &amp;&amp; (p2 &gt;= 0)) // compare two elements from nums1 and nums2 // and add the largest one in nums1 nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--]; // add missing elements from nums2 System.arraycopy(nums2, 0, nums1, 0, p2 + 1); &#125;&#125; 最好时间复杂度O（N+M） github代码链接见上面👆]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode系列</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode系列：移动零]]></title>
    <url>%2F2020%2F10%2F01%2Falgorithm%2Fleetcode-283%2F</url>
    <content type="text"><![CDATA[描述Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12]Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array.Minimize the total number of operations. 思路解一设置两个指针i、j，用i指向为0的数字，用j指向不为0的数字。只有当j&gt;i的时候，才需要交换nums[i],nums[j]。那么先遍历一遍数组，用i来表示，如果nums[i]不为0，跳过；如果为0，才有可能交换。然后将i赋值给j，找到i之后的为0的下标，交换nums[i],nums[j]。注意i、j不能越界。 1234567891011121314public static void moveZeroes1(int[] nums) &#123; int j = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123; j = i; while (j &lt; nums.length &amp;&amp; nums[j] == 0) &#123; j++; &#125; if (j &lt; nums.length) &#123; swap(nums, i, j); &#125; &#125; &#125;&#125; 该算法的时间复杂度不理想，最坏情况下是 O（N^2） 解二参考冒泡的思想，两个之间逐个比较，如果有前面的那个为0，就交换位置。利用其稳定性，可以保证不为0元素的顺序。 123456789public static void moveZeroes2(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] == 0) &#123; swap(nums, j, j + 1); &#125; &#125; &#125;&#125; 按照冒泡思想可以优化，优化后的最好时间复杂度为O（N），最坏还是 O（N^2） 解三对解一的优化，避免多余的比较和查找。利用双指针的优势，将时间复杂度压缩到O（N），思路如下： 设置两个指针i、j，用i指向不为0的数字，用j指向为0的数字。只有当i&gt;j的时候，才需要交换nums[i],nums[j]。i、j分别从0开始，如果nums[i]==0,i++；如果nums[j]!=0,j++；如果i&gt;j并且nums[i] != 0，交换i,j的值，并且同时加一，否则i++;注意边界不超过len。 123456789101112131415161718public static void moveZeroes3(int[] nums) &#123; int i = 0; int j = 0; while (i &lt; nums.length &amp;&amp; j &lt; nums.length) &#123; if (nums[i] == 0) &#123; i++; &#125; if (nums[j] != 0) &#123; j++; &#125; if (i &gt; j &amp;&amp; i &lt; nums.length &amp;&amp; nums[i] != 0) &#123; swap(nums, i++, j++); &#125; else &#123; i++; &#125; &#125;&#125; 该程序注意死循环问题，为了避免死循环，才需要i++。该程序最坏要走2N部，时间复杂度为O(n)。另外我们swap也能进行优化，因为我们知道nums[j] = 0 nums[j] = nums[i];nums[i] = 0; 参考参一统计出不为0的个数，将不为0的赋值给数组前几位，后续的用0补充 12345678910111213// 参考public static void moveZeroes4(int[] nums) &#123; int tmp = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[tmp++] = nums[i]; &#125; &#125; for (int i = tmp; i &lt; nums.length; i++) &#123; nums[i] = 0; &#125;&#125; 时间复杂度O（N） 参二快慢指针思想，j是慢指针，指向为0的元素，i是快指针为不为0元素。快指针将所有不为0的元素，赋值给前面为0的元素，直到全为0。 123456789101112public static void moveZeroes5(int[] nums) &#123; int j = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[j] = nums[i]; if (i != j) &#123; nums[i] = 0; &#125; j++; &#125; &#125;&#125; 时间复杂度O（N） github代码地址对应的是提交记录，方便参看当时踩过的坑。]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode系列</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解Class加载过程]]></title>
    <url>%2F2020%2F07%2F11%2Fjvm%2Fclassloader%2F</url>
    <content type="text"><![CDATA[简介在探探字节码文件中，我们学习了class文件作为一个二进制字节流，是如何通过二进制的方式表达编程思想的。那么，class文件是由编译器编译得到的，默默的放在硬盘里面，当我们需要运行程序的时候，我们必须将class文件加载进内存中。那么，class文件需要经过一个什么样的过程才能到内存里准备好呢？ 本篇文章：我们将讨论class文件作为一个二进制字节流文件，JVM虚拟机是如何对这个文件加载并且准备、执行的。 class加载进内存，准备、执行的过程中，总共分三大步。第一步是Loading，第二步是Linking，第三步是Intializing。其中Linking又分成三小步，第一小步是Verification (验证)，第二小步是Preparation (准备)，第三小步是Resolution (解析)。 Loading类加载器Loading是把一个class文件load装进内存的，在JVM中有一套自定义的类加载器的层次，jvm所有的class都是被类加载器加载到内存的，这个类加载器也叫做ClassLoader。每个类加载器本身也是一个普通的class文件，最终由最高层次的加载器加载进JVM中。 如果，我想知道类是由哪个加载器加载进内存里的，我们只需打印一下这个加载器，如下面代码： 123456789101112131415161718192021222324252627282930public class ClassLoaderT02 &#123; // Launcher$AppClassLoader类和Launcher$ExtClassLoader都是在rt.jar文件下，被Boostrap加载器加载 public static void main(String[] args) &#123; // Boostrap加载器主要加载jre/lib/rt.jar包下的类 System.out.println(System.class.getClassLoader()); System.out.println(java.lang.Object.class.getClassLoader()); // Translator 属于jre/lib/ext/*.jar目录下 System.out.println(Translator.class.getClassLoader()); System.out.println(Translator.class.getClassLoader().getClass().getClassLoader()); System.out.println(ClassLoaderT02.class.getClassLoader()); System.out.println(ClassLoaderT02.class.getClassLoader().getParent()); System.out.println(ClassLoaderT02.class.getClassLoader().getParent().getParent()); System.out.println(ClassLoaderT02.class.getClassLoader().getClass().getClassLoader()); &#125; /*output null null sun.misc.Launcher$ExtClassLoader@1cd072a9 null sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$ExtClassLoader@1cd072a9 null null */&#125; 这里为什么会打印空呢？原因为：Boostrap加载类，是由C++实现的，java里没有对应实现，所以为空。 由程序可以证明 AppClassLoader、ExtClassLoader是sun.misc.Launcher的内部类。 AppClassLoader、ExtClassLoader都是由Boostrap加载器加载的。 AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BoostrapClassLoader。 Launcher是ClassLoader一个包装启动类，通过这个类我们可以看到每个类加载器的范围 123456// BoostrapClassLoaderprivate static String bootClassPath = System.getProperty("sun.boot.class.path");// ExtClassLoaderString var0 = System.getProperty("java.ext.dirs");// AppClassLoaderfinal String var1 = System.getProperty("java.class.path"); 我们可以测试一下 12345678910111213141516171819202122public class ClassLoaderT03 &#123; // 检查jdk自带的三种加载器分别负责加载哪些jar包 public static void main(String[] args) &#123; System.out.println("====================== boostrap ClassLoder ======================")； String boostrapPath = System.getProperty("sun.boot.class.path"); // System.lineSeparator()为系统换行符 boostrapPath = boostrapPath.replaceAll(":", System.lineSeparator()); System.out.println(boostrapPath); System.out.println("====================== extention ClassLoder ======================"); String extensionPath = System.getProperty("java.ext.dirs"); extensionPath = extensionPath.replaceAll(":", System.lineSeparator()); System.out.println(extensionPath); System.out.println("====================== application ClassLoder ======================"); String applicationPath = System.getProperty("java.class.path"); applicationPath = applicationPath.replaceAll(":", System.lineSeparator()); System.out.println(applicationPath); &#125;&#125; 输出为： 双亲委派双亲委派是一个孩子向父亲方向，然后父亲向孩子方向的双亲委派过程。双亲委派，主要出于安全来考虑。 加载的过程如图所示： 查找的加载器路线是： 自定义的ClassLoader—&gt; AppClassLoader—&gt;ExtClassLoader—&gt; BoostrapClassLoader 重复的动作是：findInCache -&gt; parent.loadClass -&gt; findClass() 委派的方向刚好相反： BoostrapClassLoader—&gt;ExtClassLoader—&gt;AppClassLoader—&gt;自定义的ClassLoader 其实，这个可以看ClassLoader的源码 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); // findInCache if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); // parent.loadClass &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // findClass // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 任何一个class，都会先从自定义的classLoader开始，因为内部维护了缓存，先从缓存中查找，如果没有，就委托给父加载器，父加载器也是重复同样的动作，直到最顶层的BoostrapClassLoader。如果父加载器缓存没有，class文件也不在自己负责的文件范围内，就重新委托给当前加载器。 123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name);&#125; 当前加载器会从自己负责加载的文件夹查找，如果有，就加载。如果没有，就抛出ClassNotFoundException。 整个加载过程如图 那么，为什么类的加载机制要搞一套双亲委派模型出来呢？ 我们可以假设，如果任何一个class可以通过自定义的ClassLoader记载进内存里，那么，我们就可以把java.lang.String交给自定义的加载器加载，我们可以动手脚，通过将程序打包给客户，用户使用后可以把密码发给我自己。 如果有了双亲委派，就会先去上面查有没有加载过，上面有加载过就直接返回，不会让自定义加载器加载。 自定义加载器通过以上分析，我们很容易的知道自定义加载器只需要 继承ClassLoader父类 重写模版方法findClass 调用defineClass 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243public class T006_MSBClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;// File f = new File("c:/test/", name.replace(".", "/").concat(".class")); File f = new File("/Users/alongso_pro/Desktop/class/Hello.class"); try &#123; FileInputStream fis = new FileInputStream(f); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int b = 0; while ((b=fis.read()) !=0) &#123; baos.write(b); &#125; byte[] bytes = baos.toByteArray(); baos.close(); fis.close();//可以写的更加严谨 return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return super.findClass(name); //throws ClassNotFoundException &#125; public static void main(String[] args) throws Exception &#123; ClassLoader l = new T006_MSBClassLoader(); Class clazz = l.loadClass("com.mashibing.jvm.Hello"); Class clazz1 = l.loadClass("com.mashibing.jvm.Hello"); System.out.println(clazz == clazz1);//// Hello h = (Hello)clazz.newInstance();// h.m();// System.out.println(h.getClass().getClassLoader());// System.out.println(h.getClass().getClassLoader().getParent()); System.out.println(getSystemClassLoader()); &#125;&#125; LinkingVerification验证文件是否符合JVM规定。如果加载进来的文件首4个字节不是CAFE BABE开头，在这个步骤就被拒绝掉了。 Preparation把class文件中的静态成员变量赋默认值，不是初始值。比如static int i=8，注意在这个步骤并不是直接把i赋成8，而是先赋值成0。 Resolution将类、方法、属性等符号引用解析为直接引用。class文件常量池里面用到的符号引用，要给它转换为直接内存地址，直接可以访问到的内容。 Initializing调用类初始化代码 &lt;clinit&gt;，给静态成员变量赋初始值。 LazyLoading懒加载，严格上叫做懒初始化，也叫延迟初始化。jvm规范没有严格定义何时加载，但虚拟机的实现是懒加载，就是我什么时候需要这个类的时候才会去加载这个类，并不是我用到jar包里的一个类，就将jar包所有的类都加载进来。 我们来看一个例子 12345678910111213141516171819public class ClassLoadingProcedureT00 &#123; public static void main(String[] args) &#123; // 当引用静态变量时，对T初始化 System.out.println(T.count); &#125;&#125;// 初始化时，先对static变量赋默认值，再执行构造函数，置初始值。class T &#123; //public static T t = new T(); public static int count = 2; private int m = 8; private T() &#123; count++; System.out.println("T Construct !!,count=" + count); &#125;&#125; 该程序输出的结果为 1/*output 2 */ 由该程序可得 引用静态变量时，会对T初始化，赋初始值。 注意：初始化指的是是否会调用类初始化代码&lt;clinit&gt;，给静态成员变量赋初始值，不要和实例构造函数&lt;init&gt;混淆了。 思考：如果把11行放开，会输出什么呢？如果把12行放在11行前面，又会输出什么？ 初始化的五种情况在周老师的《深入理解java虚拟机》明确指出，懒初始化 在下面五种情况下才能触发： new getstatic putstatic invokestatic指令，访问final变量除外。 java.lang.reflect对类进行反射调用时。 初始化子类的时候，父类首先初始化。 虚拟机启动时，被执行的主类必须初始化。 动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化。 思考：我们可以逐步注释以下代码，看看会输出什么？ 12345678910111213141516171819202122232425262728293031public class T008_LazyLoading &#123; public static void main(String[] args) throws Exception &#123;// P p; X x = new X();// System.out.println(P.i); //常量放在mataspace// System.out.println(X.j); //初始化 new getstatic putstatic invokestatic// Class clazz=Class.forName("com.selfstudy.jvm.classloader.T008_LazyLoading$X");// clazz.newInstance(); &#125; public static class P &#123; final static int i = 8; static int j = 9; static &#123; System.out.println("P static"); &#125; P() &#123; System.out.println("P construct!"); &#125; &#125; public static class X extends P &#123; static &#123; System.out.println("X static"); &#125; X() &#123; System.out.println("X Construct!"); &#125; &#125;&#125; 总结 classloading是使用双亲委派机制，从上到下再从下到上，从上找，向下委托。主要出于安全考虑。 LazyLoading五种情况在《深入理解java虚拟机》里有详细的列出来。 ClassLoaer的源码：findInCache -&gt; parent.loadClass -&gt;findClass()。 自定义加载器 extends ClassLoader overwrite findclass()—&gt;defineClass(bytes[])]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>class</tag>
        <tag>classloder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探探字节码文件]]></title>
    <url>%2F2020%2F07%2F03%2Fjvm%2Fclassfile-format%2F</url>
    <content type="text"><![CDATA[简介java语言能够实现跨平台，完全依赖于字节码文件和 JVM虚拟机，其字节码文件是一段代码从编写到执行的中间产物，但是对于编写java语言的我们来说，可以不用去关心实现细节的。字节码文件规范其实也是一门艺术，所有的跨平台语言都是基于class文件进行跨平台，所以，这也是扩展的一个知识面。 本篇文章，我们将讨论class文件作为一个二进制字节流，class文件是如何表达源代码的思想的。 练习我们通过一个简单的例子来学习一下字节码文件 12345package com.mashibing.jvm.c1_bytecode;public class T0100_ByteCode01 &#123;&#125; 这是一个简单的类，什么也没有，但是当反编译后，可以看到多了一个构造方法 123456package com.mashibing.jvm.c1_bytecode;public class T0100_ByteCode01 &#123; public T0100_ByteCode01() &#123; &#125;&#125; 用javac命令编译到的二进制文件为 123456789101112131415161718192021cafe babe 0000 0034 0010 0a00 0300 0d07000e 0700 0f01 0006 3c69 6e69 743e 01000328 2956 0100 0443 6f64 6501 000f 4c696e65 4e75 6d62 6572 5461 626c 6501 00124c6f 6361 6c56 6172 6961 626c 6554 61626c65 0100 0474 6869 7301 0030 4c63 6f6d2f6d 6173 6869 6269 6e67 2f6a 766d 2f63315f 6279 7465 636f 6465 2f54 3031 30305f42 7974 6543 6f64 6530 313b 0100 0a536f75 7263 6546 696c 6501 0015 5430 3130305f 4279 7465 436f 6465 3031 2e6a 6176610c 0004 0005 0100 2e63 6f6d 2f6d 61736869 6269 6e67 2f6a 766d 2f63 315f 62797465 636f 6465 2f54 3031 3030 5f42 79746543 6f64 6530 3101 0010 6a61 7661 2f6c616e 672f 4f62 6a65 6374 0021 0002 00030000 0000 0001 0001 0004 0005 0001 00060000 002f 0001 0001 0000 0005 2ab7 0001b100 0000 0200 0700 0000 0600 0100 00000300 0800 0000 0c00 0100 0000 0500 09000a00 0000 0100 0b00 0000 0200 0c 结构接下来，我们分析一下字节码文件 魔数从深入理解计算机中我们知道所有的文件（不管是数据还是程序），在计算机里都是以二进制的格式进行保存的。那么如何区分文件的格式呢，我们可以打开png、jpg类型图片，可以发现前四位 12-- png格式 8950 4E47-- jpg格式 FFDB FFE0 同样格式的文件前四位都是一样的。在java语言规范中，标识为class文件的前四位为cafe babe，这个就叫做魔数,占四位字节。 版本号不同的源码，在不同版本的jdk上编译，得到的字节码也是不一样的，这是通过版本号来区分的。版本号四个字节，前面为副版本号，接着是主版本号。 因此副版本号为0x0000,主版本号为ox0034,十进制组合为52.0版本，也就是jdk1.8.0。 常量池常量池是字节码设计最复杂的一部分，它的长度不固定，不同类型的常量结构也不一样。如下表： 注：此表格的类型的单位不对，不是bit，应该是byte(字节)。后面的同理。 常量池计数器记录常量池的长度，占两个字节。0x0010表示常量池的长度为16。注意，下标是从1开始的，为0的下标不指向内部引用，是为别的引用预备的。 常量池类型和结构12345670a00 0300 0d07 000e 0700 0f01 0006 3c69 6e69 743e 0100 0328 2956 0100 0443 6f64 6501 000f 4c696e65 4e75 6d62 6572 5461 626c 6501 0012 4c6f 6361 6c56 6172 6961 626c 6554 6162 6c65 0100 0474 6869 7301 0030 4c63 6f6d 2f6d 6173 6869 6269 6e67 2f6a 766d 2f63 315f 6279 7465 636f 6465 2f54 3031 3030 5f42 7974 6543 6f64 6530 313b 0100 0a53 6f75 7263 6546 696c 6501 0015 5430 3130 305f 4279 7465 436f 6465 3031 2e6a 6176 610c 0004 0005 0100 2e63 6f6d 2f6d 61736869 6269 6e67 2f6a 766d 2f63 315f 6279 7465 636f 6465 2f54 3031 3030 5f42 7974 6543 6f64 6530 3101 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 这部分二进制描述的全部是常量池的信息，可以对造上面表格一一查找。 比如 0x0a00 0300 0d查找结构为0a | 0003 | 000d，即对应10，CONSTANT_Methodref_info类型，接着是方法的两个指针索引，指向下标为3和13的常量池。 这一一查找挺麻烦的，但是我们只要用 1javap -verbose T0100_ByteCode01.class 常量池类型和结构就全都出来了 12345678910111213141516Constant pool: #1 = Methodref #3.#13 // java/lang/Object."&lt;init&gt;":()V #2 = Class #14 // com/mashibing/jvm/c1_bytecode/T0100_ByteCode01 #3 = Class #15 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 LocalVariableTable #9 = Utf8 this #10 = Utf8 Lcom/mashibing/jvm/c1_bytecode/T0100_ByteCode01; #11 = Utf8 SourceFile #12 = Utf8 T0100_ByteCode01.java #13 = NameAndType #4:#5 // "&lt;init&gt;":()V #14 = Utf8 com/mashibing/jvm/c1_bytecode/T0100_ByteCode01 #15 = Utf8 java/lang/Object 访问标志常量池后面就是访问标志，用两个字节来表示，其标识了类或者接口的访问信息，比如：该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明成final等等。各种访问标志如下所示： 由于所有类都会继承Object类，所以访问标识ox0020都是满足的，因此访问标志为0x0021 当前类名两个字节，类索引的值为ox0002，指向常量池第二项的索引。 1#2 = Class #14 // com/mashibing/jvm/c1_bytecode/T0100_ByteCode01 这里是通过类索引我们可以确定类的全限定名。 父类名跟当前类名一样，两个字节，类索引的值为ox0003，指向常量池第三项的索引。 1#3 = Class #15 // java/lang/Object 从字节码的设计来看，这里只有两个字节存父类名的索引，因此，这里只能指向一个类。即从设计上看出，java语言类只能从一个类继承，但多个类可以多重继承。 接口接口计数器两个字节，记录了实现接口的个数。这里为0x0000,即没有实现接口，因此，接口索引就不占字节。 接口索引一个接口，两个字节。通过类索引找到实现的接口全限定名。 字段表字段计数器两个字节，记录了字段的个数。由于没有，故字节码到ox0000就没了。 字段表结构字段表作为一个表，同样有他自己的结构 我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些： 方法表方法计数器两个字节，记录了方法的个数。这里为0x0001，由于该类没有自定义构造方法，编译后会生成一个构造方法，当初始化的时候会调用Object的构造方法。 方法表结构方法表的结构实际跟字段表是一样的，方法表结构如下： 跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下： 对应字节码为：0001 0001 0004 0005 0001 0006 0000 002f 0001 0001 0000 0005 2ab7 0001 b1 1230001 || 0001 || 0004 || 0005 || 0001 || 0006 ------------------------------------------------------------------------计数器 || public || 索引&lt;init&gt; || 索引5 || 属性计数器 || 属性Code类型 Code属性表结构 123450006 0000 002f 0001 0001 0000 0005 2ab7 0001 b100 0000 02 00 0700 0000 0600 0100 0000 0300 0800 0000 0c00 0100 0000 0500 0900 0a00 00 0x0006对应常量池索引6的下标，查看是Code类型 0x0000002f为属性的长度，这里的值是47，即往后47个字节都是Code的内容。 max_stack的值为0x0001，即操作数栈深度的最大值为1。 max_locals的值为0x0001，即局部变量表所需的存储空间为1；max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。 code_length的值为0x000000005,即字节码指令的长度为5。 code的值为2ab7 0001 b1,这里的值就代表一系列的字节码指令。一个字节代表一个指令，一个指令可能有参数也可能没参数，如果有参数，则其后面字节码就是他的参数；如果没参数，后面的字节码就是下一条指令。 12345672a 指令，查表可得指令为aload_0，其含义为：将第0个Slot中为reference类型的本地变量推送到操作数栈顶。b7 指令，查表可得指令为invokespecial，其含义为：将操作数栈顶的reference类型的数据所指向的对象作为方法接受者， 调用此对象的实例构造器方法、private方法或者它的父类的方法。其后面紧跟着的2个字节即指向其具体要调用的方法。 这里指向的是`0x0001`的索引，即调用的是Object的构造方法。b1 指令，查表可得指令为return，其含义为：返回此方法，并且返回值为void。这条指令执行完后，当前的方法也就结束了。 exception_table_length的值为0x0000，即异常表长度为0，所以其异常表也没有；attributes_count的值为0x0002，即code属性表里面还有两个其他的属性表，分别是0x0007和0x0008的索引。对应为LineNumberTable属性和LineVariableTable属性。关于这两个属性可以见下面，有特定的结构。 属性表到这里，我们剩下的字节码还有00 0100 0b00 0000 0200 0c 属性计数器两个字节，记录了属性的个数。这里是0x0001，即一个属性。 属性结构体属性表的结构比较灵活，各种不同的属性只要满足以下结构即可： 0x000b对应常量池索引11的下标，查看是SourceFile类型，到这里我们需要查看SourceFile类型属性的结构 属性的长度为0x00000002，即两个字节，后面是0x000c指向索引为12的下标，即T0100_ByteCode01.java，表示源文件的名称 其他属性其实，上面LineNumberTable、LineVariableTable也是类似SourceFile类型，也有特定的结构。Java虚拟机中预定义的属性有20多个，如下图所示 总结字节码文件的设计真的是一门艺术，根据java语言的规范，将根据人的思想编写的高级语言经过编译器编译成字节码文件，通过二进制（十六进制）表达了源代码的思想。我们在学习的过程中可以使用JClassLib—IDEA插件协助我们看字节码文件，这样就不用面对枯燥的十六进制了。 使用工具查看很是方便，如图]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一切都要从二进制、字节码说起]]></title>
    <url>%2F2020%2F07%2F02%2Fjvm%2Fbytecode%2F</url>
    <content type="text"><![CDATA[二进制自古以来，就有太极生两仪，两仪生四象，四象生八卦的文化传说。天与地，明与暗，是与非，有与无，宇宙万物貌似都是在这两个极端之间存在的。然而在计算机的世界里，这个世界又是怎样存在的呢，对的，就是用二进制来表示的。 转化十进制转二进制 250除二取余数，后面的余数居最高位，得11111010 十进制转八进制 250除八取余数，后面的余数居最高位，得372 二进制转八进制 11111010补全前面的位数，9位（3的倍数）得011 111 010，得372 表示数据在计算机中是通常是用二进制表示的，但是当加减运算时，是通过补码的方式来表示的，表示方式有原码与反码，补码。 正数的原码与反码，补码都相同，即它的二进制数 负数的补码稍微复杂一些。【所有的数据运算都是采用补码进行的】 负数补码的推算 方法一：直接推算法 利用原码加上补码等于0的特性，比如：5的二进制为0101+（-5的补码）=0（十进制）,得-5的补码为1111 1011 方法二：公式推算法 负数的补码=正数的二进制取反+1, 比如5的二进制取反为11111010，+1之后，得1111 1011 计算机语言介绍完二进制后，我们来了解一下有哪些计算语言 定义是指用于人与计算机之间通讯的一种特殊语言，是人与计算机之间传递消息的媒介。 分类低级语言机器语言直接用二进制指令表达。指令是用0和1组成的一长串代码。有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言使用一些特殊的符号代替机器语言的二进制码（又称符号语言），计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言，依赖于硬件体系，开发难度较大。 高级语言高级语言是相对于低级语言来说的，高级语言是按照人的思维编写出来的语言，比如C语言、C++、JAVA、Python等，其可读性高，但执行效率较低级语言低，编写的程序叫作源程序。 那么问题来了，对于高级语言，如果程序想运行，必须翻译成计算机能识别的低级语言才行，那么，高级语言是怎么翻译的呢？这就要借助编译器或者解析器了。 翻译语言分类编译型语言 如图所示，程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候（.exe），就不用再进行翻译了。这类语言编写的程序启动稍慢，执行稍快。比如C语言、C++ 解释型语言 不需要编译，运行时使用一个专用的解释器去翻译，每一条语句都是执行的时候才翻译，所以这类程序每执行一次就要翻译一次，这类语言编写的程序启动稍快，执行稍慢。比如Python 混合型语言 混合型语言，比如java，对源码进行编译后能得到class字节码文件，然后JVM拿到文件后会进行解释成C++语言，然后通过C++编译器编译成汇编语言。具体情况如下图： 适用场景 运行速度要求高,优选编译型。比如C语言做游戏开发 跨平台性，优选解释型，java主要用于做企业平台 字节码用IDE编写好JAVA源代码之后，会自动编译成class文件（字节码文件），里面存放的是Class类的信息【这里并不是将程序编译成机器语言，可以将字节码文件看作中间语言，在程序运行时，由JVM将字节码再翻译成机器语言】 跨平台性正是由于有class字节码的存在，才使得编程语言迈入一个新的世纪，java语言成为跨平台的语言。跨平台就是一次编译，到处执行( Write Once ,Run Anywhere)。只要机器安装好了JVM，一切编译好的class文件就能够运行。而像C语言就不行，必须在指定的操作系统上运行的。JVM只是一个中间桥梁，操作系统要运行java程序，就必须安装一个对应版本的虚拟机。程序执行的时候，JVM会将class文件load进内存中，翻译成机器语言执行，从源码编译成字节码，再由字节码转机器语言的过程，java语言规范起了奠定性作用。 因此 跨平台性 = java语言规范 + class文件 + JVM虚拟机 目前支持跨平台的语言有 运行机制jvm会加载class文件进内存，java一般默认是混合模式编译，即解释器+热点代码编译，起始阶段采用解释执行，对于多次调用的方法或者循环，采用JIT即时编译。 我们可以手动配置jvm使用什么模式： -Xmixed 默认为混合模式，开始解释执行，启动速度较快，对热点代码实行检测和编译 -Xint 使用解释模式，启动很快，执行稍慢 -Xcomp 使用纯编译模式，执行很快，启动很慢 Java模型 JVM：Java虚拟机（Java Virtual Machine）它是运行所有Java程序的虚拟计算机，好比是街机游戏的模拟器。 JRE：Java运行环境（Java Runtime Environment）如果要运行Java程序，就需要JRE，JRE里包含JVM和java类库。 JDK：Java开发工具（Java Development Kit）包含开发Java程序的所有工具(javac、java)，JDK里包含JRE和开发调试工具。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《敏捷软件开发》之原则]]></title>
    <url>%2F2020%2F06%2F24%2Fpatterns%2Fagile-software-development%2F</url>
    <content type="text"><![CDATA[简介这段时间趁着学习《Head First设计模式》又抓紧时间把之前学习的《敏捷软件开发》复习了一下，但不得不承认，这两本书对设计模式有较深的深入，但相比于《Head First设计模式》，《敏捷软件开发》更吸引我的一点是，这本书对实践这一块做的比较好，将原则、模式和实践结合得恰到好处。比如说：素数、保龄球、冒泡排序和薪水支付的案例，都是不错例子和场景。 回顾敏捷宣言、极限编程、TDD测试、重构 测试驱动开发与重构的思考 敏捷设计源代码是软件系统的主要设计文档 我们不应该认为软件设计就是一组和代码分离的UML图，UML图只是描述了设计的一部分。 软件项目的设计是一个抽象的概念。它和程序的概括形状、结构以及每一个模块、类和方法的详细形状和结构有关。 设计的最终体现在 源代码 中。 设计中臭味—腐化软件的气味 僵化性： 耦合性高，模块组件件关系太紧密，依赖性高，一动全动。 脆弱性： 改动一处，其他相关联的地方也会变动，引发意想不到的问题。 牢固性： 设计难以重用。 粘滞性： 这一点有点难以理解。 不必要的复杂性： 导入不必要的模块，组件或包。 不必要的重复： 随意copy，将可以的抽象隐藏起来，而且如果随处copy的代码需要变动，得到处进行修改。 晦涩性： 模块难以理解。 保持尽可能好的设计 需求是项目中最不稳定的要素。 敏捷团队依靠变化来获取活力。 团队几乎不进行预先设计，因此不需要一个成熟的初始设计。 敏捷开发人员致力于保持设计尽可能的适当、干净、简单，并且使用许多的单元测试和验收测试支援。 敏捷软件开发知道要做的事情： 遵循敏捷实践去发现问题 应用设计原则去诊断问题 应用适当的设计模式去解决问题 定义敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能的简单、干净以及富有表现力。 臭味 设计中的臭味是一种症状，是可以主观进行度量的。这些臭味通常是由违反了这些原则中的一个或者多个导致的。 比如违反了开闭原则，会导致僵化性。 应用原则的目的是去除僵化性，当没有臭味时就不应该应用这些原则 设计原则单一职责原则（The Single Responsibility Principle）内聚性一个模块的组成元素之间的功能相关性。把内聚性和引起一个模块或者类改变的作用力联系起来。 职责变化的原因 定义就一个类而言，应该仅用一个引起它变化的原因。 描述 每一个职责都是变化的一条轴线。当需求变化时，该变化反应为类的职责的变化。如果一个类承担了多于一个的职责，那么引起它变化的原因就会有多个。 如果一个类承担的职责过多，就等于把这些职责耦合在一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。 这种耦合导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏。 例子 Employee类包含了业务规则和对于持久化的控制。 业务规则往往会频繁的变化，而持久化的方式却不会如此频繁的变化。 测试驱动开发的实践常常会远在设计出现臭味之前就迫使我们分离这两个职责。 应用 SpringIOC源码中BeanFactory的设计，getBaen()和getBeanDefinition()、registerBeanDefinition()的分离。 开放、封闭原则（The Open-Close Principle)定义软件实体（类，模块、函数等等）应该是可以扩展的，但是不可修改的。 描述对于扩展是开放的、对于更改是封闭的 本质构造抽象来隔离引起的变化 结论在许多方面，OCP都是面向对象设计的核心所在，遵循这个原则可以带来巨大好处。 比如，灵活性，可重用性以及可维护性。 Liskov替换原则（The Liskov Substitution Principle）定义子类型必须能够替换掉它们的基类型 描述若对每个类型S的对象o1,都存在一个类型T的对象o2,使得在所有针对T编写的程序P中,用o1替换o2后，程序P行为功能不变，则S是T的子类型。 结论一个模型，如果孤立地看，并不具有真正意义上的有效性。在考虑一个特定设计是否恰当时，不能完全孤立地来看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。 基于契约式设计 约定大于配置 契约：是通过为每个方法声明的前置条件和后置条件来指定的。 要使一个方法得以执行，前置条件必须为真。执行完毕后，该方法要保证后置条件为真。 接口隔离原则（The Interface Segregation Interface）定义不应该强迫客户依赖它们不用的方法 胖类意味着高耦合性，当一个客户程序要求该胖类进行一个改动时，会影响到所有其他的客户程序。 分离客户就是分离接口 分离接口的两种方式： 使用委托分离接口 使用多重继承分离接口 依赖倒置原则（The Dependency Inversion Principle）定义高层模块不应该依赖于低层模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。 设计的层次化 所有结构良好的面向对象架构都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供了一组内聚的服务。 这里的倒置不仅仅是依赖关系的倒置，它也是接口所有权的倒置。 程序中所有的依赖关系都应该终止于抽象类或者接口 任何变量都不应该持有一个指向具体类的指针或者引用。 任何类都不应该从具体类派生。 任何方法都不应该覆写它的任何基类中的已经实现了的方法。]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2020%2F06%2F20%2Fpatterns%2Fstate%2F</url>
    <content type="text"><![CDATA[简介状态模式 有点类似策略模式，同样是变化，只是应对变化的方式不一样而已。策略模式面对变化，是采取将变化的部分与不变的部分分离开来，采取封装算法族的方式进行抽象，具体实现只需对不同接口进行组合。而状态模式，变化的部分取决于对象的内部状态，通过当前的状态来决定每个方法的具体实现。 思路《Head First设计模式》给了一个糖果机的案例，它的运行机制是这样的：首先糖果机有四种状态，分别是没有25分钱、有25分钱、售出糖果、糖果售罄。同时，导致糖果机状态变化也对应着四个动作，分别是：投入25分钱、退回25分钱、转动曲柄、发放糖果。糖果机的状态转化关系如下： 如图，糖果机的实现应该包含四个方法，而且每个方法的具体行为跟糖果机当前的状态有关系。比如说，当没有25分钱时是不能退回25分钱和售出糖果的。当转动曲柄的时候，如果没有糖果应该提醒顾客已售空。 实现在使用状态模式之前，我们的 代码实现 可能是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142public class GumballMachine &#123; final static int SOLD_OUT = 0; // 售罄状态 final static int NO_QUARTE = 1; // 没有25分钱 final static int HAS_QUARTER = 2; // 有25分钱 final static int SOLD = 3; // 售出糖果 int state = SOLD_OUT; // 默认为售罄状态，因为没有糖果 int count = 0; public GumballMachine(int count) &#123; this.count = count; if (count &gt; 0) &#123; // 初始化时如果大于0，为没有25分钱 state = NO_QUARTE; &#125; &#125; // 投入硬币 public void insertQuarter() &#123; if (state == HAS_QUARTER) &#123; System.out.println("You cna't insert another quarter"); &#125; else if (state == NO_QUARTE) &#123; state = HAS_QUARTER; System.out.println("You inserted a quarter"); &#125; else if (state == SOLD_OUT) &#123; System.out.println("You can't insert a quarter,the machine is sold out"); &#125; else if (state == SOLD) &#123; System.out.println("please wait,we're already giving you a guaball"); &#125; &#125; // 退回硬币 public void ejectQuater() &#123;&#125; // 转动曲柄 public void turnCrank() &#123;&#125; // 发放糖果 public void dispense() &#123;&#125; // 其他方法 &#125; 这样子实现也没什么问题，但是随着业务的变更，比如需要有10%的可能会掉下两个糖果，发现上面的代码并没有遵循开闭原则、状态转化埋藏在条件语句中，并不好理解。更重要的是没有将会变化的部分封装，牵一发而动全身，未来很有可能导致隐藏的bug。 重构在重构之前，我们先梳理一下逻辑： 首先，我们定义一个State接口，在这个接口内，糖果机的每个动作都有一个实现的方法。 然后，为机器的每个状态实现状态类，这些状态类将负责在对应的状态下进行的行为。 最后，我们要摆脱旧的条件代码，取而代之的是，将动作委托到状态类。 类图设计如下： 状态接口定义为 12345678910public interface State &#123; void insertQuater(); // 投入硬币 void ejectQuater(); // 退回硬币 void turnCrank(); // 转动曲柄 void dispense(); // 发放糖果&#125; 糖果机的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class StateGumballMachine &#123; State noQuaterState; State hasQuaterState; State soldState; State soldOutState; State state = soldState; int count = 0; public StateGumballMachine(int count) &#123; noQuaterState = new NoQuaterState(this); hasQuaterState = new HasQuaterState(this); soldState = new SoldState(this); soldOutState = new SoldOutState(this); this.count = count; if (count &gt; 0) &#123; state = noQuaterState; &#125; &#125; // 投入硬币 public void insertQuarter() &#123; state.insertQuater(); &#125; // 退回硬币 public void ejectQuater() &#123; state.ejectQuater(); &#125; // 转动曲柄 public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; // 发放糖果 public void releaseBall() &#123; System.out.println("A gumball comes rolling out the slot..."); if (count != 0) &#123; count = count - 1; &#125; &#125;&#125; 对应没有25分钱的状态类实现为： 1234567891011121314151617181920212223242526272829public class NoQuaterState implements State &#123; StateGumballMachine stateGumballMachine; public NoQuaterState(StateGumballMachine stateGumballMachine) &#123; this.stateGumballMachine = stateGumballMachine; &#125; @Override public void insertQuater() &#123; System.out.println("You inserted a quarter"); stateGumballMachine.setState(stateGumballMachine.getHasQuaterState()); &#125; @Override public void ejectQuater() &#123; System.out.println("You haven't inserted a quater"); &#125; @Override public void turnCrank() &#123; System.out.println("You turned,but there are no gumballs"); &#125; @Override public void dispense() &#123; System.out.println("You need to pay first"); &#125;&#125; 售出糖果的状态实现 12345678910111213141516171819202122232425262728293031323334public class SoldState implements State &#123; StateGumballMachine stateGumballMachine; public SoldState(StateGumballMachine stateGumballMachine) &#123; this.stateGumballMachine = stateGumballMachine; &#125; @Override public void insertQuater() &#123; System.out.println("please wait,we're already giving you a guaball"); &#125; @Override public void ejectQuater() &#123; System.out.println("Sorry,you already turned the crank"); &#125; @Override public void turnCrank() &#123; System.out.println("Turing twice doesn't get you another gumball!"); &#125; @Override public void dispense() &#123; stateGumballMachine.releaseBall(); if (stateGumballMachine.getCount() &gt; 0) &#123; stateGumballMachine.setState(stateGumballMachine.getNoQuaterState()); &#125; else &#123; stateGumballMachine.setState(stateGumballMachine.getSoldOutState()); &#125; &#125;&#125; 从上面 代码实现 很容易看出，每个状态是如何进行转化的，而且如果需要再添加一种状态的话，也是很容易进行扩展的。总而言之言之，状态模式提升了代码的可读性和可扩展性。 那么，现在回到刚才那个问题： 需要添加可能会一下出两颗糖果的可能，代码应该怎么实现呢？ 定义书上定义为： 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 类关系图为：]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板方法]]></title>
    <url>%2F2020%2F06%2F05%2Fpatterns%2Ftemplate%2F</url>
    <content type="text"><![CDATA[简介模板方法，顾名思义，就是个方法，其实质是对算法的封装。通过继承的方式，将公共的代码封装在父类中，实现代码的复用，将变化的部分抽象成抽象方法，交给子类去实现。通过模板方法，我们就算法封装成先干什么、后干什么，最后干什么，子类实现只需提供对变化部分的具体实现，具体步骤无需在重新定义。一般情况，为了更好的保护程序，不被子类篡改算法，模板方法会用final 修饰。 实现《Head First设计模式》举了一个冲茶和冲咖啡的例子，由于他们包含相同的部分（比如烧开水，装入杯子），但是又包含不同的部分（泡法、加入食材），因此不变的代码可以复用，变化的代码交给子类定义，实现代码如下： 1234567891011121314151617181920public abstract class CaffeineBeverage &#123; final void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; protected abstract void brew(); protected abstract void addCondiments(); private void pourInCup() &#123; System.out.println("Pouring into cup"); &#125; private void boilWater() &#123; System.out.println("Boiling water"); &#125;&#125; 子类需要继承父类，提供具体的实现 12345678910111213public class Tea extends CaffeineBeverage &#123; @Override protected void brew() &#123; System.out.println("Steeping the tea"); &#125; @Override protected void addCondiments() &#123; System.out.println("Adding Lemon"); &#125;&#125; 定义书上定义为： 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 类图为： 扩展钩子hook在定义的父类中，我们可以定义一个空方法。当子类需要使用时，可以去覆盖该方法，当没覆盖时，就什么都不干。 好莱坞原则该原则有点类似前面的依赖倒置原则 别调用（打电话）我们，我们会调用（打电话）你。 应用模板方法一个典型的例子就是定义排序算法，比如冒泡排序、插入排序、选择排序等等。 源码案例双亲委派模型、AQS算法、spring的refresh方法 实际开发计算引擎消息架构、报表打印实现]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2020%2F05%2F30%2Fpatterns%2Fcommands%2F</url>
    <content type="text"><![CDATA[简介命令模式，通过对请求命令的封装，对命令的请求方和执行方进行解偶，书本上举例了顾客点餐的过程，顾客下单点餐，然后服务员将菜单拿给厨师制作，通过菜单实现了顾客与服务员，服务员与厨师之间的解偶。 实现定义一个命令接口，接口只有execute方法 1234public interface Command &#123; void execute();&#125; 对命令的一种实现，比如：打开电灯泡，这里封装了灯泡对象 12345678910111213public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125; 遥控器可以执行命令对象，至于命令具体是怎么执行，我不需要关心，因为封装在请求里面了 12345678910111213141516public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl() &#123; &#125; public void setCommand(Command command) &#123; this.slot = command; &#125; public void buttonWasPressed() &#123; slot.execute(); &#125;&#125; 对遥控器进行简单测试 12345678910111213141516171819public class SimpleRemoteControlTest extends AbstractTest &#123; SimpleRemoteControl simpleRemoteControl = null; Light light = null; Command command = null; @Before public void setUp() throws Exception &#123; simpleRemoteControl = new SimpleRemoteControl(); light = new Light(); command = new LightOnCommand(light); &#125; @Test public void buttonWasPressed() &#123; simpleRemoteControl.setCommand(command); simpleRemoteControl.buttonWasPressed(); &#125; &#125; 通过测试我们看到，遥控器可以set不同的命令，至于命令的接收者封装在了命令的实现当中，遥控器漠不关心，只是执行了command.execute()方法，具体干嘛了也不知道，这样实现了客户请求与请求执行之间的解偶，我们的类关系图如下： 定义在书上定义为： 将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 类图为： 应用在实际的开发中，我们用到命令模式的地方有：线程池、工作队列。 命令可以支持撤销操作，所以一个常见的用于日志请求，比如电脑死机数据恢复处理，mysql日志备份和还原。]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2020%2F05%2F24%2Fpatterns%2Ffactory%2F</url>
    <content type="text"><![CDATA[简介工厂模式，顾名思义，就是制造对象的工厂。在学习之前，是存在很大的误解的，之前认识的工厂是简单工厂，它并不属于工厂模式的范畴，真正的工厂模式有两种，分别是工厂方法模式、抽象工厂模式。 工厂方法模式是使用抽象方法，使用子类继承的方式去实现。抽象工厂模式是抽象出一个工厂的接口，用具体的工厂去实现接口，然后采用组合的方式，去解藕。总而言之，两者使用的场景不一样，感觉差别挺大。 静态工厂本章案例是制造Pizza，讲解的思路是：一个店面给顾客制造不同口味的披萨，发现效益不错，别的地方的商店想加盟，希望也能套用你的模板，再到不同地方的商店希望在本地有对应原料加工工厂。可见，随着业务的扩张，带来的变化变化也越来越多，这个时候各个模式就在应对这种变化中产生了静态工厂、工厂方法、抽象工厂 首先是静态工厂，在使用静态工厂前，顾客下订单的实现应该是这样的： 12345678910111213141516171819202122public class PizzaStore &#123; Pizza orderPizza(String type) &#123; Pizza pizza = null; // 变化的部分 if ("cheese".equals(type)) &#123; pizza = new CheesePizza(); &#125; else if ("peperoni".equals(type)) &#123; pizza = new PepperoniPizza(); &#125; else if ("clam".equals(type)) &#123; pizza = new ClamPizza(); &#125; // 不变的部分 pizza.preprae(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 在上面代码中，我们发现ifelse代码是经常发生改变的，每增删一种口味的Pizza就要修改这段代码，这必将造成系统难以维护。在策略模式中学到了应该将变化的部分和不变的部分分离出来，那么我们对这部分代码做一个封装，这就是简单工厂了，单独负责Pizza的创建。 实现的代码如下： 123456789101112131415161718public class SimplePizzaFactory &#123; public Pizza create(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new CheesePizza(); &#125; else if ("peperoni".equals(type)) &#123; pizza = new PepperoniPizza(); &#125; else if ("clam".equals(type)) &#123; pizza = new ClamPizza(); &#125; else if ("veggie".equals(type)) &#123; pizza = new VeggiePizza(); &#125; else &#123; System.out.println("本店没有该口味披萨，请换购其他类型"); &#125; return pizza; &#125;&#125; 当新增新口味的Pizza时，我们只需修改这里的代码，create方法可以声明为静态的，当调用的时候可以不需要创建对象，直接调用。但这种设计不容易扩展，运行的时候不能修改create的行为。 那么，当有不同的加盟商到来时，这个时候create方法不得不变，要怎么办呢？这个时候我们可以这样做： 但是，更大的变化再等着我们，有些加盟商说，想要自己的一套bake、cut、box的方式。 工厂方法工厂方法要求不同的厂商提供自己的create方法，同时可以提供自己一套烘烤、切片、包装的方式。这个时候，工厂方法来解救我们。 简单工厂将create方法进行了抽象，交给子类去实现。当定义的Pizza有自己的烘烤、切片、包装方式时，在子类定义的时候需要进行覆盖。 实现为： 12345678910111213141516public abstract class PizzaStore &#123; Pizza orderPizza(String type) &#123; // 变化的一部分 Pizza pizza = creatPizza(type); // 不变的一部分 pizza.preprae(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; abstract Pizza creatPizza(String type);&#125; 加盟商只需实现该方法，当该加盟商新增一种口味时，只需在以下实现中做一下修改，相比于简单工厂的方式，更加易于维护，而且对系统的影响度更低。 12345678910111213public class NYStylePizzaStore extends PizzaStore &#123; @Override Pizza creatPizza(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new NYStyleCheesePizza(); &#125; else if ("peperoni".equals(type)) &#123; pizza = new NYStylePepperoniPizza(); &#125; return pizza; &#125;&#125; 讲到这里，是不是对工厂方法有了大概的了解，我们来看看到底什么是工厂方法吧！ 工厂方法模式 书上定义为： 定义了一个创建对象的接口，但由于子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 到这里，可以回顾一下，如果使用简单工厂去实现，会是什么样的？会出现一个高度依赖的工厂类，当新增或删减时，对系统的影响是很大的。这样使得PizzaStore类高度依赖所有的Pizza对象，这里违背了我们新学到的一个设计原则依赖倒置原则： 要依赖抽象，不要依赖具体类。 这个原则说明了：不能让高层组建依赖低层组件，而且，不管高层或底层组件，两者都应该依赖于抽象。 所谓高层组件，是由其底层组件定义其行为的类。在这里，PizzaStore是高层组件，因为它的行为是由Pizza定义的，PizzaStore创建所有不同的Pizza对象，准备、烘烤、切片、装盒；而Pizza本身属于底层组件。 抽象工厂到这里，系统已经有了良好的弹性框架，而且遵循设计原则。但是，我们的设计远远没有结束，比萨店成功的关键在于新鲜、高质量的原料，要是在当地建立一个原料的工厂，还能实现更大的利润。 我们首先得定义原料工厂： 1234567891011121314public interface PizzaIngredientFactory &#123; Dough createDough(); Sauce createSauce(); Cheese createCheese(); VeggiePizza createVeggiePizza(); Pepperoni createPepperoni(); Clams createClams();&#125; 将Pizza的parepar进行抽象 12345678910111213141516171819public abstract class Pizza &#123; String name; // 面团 Dough dough; // 酱料 Sauce sauce; // 一套佐料 Cheese cheese; Pepperoni pepperoni; Clams clams; abstract void preprae();&#125; 其实这里就有点类似于工厂方法了，交给子类去实现 12345678910111213141516public class CheesePizza extends Pizza &#123; PizzaIngredientFactory pizzaIngredientFactory; public CheesePizza(PizzaIngredientFactory pizzaIngredientFactory) &#123; this.pizzaIngredientFactory = pizzaIngredientFactory; &#125; @Override void preprae() &#123; System.out.println("Preparing " + name); dough = pizzaIngredientFactory.createDough(); sauce = pizzaIngredientFactory.createSauce(); cheese = pizzaIngredientFactory.createCheese(); &#125;&#125; 最后定义具体的PizzaStore 123456789101112131415161718public class NYPizzaStore extends PizzaStore &#123; PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); @Override Pizza creatPizza(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new CheesePizza(ingredientFactory); pizza.setName("NY Style Cheese Pizza"); &#125; else if ("clam".equals(type)) &#123; pizza = new ClamPizza(ingredientFactory); pizza.setName("NY Style Clam Pizza"); &#125; return pizza; &#125;&#125; 最后测试一下： 12PizzaStore pizzaStore = new NYPizzaStore();Pizza pizza = pizzaStore.orderPizza("cheese"); 可以跟踪一下代码执行 先是创建一个NYPizzaStore实例：PizzaStore pizzaStore = new NYPizzaStore(); 有了Pizza店了，接受订单：pizzaStore.orderPizza(&quot;cheese&quot;); orderPizza会先调用creatPizza方法：Pizza pizza = creatPizza(type); creatPizza方法调用时，涉及到原料工厂了：pizza = new CheesePizza(ingredientFactory); 拿到Pizza后，会调用prepare方法： 123456void preprae() &#123; System.out.println("Preparing " + name); dough = pizzaIngredientFactory.createDough(); sauce = pizzaIngredientFactory.createSauce(); cheese = pizzaIngredientFactory.createCheese();&#125; 最后，得到准备好的Pizza，orderPizza就会接着烘烤、切片、装盒。 抽象工厂模式在书上定义为： 提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。 代码链接 模型如图所示：]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2020%2F04%2F15%2Fpatterns%2Fstrategy%2F</url>
    <content type="text"><![CDATA[简介《Head Filst 设计模式》的第一章，讲的就是策略模式，策略模式算是一切模式的根本。在我理解看来，所有的模式都是由于随着业务的不断扩大，为了使得系统具有良好的扩展性、维护性而产生的，一种设计模式反应了很多个类之间的关系，使得系统耦合性更低，更容易扩展和维护。 思路策略模式讲解了一个关于Duck的相关设计案例，Duck有display、quack(呱呱叫)、swim的行为。起初的时候，设计是使用继承，发现随着变化，有的鸭子会fly，需要在父类里面加上fly方法，这下惨了，其实有些鸭子是不会飞的（不得不覆盖，空实现），导致噩梦的产生。 这是违背了原则3，由于继承带来的强耦合性。 后来考虑将quack、fly是变化的，那就把他们都抽象为一种行为吧，抽象出quackable、flyable接口怎么样，子类只要有以上两种行为，就去实现这个接口。但是问题又来了，如果有100种鸭子，就有100种flyable的实现，太可怕了吧，这样就没能代码复用。 代码复用才是我们设计的根本啊。 然后，设计模式登场了。 原则1：找出应用中可能需要变化之处，把它么独立出来，不要和那些不需要变化的代码混合在一起。 由于，在所有的实现中，swim的实现是唯一的，这是不会变的。而quack、fly是变化的，那么我们将这一部分抽象出去，交给一个专门的地方去实现，当需要使用的时候，我只需使用组合的方式，这样就能降低耦合度了。当然，我不能使用实现类组合的方式，因为，这样耦合度也太高了。那么，就使用接口吧！ 原则2：针对接口编程，而不是针对实现编程。 最后，我们的思路是这样的： Duck依然是抽象类，里面有swim实现方法、display抽象方法、还依赖了两个接口，分别是QuackBehavior接口、FlyBehavior接口，在quack方法里调用QuackBehavior.quack()、在fly方法里调用FlyBehavior.fly()，至于实现是什么，交给子类去决定。 原则3：多用组合，少用继承。 那么，子类决定的方式有哪两种方式呢 第一是使用构造器 第二是使用set方法 最后，类的实现是这样的： 总之，策略模式就是将这种变化封装了起来，放在另一个地方实现。那么，你脑子里面有类图了吗？有了之后就可以将代码落地了，哈哈！ 定义在书上其定义为： 定义了算法族，分别封装了起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 应用在我们工作中，策略模式的典型应用就是if条件很多的情况，将这部分变化的代码拿出来，不要将不变的代码混在一起，使用接口的方式降低耦合性，具体实现交给子类去实现。 补充这是我的代码实现、类图，欢迎来star😄 代码链接]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2020%2F04%2F12%2Fpatterns%2Fsingleton%2F</url>
    <content type="text"><![CDATA[简介单例模式，也叫单件模式。顾名思义，就是程序中只有一个实例。一般在我们实际工作中，会经常遇到这个模式，所以，掌握这个模式是应该的。 定义单件方式可以有很多中方法定义，可根据不同的应用场景来选择最合适的定义方式。根据目前所学习的知识，可分为以下五种，某些可能在多线程的环境下回出现安全问题，需要改进。 《Head Filst 设计模式》中定义为： 单件模式确保程序中一个类只有一个实例，并且能够提供访问这个实例的全局访问点。 饥汉式也叫饿汉式，二话不说 ，当jvm加载类时，就将类的静态实例初始化。 12345678910111213public class SingleInstanceT00 &#123; // 构造器私有化 private SingleInstanceT00() &#123; &#125; public static SingleInstanceT00 instance = new SingleInstanceT00(); public static SingleInstanceT00 getInstance()&#123; return instance; &#125;&#125; 在没有空间限制的情况下，可以选择这样使用。但是更优雅的做法是，调用的时候进行初始化，也就是延迟初始化。 延迟初始化延迟初始化会带来线程安全的问题，比如改造后的代码为： 12345678910111213141516171819202122public class SingleInstanceT01 &#123; // 构造器私有化 private SingleInstanceT01() &#123; &#125; public static SingleInstanceT01 instance = null; public static SingleInstanceT01 getInstance() &#123; if (instance == null) &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; instance = new SingleInstanceT01(); &#125; return instance; &#125;&#125; 经测试后发现，多个线程同时进入getInstance后，得到的不是同一个实例。 为了使得线程安全，解决方案也分为很多种，有synchronized同步方法、双重检查锁定和静态内部类初始化三种。 同步方法使用synchronized对getInstance方法进行同步处理，但会导致不必要的性能开销。如果getInstance()方法被多个线程频繁调用，将会导致程序执行的性能下降。只有不频繁调用的时候，可能是理想状态。实现方式为： 1234567891011121314151617181920212223public class SingleInstanceT02 &#123; // 构造器私有化 private SingleInstanceT02() &#123; &#125; public static SingleInstanceT02 instance = null; // 同步方法作用域太大，性能低 public static synchronized SingleInstanceT02 getInstance() &#123; if (instance == null) &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; instance = new SingleInstanceT02(); &#125; return instance; &#125;&#125; 使用synchronized 同步方法时可以不用加volatile，因为synchronized 可以保证原子性。 双重检查锁定双重检查锁定使用synchronized同步代码块的方式成功的优化了性能。只有第一次进来的时候，才需要加锁。其他时候进来的时候先判断instance是否为空，如果不为空的话，就直接进行返回。 12345678910111213141516171819202122232425262728public class SingleInstanceT03 &#123; // 构造器私有化 private SingleInstanceT03() &#123; &#125; public static volatile SingleInstanceT03 instance = null; public static SingleInstanceT03 getInstance() &#123; if (instance == null) &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 同步代码块 DCL synchronized (SingleInstanceT03.class) &#123; if (instance == null) &#123; instance = new SingleInstanceT03(); &#125; &#125; &#125; return instance; &#125;&#125; 注意：加volatile是为了防止指令的重排序，在jvm执行指令时，instance = new SingleInstanceT03() 分了三步： 第一步：给对象分配内存空间 第二步：成员变量初始化 第三步：将instance指向刚分配的内存地址（此时还是半初始化状态，有属性的话，属性尚未赋值） 如果没有加volatile，第二步和第三步会交换顺序执行，导致其他线程拿到的是半初始化的实例，拿到未初始化的数据（比如秒杀系统拿到的值为0，带来重大安全隐患）。 类初始化这也是延迟初始化的一种，基于类初始化实现的。实现原理是每个对象对应有一个初始化锁，初始化时线程需要获取该对象对应的初始化锁。如果没有获取，那么线程必须等到初始化锁释放了才能获取。 12345678910111213141516171819public class SingleInstanceT04 &#123; private SingleInstanceT04() &#123; &#125; private static class InnerInitialClass &#123; public static SingleInstanceT04 instance = new SingleInstanceT04(); &#125; // 原理：每个对象对应有一个初始化锁，初始化时线程需要获取该对象对应的初始化锁 public static SingleInstanceT04 getInstance() &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return InnerInitialClass.instance; &#125;&#125; 应用在《Head Filst 设计模式》提到，使用单件模式的地方很多。常见的有线程池、连接池、缓存、日志对象。 还用一些不常见的，对话框、处理偏好设置、注册表的对象、充当打印机、显卡等设备的驱动程序的对象。]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[是时候揭开线程池这块面纱了（二）]]></title>
    <url>%2F2020%2F03%2F18%2Fconcurrentart%2Fthreadpool-usages2%2F</url>
    <content type="text"><![CDATA[线程池状态定义在简单介绍完线程池的基本概念后，这篇文章我们来分析一下，线程池它具体是如何工作的。首先我们看一下线程池的状态。线程池的设计是这样子的，它将线程池的状态和目前工作线程的线程数用一个变量来进行了存储，就是ctl变量 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 首先这是一个原子类，int类型，32位，前3位是用来标识线程池的状态的，后29位是用来表示线程池当中工作的线程数的。 通过使用原子类，这样就能保证线程池的状态和工作线程数的原子性了。那么，我们当前线程池的状态常量是如何标识的呢，以及当我们想要查询线程池的工作线程数，是怎样运算的呢。 123456789101112131415161718private static final int COUNT_BITS = Integer.SIZE - 3; // 29位用来存工作线程数private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 所能存放工作线程的最大数 000 1111...// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 运行状态 补码形式为：1110 00……private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 关闭状态 0000 ....private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 停止状态 0010 00……private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 清理状态 0100 00……private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 终止状态 0110 00……// Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; // 后28位取1 按位与操作private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; // 后29为取0 与运算private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; // 根据状态和工作数生成ctlprivate static boolean runStateLessThan(int c, int s) &#123; return c &lt; s;&#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; 线程池有5种状态，按小到大的顺序如下：RUNNING&lt;SHUTDOWN&lt;STOP&lt;TIDYING&lt;TERMINATED 使用原子类来存储两个变量，保证了共享变量的原子性，以及它按照位操作提升了很大的性能 状态解析RUNNING：in operation 运行，当线程池初始化的时候，线程池就处于RUNNING状态，处于该状态时，线程池可以接受任务，并且处理缓冲的任务。 SHUTDOWN：turn off 关闭，当调用shutdown()方法时，线程池从RUNING转化为SHUTDOWN状态，该状态的线程池不接受任务，只处理缓冲的任务 STOP：stop 停止，当调用shutdownNow()方法时，会将（RUNING/SHUTDOWN状态）转换成该状态，处于该状态的线程池不接受任务，不处理缓冲任务，并且中断全部正在处理的任务interrupt running tasks TIDYING：清理，当任务中断了，并且线程工作数为0，就会进入清理状态，清理现场。 When the thread pool is in the SHUTDOWN state, the blocking queue is empty and the tasks executed in the thread pool are also empty, it will be SHUTDOWN - &gt; tidying. When the task executed in the thread pool is empty in the STOP state, it will be STOP - &gt; tidying. TERMINATED：终止，结束，当terminated()方法执行完后，就会进入该状态 When the thread pool terminates completely, it becomes terminated. When the thread pool is in tidying state, after executing terminated(), it will be tidying - &gt; terminated. 状态转化1234567891011* RUNNING -&gt; SHUTDOWN* On invocation of shutdown(), perhaps implicitly in finalize()* (RUNNING or SHUTDOWN) -&gt; STOP* On invocation of shutdownNow()* SHUTDOWN -&gt; TIDYING* When both queue and pool are empty* STOP -&gt; TIDYING* When pool is empty* TIDYING -&gt; TERMINATED* When the terminated() hook method has completed* 通过介绍我们知道，线程池初始化时处于RUNNING状态，当线程池调用shutdown()方法时，线程池就关闭了，只处理当前已经进来的任务。当任务处理完之后，线程池会调用terminated()方法，执行完后线程池进入TERMINATED状态。当然还有另一种方式，不管线程池有没有调用shutdown()方法，如果调用了shutdownNow()，会中断正在执行的线程，当队列和线程池线程为空时，线程池就会进入stop状态。当池中线程为空时，terminated()方法执行完后进入TERMINATED状态。 构造方法123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); // 主线程不能小于0 if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 队列和线程工厂、策略不能为null this.acc = System.getSecurityManager() == null ?null :AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime);//将时间传入的unit和keepAliveTime转换为ns this.threadFactory = threadFactory; this.handler = handler;&#125; 提交执行task的过程​ 解释当提交一个新任务到线程池时，线程池的处理流程如下： 线程池判断核心线程数是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果是，则进入步骤2。 线程池判断工作队列是否已满。如果没有满，将新提交的任务存储在工作队列中。如果满了，则进入步骤3。 线程池判断线程池中线程是否都处于工作状态（已满）。如果没有，则创建一个新的工作线程。如果满了，则交给饱和策略来处理这个任务。 execute方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 如果任务不能提交，要么是因为当前线程池关闭了，要么是因为队列满了需要触发饱和策略 */public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); // worker数量比核心线程数小，直接创建worker执行任务 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // worker数量超过核心线程数，任务直接进入队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // 线程池状态不是RUNNING状态，说明执行过shutdown,需要对新加入的任务做reject操作 // 这儿为什么需要recheck,是因为任务入队前后，线程池的状态可能发生变化。但是一般检查一下，并没啥用。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 这儿为什么需要判断0值，是因为线程池构造方法中，允许线程池的核心数为0，如果遇上SynchronousQueue类型的队列，我也能创建线程去消费，不会一直阻塞 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 如果线程池不是运行状态，或者任务进入队列失败，则会尝试创建worker执行任务 // 注意3点 // 1. 线程池不是运行状态时，addWorker方法内部会去判断线程池状态 // 2. addWorker的第二个参数表示是否创建核心线程 // 3. addWorker方法返回false，说明任务执行失败，需要执行reject操作 else if (!addWorker(command, false)) reject(command);&#125; execute方法本身来说并不难，我们来这样子分析。 第一步，传入来的command不能为空 第二步，取到当前ctl，拿到当前工作线程数与核心数比较，如果小于，直接创建worker执行任务，否则进入下一步。 注意，addWorkerf方法的第二个参数表示是否核心线程。方法本身会去判断当前线程池状态和数量的，如果addWork失败，方法会返回false，表示添加任务失败，在重新获取一下ctl，用于下一步 第三步，走到这一步说明，不是核心数满了，就是线程池shutdown了。看一下当前线程池状态，如果是运行状态，就尝试往队列中放任务，如果放成功了返回true，放任务前后都得去拿一下当前的ctl，再去判断一下线程池是否shutdown了，如果shutdown了，就把任务从队列中remove掉。如果没有shutdown，会去判断当前工作线程数。 如果为0，我就启动一个线程，并且这里传入的firstTask还是null，这是为什么呢? 第四步，这一步相当重要，走到这一步，说明线程池不是运行状态了，或者任务进入队列失败了，为了消费任务，会尝试创建（非核心）worker执行任务，如果创建失败，则要采取饱和策略，执行reject操作。 addWorker源码解析干了两件事情 使用CAS算法将workerCount加一 将任务装入到worker中，并且将work添加到工作线程集合workers中,开始执行任务 worker是一个任务单元，继承了AQS类，本身是把锁，而且构造方法是RUNNALE任务，因此可以使用start方法执行线程中的run方法 如果线程启动失败，将这个worker从当前线程池works集合中删除，并且将workerCount减一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 外层自旋 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; // 如果状态&gt;SHUTDOWN,返回false ! (rs == SHUTDOWN &amp;&amp; // 如果状态=SHUTDOWN，且task!=null,返回false firstTask == null &amp;&amp; // 如果状态=SHUTDOWN，且队列为空，返回false ! workQueue.isEmpty())) return false; // 内层自旋 for (;;) &#123; int wc = workerCountOf(c); // 判断工作线程数，是否超过最大值和标准值 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 使用一次CAS算法，使得c++,就是wc++ if (compareAndIncrementWorkerCount(c)) // 如果成功，跳出外部循环进入第二部分 break retry; // 如果失败，应该是有线程把ctl改了，比较一下 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) // 不等于的话进入外部循环自旋，重新获取ctl continue retry; // else CAS failed due to workerCount change; retry inner loop（等于的话，内部自旋） &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; // worker的添加必须是串行的，必须得加锁 mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 重新检查线程池状态 int rs = runStateOf(ctl.get()); // 如果处于RUNNING状态或者SHUTDOWN时传递的任务为空 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // 如果worker已经调用过start方法了，则不再创建了 if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 创建并且加入到works成功 workers.add(w); // 更新largestPoolSize变量 int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // 启动worker线程 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; // worker启动失败，说明线程状态发生了变化（关闭操作被执行），需要执行shutdown相关操作 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; worker任务单元worker是一个任务单元，他里面包含了一个线程，和一个任务，然后还记录了我这个worker干过多少个任务等等。 123456789101112131415161718192021222324252627282930313233343536private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; // 这里使用了我们之前定义的线程工厂，传入的参数我当前的worker this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; // run方法的实现在runWorker里面 runWorker(this); &#125; //省略代码……&#125; runworker核心线程执行逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; // for GC // 允许外部中断 w.unlock(); // allow interrupts // 用于判读是否进入过自旋 boolean completedAbruptly = true; try &#123; // 自旋 // 如果task不为空，则开始执行task // 如果不为空，则从队列中获取task开始执行 // 阻塞队列的特性：就是当队列为空的时候，当前线程会被阻塞 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt // 如果线程池正在停止，则对当前线程中断 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // beforeExecute和afterExecute 是为扩展功能用的，在当前类实现默认为空 beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; // for GC w.completedTasks++; // 已完成任务数加一 w.unlock(); &#125; &#125; completedAbruptly = false; //表示已经自旋完成 &#125; finally &#123; // 自旋操作被退出，说明线程池正在结束，要把wc--，并且从workers删除当前worker processWorkerExit(w, completedAbruptly); &#125;&#125; 这里相当于用到了一种装饰者模式，将一个task包装成一个带有锁特性的执行者。这个执行者不仅可以消费当前的任务，getTask 还能从阻塞队列中获取任务消费，当队列为空的时候，线程会被阻塞住。当有任务过来的时候，又可以执行了。当任务执行完之后，processWorkerExit 方法是线程worker的出口。他会处理wc和workers集合，并且尝试将当前线程中断。 参考： Deep understanding of thread pool ThreadPool Executor Do you know the underlying implementation of thread pools?Thread Pool Module Summary 能说说什么是线程吗？线程模块总结]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>threadpool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS与ReentrantLock]]></title>
    <url>%2F2020%2F03%2F16%2Fconcurrentart%2Faqs%2F</url>
    <content type="text"><![CDATA[定义AQS是并发体系中一个非常重要的类，ReentrantLock就是基于AQS实现的，AQS底层使用了LockSupport类实现对线程的等待通知机制，相比于wait和notify方法，使用的更加的灵活，所以，要学习并发线程的底层知识，这个类你必须要学明白。 初始化默认初始化，为非公平锁，为什么？ 1234567891011121314151617/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125;/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; Sync类他们都是继承Sync抽象类，Sync继承了AQSAbstractQuenedSynchronizer 抽象类，AQS是并发里面十分重要的一个类，jdk1.7中ConcurrentHashMap曾使用过ReentranLock用于分段锁，在线程池中Worker(任务单元)也是用到了AQS。因此，要学习并发，必须把这个类学明白。 类图 AQS类123456789101112131415public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; private transient volatile Node head; private transient volatile Node tail; private volatile int state; static final class Node &#123; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; &#125;&#125; 在AQS内部维护了state字段，表示当前资源是否已经有线程对他进行了加锁，每一次加锁，该值都会加一，每次解锁，该值都会减一。 源码lock在lock方法，我们看到它调用了sync.lock()，sync.lock调用了acquire(1). 12345678910public void lock() &#123; sync.lock();&#125;static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125;&#125; 再跟进到acquire(1)里，可以看到AQS的一个模板方法 12345678public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123; selfInterrupt(); &#125; &#125;&#125; 这里可以知道acquire干了三件事情 tryAcquire：当前线程尝试获得锁（state），如果获得锁成功，则结束。如果获取失败，进入步骤2 addWaiter：添加一个等待者，将当前线程以排他形式扔到队列里面 acquireQueued：以排队的方式将阻塞的线程一个一个唤醒 tryAcquireFairSync对tryAcquire的实现 12345678910111213141516171819202122232425262728293031static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 首先是先拿到当前线程，获取当前state值，看一下是否等于0，等于0表示我当前可以对他进行加锁，但是公平锁我需要去检查一下队列，看当前队列是否有别的线程已经在排队了，如果有的话，就不去CAS，返回false，如果没有（即为空或者当前线程是队头），就去CAS获取锁，返回true，hasQueuedPredecessors实现如下： 123456789101112131415/* @return &#123;@code true&#125; if there is a queued thread preceding the * current thread, and &#123;@code false&#125; if the current thread * is at the head of the queue or the queue is empty * @since 1.7 */public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 没有其他线程的话，就给自己上锁，使用CAS(compareAndSetState)将state从0设置为1，如果这中间state被别的线程改了，则加锁失败，返回false。 如果state!=0的话，会检查当前线程是否是拥有锁的线程，如果是，将state+1，表示重入。 addWaiter当tryAcquire拿到锁以后就结束了，表示加锁成功。如果拿不到锁，那么就将调用addWaiter方法，将当前线程添加到队列的尾端，相当于排队等待被唤醒嘛，来看看它是如何实现的。 1234567891011121314151617181920212223242526272829303132/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; return node;&#125; addWaiter方法有一个参数，指定了传Node.EXCLUSIVE 排他锁或者是Node.SHARED 共享锁，addWaiter做了两件事情： 一上来就使用一次CAS将要添加的线程加入到队列尾部，这是在队列不为空的情况下操作的，所以得先判断一下。 如果失败的话，那说明有竞争，已经有线程也在往队列里面排，那么我就不断的试，直到将线程续接在队列的尾部。 acquireQueued当线程插入到队列中后，那么队列里的线程会排队的去获得锁，那么是如何实现的呢？（这些线程是不是全阻塞了啊） 1234567891011121314151617181920212223242526272829/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return &#123;@code true&#125; if interrupted while waiting */final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 首先它看一看前置节点是不是头节点，如果不是，那就阻塞parkAndCheckInterrupt。如果是，那就尝试获取锁，这里会和头节点产生竞争，如果竞争到锁，表示头节点已经释放了（因为头节点总是先获得锁，等释放后才会唤醒队列里的线程），然后将当前节点置为头节点。如果没有竞争到锁，说明头节点还没有释放，然后检查一下，停止尝试释放锁cancelAcquire unlock那么，程序是如何释放锁并且释放完后，是如何通知到的后置节点的呢，有必要去看一下unlock方法了 unlock方法调用了sync.release(1)方法，AQS对该方法实现如下 12345678910111213141516171819/** * Releases in exclusive mode. Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryRelease&#125; but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; */public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 这里干了两件事情： tryRelease：释放锁 unparkSuccessor：唤醒头节点 tryRelease释放锁很简单，将state-1，如果是0的话，需要将锁的当前拥有者置为空。 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; unparkSuccessor这里唤醒的话，不是唤醒队列里的所有线程，而是唤醒队列的头节点，因此在唤醒之前需要判断一下队列是否为空。 12345678910111213141516171819202122232425262728293031/** * Wakes up node's successor, if one exists. * * @param node the node */private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 可以看到AQS内部对每一个线程Node同时维护一个waitStatus字段，这是唤醒其他线程的核心。如果队列中线程被为空或者被cancelled，就会递归找到没有cancelled的那个节点。 公平锁与非公平锁那么，学到这里，我们来回答一下开头那个问题，为什么要默认为非公平锁？公平锁与非公平锁的区别？ 看过代码知道，公平锁是要排队的，当线程竞争时，多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 那么非公平锁是什么个概念呢？非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 对比一下代码，也是调用了sync.lock方法 123456789101112131415161718192021/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 这里，一来就去使用CAS尝试获取锁，如果刚好锁释放了，队列的头节点还没加锁，当前线程就有可能拥有这把锁。否则的话，调用 acquire(1)方法 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire模版方法是一样的，分三步：加锁、加锁不行放等待队列，看看排队是否到我获取锁了。 唯一的区别是tryAcquire的实现方式。这里不会去检查队列hasQueuedPredecessors，因为非公平锁，是无序的，如果state为0的话，就直接使用一次CAS竞争，谁先拿到锁，谁就先执行，否则就阻塞等待。 12345678910111213141516171819202122/** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 总结综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2020%2F03%2F14%2Falgorithm%2Fsortway-algorithm%2F</url>
    <content type="text"><![CDATA[今日复习任务：实现数据从小到大的排序方式，分别有冒泡、选择、插入、快排、归并 冒泡排序思想：大的数往往上冒，每遍历一次，后面的几位是排好顺序的。第一次遍历得到最大的数，在末尾，第二次遍历，次大的数在倒数第二位，需要遍历n-1次，所有的才能排好顺序。 12345678910111213 /** * @Description 选择排序 * TODO 时间复杂度 O(n^2) **/public static void maoPaoSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j+1); &#125; &#125; &#125;&#125; 优化 123456789101112131415161718/*** @Description 选择排序* TODO 性能优化 对于已经排好序的部分，直接退出外部循环，因为存在重复比较。**/public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; boolean isOrder = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); isOrder = false; &#125; &#125; if (isOrder) &#123; break; &#125; &#125;&#125; 由于有大量的重复比较，在每次比较的时候，用一个变量标识表示这轮遍历是否都已经排好顺序了，如果都排好顺序了，就直接跳出循环。可想而知，当排好序的情况下，是最好的情况，时间复杂度为O(n)。最坏情况是O(n^2),对于同样大小的数是不需要移动的，可以保证之前的顺序，所以是稳定的。 选择排序思想：有点类似冒泡，每次也是得到一个排好顺序的位置。选择一个数，逐个跟其他的比较大小。比如，取第一个，如果有比它小的数，则交换位置。 12345678910111213/** * @Description 选择排序 * TODO 最好,最坏，平均的情况 都是 n^2 【不稳定】 **/public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; swap(arr, i, j); &#125; &#125; &#125;&#125; 选择排序不管是有序无序都会进行选择比较，因此时间复杂度都是O(n^2)，为什么不是稳定的？ 因为每次比较都可能会交换问题，比如3，2，2，1，1，相邻的两个2在第一轮遍历的时候顺序就打乱了。 插入排序思想：把元素分为两部分，前部分是排好队的部分，后部分是还没有排好队的，当第一次遍历时，第一个元素是排好队的，第二个及之后的元素是需要插入到前面的，所以每次遍历的时候，拿第i+1个元素与前面的元素逐个比较，如果小于，交换元素。指针j继续往前移动，直到arr[i]大于arr[j]或者j&lt;=0 1234567891011/** * @Description 插入排序 * TODO 时间复杂度 O(n^2) 最坏O(n^2) 最好 O(n) 稳定 **/ public static void chaRuSort(int arr[]) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &gt; 0 &amp;&amp; arr[j - 1] &gt; arr[j]; j--) &#123; swap(arr, j - 1, j); &#125; &#125;&#125; 优化 123456789101112/** * @Description 插入排序 * TODO 最好的情况 n^2,最坏的情况，n^2,平均情况 n^2 【稳定】 **/public static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int key = arr[i]; for (int j = i - 1; j &gt;= 0 &amp;&amp; key &lt; arr[j]; j--) &#123; swap(arr, j + 1, j); &#125; &#125;&#125; 原理是一样的，更加容易理解一些，并且性能更好，因为每次比较的时候可以利用局部性缓存原理。 优化 1234567891011121314/** * @Description 插入排序 * TODO 对swap方法的优化，避免多次数据的赋值交换 **/public static void insertSort_improve(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int key = arr[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; key; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[j + 1] = key; &#125;&#125; 跟前一种思想一样，只是没有使用swap方法了，前面遍历，移动位置，最后找到key应该插入的位置，赋值就OK。 优化 12345678910111213141516/** * @Description 插入排序 * TODO 避免不必要的重复，最好情况下时间复杂度为 n(o) **/public static void insertSortImprove(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int key = arr[i]; for (int j = i - 1; j &gt;= 0; j--) &#123; if (key &lt; arr[j]) &#123; swap(arr, j + 1, j); &#125; else &#123; break; &#125; &#125; &#125;&#125; 避免不必要的重复比较，如果一开始比较比前面的数小，那直接跳出本次内部循环。 快速排序思想：选择一个哨兵，以这个为基准，对剩余的元素进行比较，小的排左边，大的排右边。当进行完一次遍历后，找到了当前哨兵所应该在的位置。然后对左右两部分递归，选择各自的哨兵，进行排序，当排完之后，就是有序的了。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @Description 快速排序 * TODO 使用分而治之的思想,平均时间复杂度为O(nlgn) 不稳定，交换有点类似选排 * 最坏的情况是选到的哨兵两个极端（最大值/最小值），导致O(n^2) **/public static void quick_sort(int[] arr) &#123; quick_Sort(arr, 0, arr.length - 1);&#125;private static void quick_Sort(int[] arr, int min, int max) &#123; if (max &gt; min) &#123; int partIndex = partition(arr, min, max); quick_Sort(arr, min, partIndex - 1); quick_Sort(arr, partIndex + 1, max); &#125;&#125;private static int partition(int[] arr, int min, int max) &#123; int key = arr[min]; while (max &gt; min) &#123; while (max &gt; min &amp;&amp; arr[max] &gt;= key) &#123; max--; &#125; // 将从右往左数比哨兵第一小的数赋值给左侧第一个数 arr[min] = arr[max]; while (max &gt; min &amp;&amp; arr[min] &lt;= key) &#123; min++; &#125; // 将从左往右数第一个比哨兵大的数，赋值给max处的下标，再比较min与max的大小 // 进入下一次循环，直到min=max arr[max] = arr[min]; &#125; arr[max] = key; return max;&#125; 程序有两处容易犯错的地方，第一处是quick_Sort()方法的递归调用，调用外部递归是因为，每次要使的左右两边有序。第二处是partition()方法有两处while循环，当内部循环之后，两处的交换赋值，需要注意。 快排的平均时间复杂度为O(nlogn)，对于排好序（升序或者倒序）的数组，表现的性能最差，因为每次遍历，选择到的哨兵是最大的或者最小的，导致每次遍历完，左侧的要么全是最大的或是最小的，导致没有二分的效果，时间复杂度接近于O(n^2)。 为了避免这种情况，重点在于选择哨兵的方法，我们可以选择数组的中间的那个数做哨兵，也能使用随机数选择，避免出现最快的情况。 三位数取中 12int index = (min + max) / 2;int key = arr[index]; 随机选择哨兵 123Random random = new Random(47);int index = random.nextInt(max - min) + min;int key = arr[index]; 归并排序思想：使用分而治之的思想，对一个大的任务分解成多个子任务，进行处理，将子任务处理完得到的解合并，就是所求问题的解。在归并排序中，将带排序的元素分成大小大致相同的两个子集合，分别对子集合进行排序（其实对子集合排序很简单，再对子集合进行分，分，分，直到分成单个元素，然后将单个元素进行从小到大合并，得到的就是有序的子集合），最终将排好序的子集合合并成所要排好序的集合。 其分而治之思想实现为： 123456789101112131415/** * @return void * @Author chenjianrong-lhq * @Description 平均时间复杂度 nlogn 稳定 * @Date 2020-04-05 18:26 * @Param [arr, left, right] **/public static void mergeSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int middle = (left + right) &gt;&gt; 1; mergeSort(arr, left, middle); // 分 mergeSort(arr, middle + 1, right); merge(arr, left, middle, right); // 治、合 &#125;&#125; 上面一步很容易理解，也有点类似快排。其重要的实现在于将单个元素进行从小到大合并，其中间的过程会产生多个有序的子集合，因为涉及到递归，必会开辟多个栈空间进行方法的运算和存储，所以相比于非递归，递归算法的运算效率较低，在计算时间上和占用空间上都差于非递归实现。当然，可以想一想如何消除递归，用非递归方法实现归并排序？ 将单个元素进行从小到大合并实现，可以简单的抽象为有两个排好序的长度为n/2数组，现在要按照从小到大组合成长度为n的数组，这组合的过程中要考虑多个不同的情况，共以下三 种： 左边的数全部比右边小 右边的数全部比左边的小 左边的数有比右边的小，也有比右边的大的（这个时候先取小的，再遍历比较） 具体 实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940private static void merge(int[] arr, int low, int middle, int high) &#123; // 定义组合后的数组 int[] temp = new int[arr.length]; // 组合数组的下标标识 int k = low; // 左部分的开始下标 int i = low; // 右部分的开始下标 int j = middle + 1; // 从左至右开始遍历 for (int m = low; m &lt; high; m++) &#123; if (m &gt; middle) &#123; // 表示左边元素已经处理 temp[k] = arr[j]; k++; j++; &#125; else if (j &gt; high) &#123; // 表示右边的元素已经处理 temp[k] = arr[i]; k++; i++; &#125; else if (arr[i] &gt; arr[j]) &#123; // 表示左边的数大于右边，取右边 temp[k] = arr[j]; k++; j++; &#125; else &#123; // 表示左边的数小于右边，取左边 temp[k] = arr[i]; k++; i++; &#125; &#125; // 数组的拷贝 for (int n = 0; n &lt; temp.length; n++) &#123; arr[n] = temp[n]; &#125;&#125; 总结以上几种排序是我们最熟悉的排序，也是面试时候经常会问到的排序，理解每种排序的思想远远比记住代码更重要。 最后我们总结归纳： 稳定的排序有三种：冒泡、插入、归并 在已经排好序的情况下 ，应该选择哪几种排序：优化的冒泡、插入]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[双向链表LinkedList]]></title>
    <url>%2F2020%2F03%2F13%2Fcollection%2Flinkedlist%2F</url>
    <content type="text"><![CDATA[定义LinkedList的本质是双向链表，与ArrayList相比，LinkedList的插入和删除速度更快，但是随机访问速度则很慢。LinkedList除了实现AbstractLIst抽象类外，还实现了另一个接口Deque，即double-ended queue，这个接口同时具有队列和栈的性质。 123456789101112131415public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; public LinkedList() &#123; &#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125;&#125; 由于链表是使用节点的方式，将内存单元通过附加引用的方式关联的，所以初始化的时候，是不需要指定容量的，也不存在扩容一说。 增添LinkedList默认在尾部增添节点，所以add方法效率有可能高于ArrayList，因为有可能扩容，涉及到数组的复制 add(ele)12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; add(index,ele)12345678public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 当插入下标等于尾节点时，插入尾部，否则，调用 linkBefore方法，插入下标处 123456789101112void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 这里用到了node方法，寻找下标的位置元素 123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 可以看到，node方法进行了一些优化，不是全部遍历的，而是根据靠近头节点还是尾节点进行遍历（相比于全部遍历速度提升了一倍） 删除remove(index)123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; //使节点失效，断掉链接 // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; remove(obj)123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; remove(obj)方法是和ArrayList一样的，从头开始遍历，没什么区别！ clear()12345678910111213141516public void clear() &#123; // Clearing all of the links between nodes is "unnecessary", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; 遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;]]></content>
      <categories>
        <category>collection</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList顺序表]]></title>
    <url>%2F2020%2F03%2F11%2Fcollection%2Farraylist%2F</url>
    <content type="text"><![CDATA[定义ArrayList的本质是顺序表，内部实现是使用数组存储的，集合扩容时会创建更大的数组空间，把原来的数据复制到新数组中。ArrayList支持对元素的快速随机访问，但是插入和删除时速度会很慢，因为这个过程可能要移动其他的元素。 默认大小1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 初始化123456789101112131415private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认初始化状态的校验public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //指定为空，当add时才会扩容&#125; public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity); &#125; &#125; 当没有指定容量时，内部数组指定为空数组，当add的时候才会扩容。 一般明确集合数据量范围的话，我们必须初始化容量，不然遇到大数据量时，会进行多次的扩容，进行数组的复制，降低系统性能。那么，数组是如何扩容的呢？ 扩容12345678910111213141516171819202122232425262728293031323334353637// 当size+1大于length的时候，对容器进行1.5倍扩容public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //增加初始化判断 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //当最多能放的数大于length，进行扩容 grow(minCapacity); &#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5陪扩容 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 当添加100个元素时，容器的扩容跟踪为： 1（new）0——(add first)10—— (add 11)15 --（add 16）22——（add 23）33——（add 34）49...... 这里如果估量一下，如果有1000个元素，会进行多少次扩容呢？ 73——109——163——244——366——549——823——（add 824）1234。 故需要13次扩容 Arrays.copyOf方法实现 123456789101112public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); //调用本地方法扩容 return copy; &#125; 最大容量123456789private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //去掉低三位private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //返回能够扩容的最大值 Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 增添123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; //默认加在最后面 ensureCapacityInternal(size + 1); elementData[size++] = e; return true; &#125;/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); //校验index是否越界 ensureCapacityInternal(size + 1); // Increments modCount和自动扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;/* * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. * @exception IndexOutOfBoundsException if copying would cause * access of data outside array bounds. * @exception ArrayStoreException if an element in the &lt;code&gt;src&lt;/code&gt; * array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array * because of a type mismatch. * @exception NullPointerException if either &lt;code&gt;src&lt;/code&gt; or * &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); System.arraycopy本地方法参数说明 src：原数组 srcPos：原数组开始复制的下标 dest：目标数组 destPos：目标数组开始下标 length：要复制的元素个数 删除普通remove1234567891011121314151617181920212223/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; //按下标remove rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 快速remove123456789101112131415161718192021222324252627282930313233343536373839404142/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */private void fastRemove(int index) &#123; // 去掉校验和返回值 modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 遍历为什么遍历删除指定对象时，不能边遍历，边使用list.remove()和list.add()做删除和增加操作？ 验证1234567891011121314// output:Exception in thread "main" java.util.ConcurrentModificationExceptionprivate static void testArrayList() &#123; ArrayList arrayList = new ArrayList(); arrayList.add("123"); arrayList.add("345"); arrayList.add("1"); arrayList.add("23"); for (Object ele : arrayList) &#123; if ("123".equals(ele)) &#123; arrayList.remove(ele); //除非这里break;或者return； &#125; &#125; System.out.println(arrayList);&#125; 因为forEach遍历，编译后是使用内部迭代器Iterator的next方法遍历的，在List中维护了一个modCount字段，表示修改的次数，而Iterator内部也维护了一个字段expectedModCount，每次遍历的时候，会去比较这两个字段的值是否相等，就是checkForComodification()方法，如果不等，就会抛出ConcurrentModificationException异常 而使用fori遍历做删除，add的话，有可能会出现问题，如下例，为安全起见一般不建议这么用。 123456789101112131415161718192021//output:[Student&#123;name='male'&#125;, Student&#123;name='female'&#125;, Student&#123;name='female'&#125;]public static void main(String[] args) &#123; //准备数据 List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("male")); list.add(new Student("male")); list.add(new Student("female")); list.add(new Student("female")); list.add(new Student("male")); //普通for循环遍历删除 for (int i = 0; i &lt; list.size(); i++) &#123; Student student = list.get(i); if ("male".equals(student.getName())) &#123; list.remove(i); //使用集合的删除方法删除// i--; //删完之后i不减一，回到之前的值开始遍历 &#125; &#125; System.out.println(list.toString()); &#125; Iterator遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); //检查modcount try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) // fail-fast机制，多处会使用这个判断 throw new ConcurrentModificationException(); &#125;&#125; 实例12345Iterator iterator = branchList.iterator();while (iterator.hasNext()) &#123; Object ele = iterator.next(); System.out.println(ele);&#125; fail-fast在ArrayList设计了一个内部List类，为什么要设计这个类? 12345678910111213141516171819202122232425262728293031public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125;private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123;...&#125; public E get(int index) &#123;...&#125; public int size() &#123;...&#125; public void add(int index, E e) &#123;...&#125; public E remove(int index) &#123;...&#125; protected void removeRange(int fromIndex, int toIndex) &#123;...&#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;...&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; ...&#125; public Iterator&lt;E&gt; iterator() &#123;...&#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123;...&#125;&#125; 由于SubList提供了add()、remove()、addAll()方法的实现，均加了checkForComodification() 方法的校验，且对他们的操作会影响外部类，所以使用的时候特别注意。这样一种设计使用了适配器模式，当我们对子集合进行修改、插入、删除操作时，可以操控父集合的元素。但一定要注意，当我们对声明子集合后，再对父集合进行了修改，那么子集合的遍历与修改都会报fail-fast异常。 1234567891011121314151617181920212223private static void testFailfast() &#123; List&lt;String&gt; masterList = new ArrayList&lt;&gt;(); masterList.add("one"); masterList.add("two"); masterList.add("three"); masterList.add("four"); masterList.add("five"); List&lt;String&gt; branchList = masterList.subList(0, 2); //masterList.remove(0); // 打开后对branchList做遍历、修改、删除操作会报ConcurrentModificationException branchList.clear(); branchList.add("six"); branchList.add("seven"); System.out.println(masterList); branchList.remove(0); //output:[six, seven, three, four, five] System.out.println(branchList); //output:[seven] System.out.println(masterList); //output:[seven, three, four, five] &#125; 这个案例告诉我们 当取完子对象后，父对象与子对象有了联系，就不能随意的改变了，当父对象更改时，再对子对象操作，就会报fail-fast错误。 当建立联系后，子对象的更改会影响到父对象，彼此影响，所以使用的时候，一定不要同时对两个对象做修改操作。 asList &amp; toArray由于ArrayList底层是由数组实现的，那么，肯定是存在数组转集合和集合转数组的方法。我们常使用Arrays.asList(T [])将数组转换为List集合，注意使用该方法时，不能对子集合进行add、remove、clear等操作，因为，返回的ArrayList是一个内部类，没有提供以上方法的实现。 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 如果使用了，就会报fail-fast错误。如果一定要使用修改的话，一般我们是这么声明的。 12String[] strs = new String[2];ArrayList list=new ArrayList(Arrays.asList(strs)); ArrayList集合本身提供了一个集合转数组的方法，就是toArray方法。当我们使用这个方法的时候，一定要注意一些小坑。我们先来看一个例子，猜测一下会打印什么？ 12345678910111213141516171819private static void testArrayList() &#123; ArrayList arrayList = new ArrayList(); arrayList.add("male"); arrayList.add("male"); arrayList.add("female"); arrayList.add("female");// String[] objs = (String[]) arrayList.toArray(); Object[] objs = arrayList.toArray(); String[] strs = new String[2]; String[] strs1 = new String[5]; arrayList.toArray(objs); arrayList.toArray(strs); arrayList.toArray(strs1); System.out.println(Arrays.asList(objs)); System.out.println(Arrays.asList(strs)); System.out.println(Arrays.asList(strs1)); &#125; 最终的打印结果为： [male, male, female, female][null, null][male, male, female, female, null] 分析一下，第一条结果很明确，能完成复制，当我使用无参的方法时，该方法返回的是Object[]，不能转化为String[]，会报ClassCastException异常。第二条当数组声明的长度比集合小的时候，返回全是空。当大于的时候，能进行复制，其余的默认为null，这是什么导致的呢，我们来看看源码。 无参方法实现 123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 无参方法返回Object数组 有参方法实现 123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 当小于集合大小时，我们看到这里返回了一个复制好的数组，但是入参数组a被忽略了，所以a还是空，如果声明另一个数组要接受的话，是有值的。 我们看看Arrays.copyOf()方法是如何实现的 123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 可以看到，这里copy new了一个空的数组，长度为newLength,然后调用本地方法进行了复制，返回。 当我们集合转数组的时候，要注意，将数组的长度声明为list.size()，这性能往往高于大于时候的长度。]]></content>
      <categories>
        <category>collection</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是时候揭开线程池这块面纱了（一）]]></title>
    <url>%2F2020%2F03%2F04%2Fconcurrentart%2Fthreadpool-usages%2F</url>
    <content type="text"><![CDATA[引言 今天在上班的路上，想到一个例子，就是一个病人感染上了新冠病毒要上医院去住院隔离治疗，方舱医院如果床位不够，就会导致医院响应不了病人的请求，只能拒绝。但是要能够响应又得临时搜集资源、组建材料搭建病房和床位，这必然会消耗大量的时间，也会耽搁了病人的病情。那么，要是实现了床足够多，达到床等人的话，就能够迅速的接待病人，进行隔离治疗，使病情得到及时的控制。 这个例子让我想到了线程池，假设对服务器的每一个请求都是一个任务调度，当大量的请求过来的时候，必然由于服务器空间资源限制，导致服务器响应缓慢，更可能导致系统崩溃。当大量的请求处理完之后，线程也就会销毁掉，当下次请求再来的时候，又得去创建线程，导致不必要的系统开销，同时降低了系统的响应速度。如果，我们能够在服务器预备一个专门响应的线程池，当请求来的时候我只要取一个线程去处理任务，处理完之后，我不销毁又放回到池子中，这样的话，我就能随到随取。我还想使这个池子有一定的可塑性，当大量的请求过来的时候，我想使更多的线程去响应，但当处理完之后，该销毁的销毁，不该销毁的还留在池子中，这样能同时响应的请求就更多了。当然，当服务器请求处理不过来，我也可能不想把这个请求给扔掉，我想我处理完后，再来处理之后的请求，只是可能需要你等一等！ 好吧，这就是我们今天要讲的线程池了。 好处 降低资源消耗。避免反复创建线程而不必要的资源开销。 提高响应速度。随来随用，当任务到来无需创建线程就能立即响应。 提高线程的可管理性。控制系统的最大并发数，避免线程创建过多导致系统运行缓慢甚至崩溃的情况发生，同时可以对线程池统一分配、调优和监控。 思考 线程池如何定义？线程池的种类？缓冲队列有哪几种？饱和策略有哪些？这几种线程池该如何使用？ 当线程池刚刚创立还没有Task到来的时候，线程池中的线程处于什么状态？ 当Task到来的时候，线程池中的线程是如何得到通知的？ 当线程池中的线程完成工作，如何回到池子里？ Task是什么东西？ 基本概念线程池接口线程池中定义了几个重要的接口，分别是Executor、ExecuterService。 Executor叫做执行者，有execute(Runnable command)方法。 1234567891011121314public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; 而ExecuterService继承了Executer，定义了线程池对线程的生命周期管理方法，重要的是它还提供了一套submit提交任务的机制。submit表示将任务提交给线程池，至于什么时候执行我就不管了，所以任务执行是异步的。 123456789101112public interface ExecutorService extends Executor &#123; void shutdown(); //结束 List&lt;Runnable&gt; shutdownNow(); //马上结束 boolean isShutdown(); //是否结束了 boolean isTerminated(); //是不是任务都执行完了 boolean awaitTermination(long timeout, TimeUnit unit); //等待结束，时间到了还不结束的话，就给返回false &lt;!--submit 相关方法--&gt; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task);&#125; 我们知道Runnable没有返回值，但是当我需要返回值的话，那就应该使用Callable接口。 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 当任务异步执行完后 ，我该如何通知给调用方呢，这就牵扯出一套Future、RunnableFuture和FutureTask相关概念了。 submit方法返回的是一个Future接口，可理解为未来执行完的一个结果，这个接口里面定义了get方法，主线程可以通过调用get()方法拿到任务的执行结果。所以Callable一般是配合线程池和Future来用的。 但是，更加灵活的一种方式，我们可以把Callable和Future进行封装到一个类里面，这个类就是FutureTask,代表的是我即是一个Task也能是一个用来存这个任务的结果的对象，因此，我就得有任务可执行的属性。因为FutureTask实现了RunableFuture,而RunnableFuture即实现了Runnable又实现了Future。 类图如下： 123456789101112131415161718public class T05_Callable &#123; static class MyCall implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("Hello MyCall"); TimeUnit.SECONDS.sleep(3); return "Success"; &#125; &#125; public static void main(String[] args) throws Exception&#123; // 实现callable接口 FutureTask futureTask = new FutureTask&lt;String&gt;(new MyCall()); Thread thread = new Thread(futureTask); thread.start(); System.out.println(futureTask.get()); &#125;&#125; 注意：主线程调用get方法，任务没有执行完时会被阻塞，直到任务执行完或者抛异常结束。当然，可以指定最大阻塞时间V get(long timeout, TimeUnit unit)，当时间到了就不继续等待了，但是会抛出TimeoutException异常。 线程池定义目前jdk定义的线程池有两种类型，第一种是是普通的线程池ThreadPoolExecutor，第二种是ForkJoinPool，这篇文章我们先分析一下ThreadPoolExecutor相关的线程池。 ThreadPoolExecutor的父类是AbstractExecutorService，而AbstractExecutorService是个抽象类，主要实现了ExecutorService的submit方法，上面知道，ExecutorService也继承了Executor。所以，ThreadPoolExecutor相当于线程池的执行器，可以往这个池子里面扔要执行的任务。 类图如下： 那么，ThreadPoolExecutor是如何定义的呢，它的核心参数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize：核心线程数 maximumPoolSize：最大线程数 keepAliveTime：线程的空闲时间，超出这个时间，非核心线程就会销毁。 unit：空闲时间单位 workQueue：任务队列 threadFactory: 线程工厂 handler：拒绝策略。目前jdk提供四种拒绝策略，一般默认的是抛出异常Abort这种，一般我们需要自己定义策略，根据不同的业务需求进行不同的操作，比如打印错误日志、将任务保存到kafka或者MQ、也可以将数据保存到redis或者数据库。四种拒绝策略分别是 Abort：抛异常 Discard：扔掉，不抛异常 DiscardOldest：扔掉排队时间最久的 CallerRuns：调用者处理服务 注意：线程池在阿里的开发规范上建议不使用jdk自定义的四种ThreadPoolExecutor，建议自己根据不同的业务场景自定义线程池。比如我们可以实现ThreadFactory接口，自定义newThread方法，方便线程的管理以及问题的回溯。 线程池的种类在jdk中提供了一些默认的线程池实现，主要有四种。它们的生成方式是封装在一个专门的线程池工具类中，叫做Executors，它可以看作线程池的工厂。 SingleThreadPool单线程线程池，只有一个线程工作，保证扔进去的任务是顺序执行的。为什么会有单线程线程池呢？第一是有任务队列，保证任务按顺序执行。第二是可通过线程池管理线程的生命周期。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; CachedThreadPool可缓冲线程池，cachepool核心数是0，最大是Integer.MAX_VALUE，队列使用的是SynchronousQueue（这是一个阻塞调用者的队列），keepAliveTime=60s，工作原理为当来第一个任务时，会new Thread，之后的任务会校验是否有线程没在忙，没有的话就来他处理，否则再new 一个，处理完之后60s销毁。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; FixedThreadPool固定线程池，fixedpool核心数和最大线程数是相等的，通过传参传入，队列使用的是无界队列，keepAliveTime=0s。工作原理为我就指定了最多工作的线程数为这么多。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 那么，CachedThreadPool和FixedThreadPool应该怎样使用呢？根据当前业务场景评估任务量以及平稳度，如果是忽高忽低，在保证任务进来之后会马上处理，不会堆积的情况下，可使用CachedThreadPool。如果评估任务来的是平稳的，数量也有一定的范围，可使用FixedThreadPool。 ScheduledThreadPool定时任务线程池，核心数自己定义，最大数为Integer.MAX_VALUE，队列为DelayedWorkQueue。他提供了定时任务的实现机制. 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; 可通过调用scheduleAtFixedRate方法间隔多长时间在一固定的频率上执行一次这个任务。该方法有四个参数，第一个是任务，initialDelay表示开始执行是延迟的时间，period表示间隔时间，unit表示间隔时间的单位。 1234public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); 总结至此，线程池的基本概念就就讲完了，稍微总结一下： Callable类似于Runnable，但是有返回值，并且call方法还有可能抛异常 Future是用来储存任务执行完的结果的 FutureTask的本质是Future加上Runnable，即可以执行又能存结果，可以使用CompletableFuture管理多个线程的结果。 SingleThreadPool只有一个线程的线程池 CachedThreadPool有弹性的线程池，只要没闲着的，就来一个启动一个 FixedThreadPool固定了线程池的线程数 ScheduledThreadPool线程池主要为了执行定时任务的 在我们实际开发中，一般都是自定义线程池，但是如果不了解原理的话，很容易滥用，导致一些系统运行缓慢甚至崩溃的问题。为此，分析源码的文章就留着下篇了。]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>threadpool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS实现与原子类actomic]]></title>
    <url>%2F2020%2F03%2F03%2Fconcurrentart%2Fcas-implement%2F</url>
    <content type="text"><![CDATA[悲观锁与乐观锁悲观锁定义：对于同一数据的并发操作，悲观锁认为当我在使用数据的时候一定有其他线程也会来访问和修改数据，因此在获取数据的时候会加锁，确保数据不会被别的线程修改。 应用：Java中，synchronized关键字和Lock的实现类都是悲观锁。 乐观锁定义：乐观锁认为在对访问数据进行时，没有别的线程来修改数据，所以不需要加锁。但是为了确保只有自己在对数据进行了操作，自己在更新数据的时候会去判断以前有没有别的线程对数据进行了修改。如果数据没有更新，当前线程会将自己修改的数据成功写入；如果数据被更新了，则根据不同的实现方式执行不同的操作（例如报错和循环重试） 应用：java的原子类的自增操作就是通过CAS自旋算法实现的。 应用场景 悲观锁适合写操作多的场景，先加锁可以保证数据正确性。 乐观锁适合读操作多的场景，不加锁特性可以提高读操作的性能。 CAS定义：CAS全称是Compare And Swap (cmpxchg指令)，它是一种无锁的算法，在不使用锁（没有线程阻塞）的情况下实现多线程间的变量同步。由于它实现的特性，也叫做自旋锁、乐观锁。 源码分析1count.incrementAndGet(); // 替代count++ AtomicInteger.incrementAndGet方法调用了unsafe.getAndAddInt方法 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; 看一下AtomicInteger的定义 1234567891011public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; 根据定义我们可以看出各属性的作用： unsafe： 获取并操作内存的数据。 valueOffset： 存储value在AtomicInteger中的偏移量。 value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。 接下来查看Unsafe.getAndAddInt方法的实现 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 分析源码可以看到： getIntVolatile方法获取给定对象o中的偏移量处的值var5 然后调用compareAndSwapInt方法，比较+更新 是个原子操作，这是通过CPU的 cmpxchg指令去实现的 compareAndSwapInt就是cas操作，可看作cas(V，Excepted，NewValue)，V就是要修改的值，Excepted是当前的期望值，NewValue是修改后的值。 当V==Excepted时，将V更新为NewValue，否则，返回flase，继续while循环再次调用cmpxchg指令进行重试，直到成功为止。 CAS带来的问题ABA问题描述：因为CAS需要在操作值时候，检查值有没有发生变化，如果没有发生变化，但是如果一个值原来是A，变成了原来的B，又变成了A，但是用CAS检查出来它没有变化，但是实际上是变化了的。 影响：如果是基础类型，不产生影响。如果是引用类型，可能会产生一些影响，这个影响对业务来说可能不可忽略。 解决思路：在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A” JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 AtomicStampedReference.compareAndSet方法的实现 123456789101112public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); &#125; 循环时间长开销大描述：CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作描述：对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 AtomicReference类的定义，使用了泛型 123456789101112public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -1848883965231344442L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile V value; public AtomicReference(V initialValue) &#123; value = initialValue;&#125; //传递对象 How CAS (Compare And Swap) in Java works]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>CAS</tag>
        <tag>actomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized底层实现原理]]></title>
    <url>%2F2020%2F02%2F28%2Fconcurrentart%2Fsynchronized-implement-prinpiple%2F</url>
    <content type="text"><![CDATA[synchronized定义 Multi-threaded programs may often come to a situation where multiple threads try to access the same resources and finally produce erroneous and unforeseen results.So it needs to be made sure by some synchronization method that only one thread can access the resource at a given point of time. 应用方式 对于普通同步方法，锁是当前实例对象 对于静态同步方法，锁是当前类的class对象 对于同步方法块，锁是synchronized括号里配置的对象 原理 JVM基于进入和退出Monitor对象来实现方法、代码块同步的，两者实现的细节不一样，但都是使用monitorenter和monitorexit指令来实现的。monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法的结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。 任何对象都有一个Monitor与之 关联，当且一个Monitor被持有后，它将处于锁定状态。 线程执行到monitorenter指令时，将会尝试获取对象的锁。 而对于没有获取到对象锁的线程会阻塞在方法的入口，直到获取锁的线程执行 monitorexit之后才能尝试继续获取锁。 流程如下： 验证源码 123Object o = new Object();synchronized (o) &#123;&#125; 使用jclasslib查看汇编指令 对象在内存中的存储 由三部分组成：markword（8个字节）、class pointer（4个字节）、instance data 内存对齐，每个对象在内存中占的字节数必须是8的倍数，即%8=0，如果不满足，则会补齐至8的倍数。 对象头 在64位虚拟机下，markword是64位 用markword中最低的三位代表锁状态，其中1位是偏向锁位：无锁—0 01、偏向锁—1 01 后面两位是普通锁位：轻量级锁—00、重量级锁—01 参考：synchronized 关键字原理 锁升级描述JDK较早的版本，都是使用synchronized,很多人称为重量锁， 重量锁 效率比较低，因为它要向操作系统申请资源。jdk1.6对synchronized进行了优化，为了减少获取和释放锁带来的消耗，引入了轻量级锁和偏向锁 的概念。锁一共有4种状态，级别从低到高分别是无锁 - 偏向锁 - 轻量级锁（自旋锁）-重量级锁 无锁Object o = new Object() 锁的状态为：0 01 无锁态 100000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 执行o.hashCode()后，对象头变为hashcode+0 01 100000000 00000000 00000000 00000111 10000000 11001011 01110111 00000001 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 关闭偏向锁 -XX:+UseBiasedLocking -client -Xmx512m -Xms512m 问题：新实例化对象o是无锁，当对象使用sync(o)之后，为什么对象是轻量级锁状态而不是偏向锁状态呢？ 因为偏向锁的启动有4s的时延，为什么要有时延呢？JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。 可使用以下命令关闭时延 -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -client -Xmx1024m -Xms1024m 偏向锁偏向锁，偏向加锁的第一个线程。 适用于锁不存在多线程竞争，并且应由一个线程多次获得锁。markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个。 获得锁当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，以后该线程进入或者退出同步块时不需要进行 CAS 操作来加锁和释放锁。只需检查一下锁对象的 Mark Word 中是否存储了当前线程的ID，如果是，表示当前已经获得偏向锁，否则再去检查一下 Mark Word 中偏向锁位是否是1，如果不是，使用 CAS竞争锁，如果是，使用 CAS 将对象头的偏向锁指向当前线程。 释放锁当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，偏向锁的撤销需要等到全局安全点（在这个时间点上没有正在执行的字节码），接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁，来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。 偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。这时应该关闭偏向锁，使程序直接进入轻量锁状态。 轻量级锁锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁。 加锁线程在进入同步块之前，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。 如果更新成功，当前线程就获得了锁。 如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。 如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。 不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。 解锁轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁) 轻量锁能提升性能的原因： 认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。 重量级锁自旋超过10次，升级为重量级锁（如果太多线程自旋 CPU消耗过大，不如升级为重量级锁）。当升级为重量级锁时，其他线程试图获取锁时，会阻塞进入等待队列（不消耗CPU），直到持有锁的线程释放锁后会唤醒这些线程，被唤醒的线程会再次一起竞争锁。 其他优化适应性自旋在使用 CAS 时，如果操作失败，CAS 会自旋再次尝试。由于自旋是需要消耗 CPU 资源的，所以如果长期自旋就白白浪费了 CPU。JDK1.6加入了适应性自旋: 如果某个锁自旋很少成功获得，那么下一次就会减少自旋。 总结综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 参考：美团 不可不说的Java“锁”事]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile底层实现原理]]></title>
    <url>%2F2020%2F02%2F27%2Fconcurrentart%2Fvolatile-implement-prinpiple%2F</url>
    <content type="text"><![CDATA[volatile定义 Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获取这个变量。 线程的可见性123456789101112131415161718192021222324public class VolatileApplication &#123; // 当使用volatile时，主线程修改完内存中的flag后，对等线程会从内存中读取到flag被修改后的值，正常结束！ private static /*volatile*/ boolean flag = true; public static void main(String[] args) throws InterruptedException &#123; new Thread() &#123; @Override public void run() &#123; while (flag) &#123; &#125; System.out.println("对等线程执行完毕"); &#125; &#125;.start(); Thread.sleep(1000); flag = false; System.out.println("主线程执行完毕"); &#125;&#125; 原理java源码： 1instance = new Singleton(); //instance是volatile变量 汇编： 10x01a3deld:movb $0✖️0,0✖️1104800(%esi);oxo1a3de24:lock addl $0✖️0,(%esp); lock指令干了两件事情： 将当前处理器缓存行的数据写会到系统内存 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效 缓存一致性 由于CPU的运行速度远远大于向内存读取的速度，所以为了提高效率，加入了高速缓存机制，即处理器不会直接和内存进行通信，而是先将物理内存的数据读到内部缓存（L1，L2，L3或其他），再进行操作 。保存的一致性就是保证多个缓存中共享数据的一致性，目前主要是通过MESI协议来保证的。 MESI 协议 Modified、Exclusive、 Share or Invalid状态而命名的，用来标识每个缓存行的状态（由两个状态位表示），每个缓存行（缓存的数据基本单位）都处于M、E、S和I这四种状态之一。 伪共享 当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class T02_CacheLinePadding &#123; // 不对齐的结果耗时：227ms，对齐的结果耗时：79ms private static class Padding &#123; /*volatile*/ long p0, p1, p2, p3, p4, p5, p6; &#125; private static class T extends Padding &#123; volatile long x = 0L; &#125; public static T[] arr = new T[2]; static &#123; arr[0] = new T(); arr[1] = new T(); &#125; public static void main(String[] args) &#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000000L; i++) &#123; arr[0].x = i; &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000000L; i++) &#123; arr[1].x = i; &#125; &#125; &#125;); long startTime = System.currentTimeMillis(); thread1.start(); thread2.start(); try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("总耗时：" + (System.currentTimeMillis() - startTime) + "ms"); &#125;&#125; 避免伪共享 缓存行隔离 利用缓存行在现代计算机中占8字64字节的特性，为避免多线程缓存一致性带来的性能影响，引入了缓存行对齐，在定义对象时，如果对象在内存中不占64字节，就补齐64字节，保证对象中的数据缓存在不同的缓存行中。 缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高 参考：杂谈 什么是伪共享（false sharing） Concurrency with LMAX Disruptor – An Introduction 指令重排序定义 CPU内部的一个优化，当CPU同时先后执行两条指令，一条是从内存中读指令，一条是执行操作数据指令，CPU由于读指令更耗时，会对指令进行重新排序，先执行操作数据的指令，再执行读指令，当然是这两条指令的变量必须是没有关联，不会互相影响的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class T04_Disorder &#123; private static int x = 0, y = 0; private static int a = 0, b = 0; public static void main(String[] args) throws InterruptedException &#123; int i = 0; for (; ; ) &#123; i++; x = 0; y = 0; a = 0; b = 0; Thread one = new Thread(new Runnable() &#123; @Override public void run() &#123; shortWait(100L); a = 1; x = b; &#125; &#125;); Thread two = new Thread(new Runnable() &#123; @Override public void run() &#123; b = 1; y = a; &#125; &#125;); one.start(); two.start(); one.join(); two.join(); String result = "第" + i + "次 (" + x + "," + y + "）"; if (x == 0 &amp;&amp; y == 0) &#123; System.err.println(result); break; &#125; else &#123;// System.out.println(result); &#125; &#125; &#125; private static void shortWait(long interval) &#123; long startTime = System.currentTimeMillis(); long endTime; do &#123; endTime = System.currentTimeMillis(); &#125; while (endTime - startTime &lt;= interval); &#125;&#125; 问题 对象的半初始化 1234567public class T &#123; int m = 8; public static void main(String[] args) &#123; T t = new T(); &#125;&#125; DCL单例到底需不需要加volatile修饰符 这里的 volatile 关键字主要是为了防止指令重排。原理如下： singleton = new Singleton();这段代码其实是分为三步： 分配内存空间，t.m=0 初始化对象，执行构造函数，t.m=8 将 singleton 对象指向分配的内存地址 加上 volatile 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于报错。 JSR内存屏障 两条指令间如果加了内存屏障，CPU运行的时候就不能对指令进行重排序。 volitile如何解决指令重排序 volatile i ACC_VOLATILE JVM的内存屏障 hotspot实现 查看虚拟机中的C++源码文件如下： bytecodeinterpreter.cpp 12345int field_offset = cache-&gt;f2_as_index(); if (cache-&gt;is_volatile()) &#123; if (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123; OrderAccess::fence(); &#125; orderaccess_linux_x86.inline.hpp 12345678910inline void OrderAccess::fence() &#123; if (os::is_MP()) &#123; // always use locked addl since mfence is sometimes expensive#ifdef AMD64 __asm__ volatile ("lock; addl $0,0(%%rsp)" : : : "cc", "memory");#else __asm__ volatile ("lock; addl $0,0(%%esp)" : : : "cc", "memory");#endif &#125;&#125; 参考：你应该知道的 volatile 关键字]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程的挑战]]></title>
    <url>%2F2020%2F02%2F26%2Fconcurrentart%2Fchallenge-concurrency-progrramming%2F</url>
    <content type="text"><![CDATA[上下文切换减少上下文切换的方法 无锁并发编程 CAS算法 使用最少线程 协程(在一个线程中实现多任务调度) 监控程序查看进程中的线程 jstack 30587 &gt; /app/sssc-soa-starindex/dump1 分析线程信息文件 grep java.lang.Thread.State dump1 | awk ‘{print $2$3$4$5}’ | sort | uniq -c 查看线程状态，是否堵塞或进行多次的上下文切换重新配置线程池信息，重启服务，查看线程运行效果，是否进行了多次线程切换死锁导致死锁的原因 第一个线程等待第二个线程释放资源，而第二线程在等待第一个线程释放资源。 产生死锁的条件 互斥等待（同步的原理） Hold and Wait 循环等待 无法剥夺的等待 避免死锁的方法 一次性获取from和 to锁，无法实现 按顺序获取锁 加入超时，如果超时，就释放锁（不推荐） 资源限制的挑战什么是资源限制 在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。比如硬件资源限制有宽带的上传/下载速度、硬件读写速度和CPU的处理速度。软件资源限制有数据库的连接数和socket连接数等。 资源限制引发的问题 并发程序在资源限制的情况下，运行起来比串行还慢。 解决资源限制引发的问题 使用集群，多机部署 软件资源：线程池、连接池复用]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程基本概念]]></title>
    <url>%2F2020%2F02%2F25%2Fconcurrentart%2Fthread-base-knowledges%2F</url>
    <content type="text"><![CDATA[进程与线程 进程 一个程序就是一个进程，经典定义是：一个执行中程序的实例。 线程 线程是进程执行的最小执行单元，一个进程可以包含多个线程。 什么是线程12345678910111213141516171819202122232425262728293031323334public class T01_whatisThread &#123; // 直接执行run方法,程序顺序执行，执行start方法，主线程与对等线程同时执行，交叉打印！ public static void main(String[] args) &#123;// new T1().run(); new T1().start(); for (int i = 0; i &lt; 10; i++) &#123; try &#123; TimeUnit.MICROSECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Main"); &#125; &#125; private static class T1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; TimeUnit.MICROSECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("T1"); &#125; &#125; &#125;&#125; 线程的创建方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class T02_HowToCreateThread &#123; public static void main(String[] args) &#123; // 1.继承Thread方式 new MyThread().start(); // 2.实现Runnable接口 new Thread(new MyRun()).start(); // 3.使用匿名类 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello,My Anonymous"); &#125; &#125;).start(); // 3.使用Lambda表达式// new Thread(()-&gt;&#123;// System.out.println("Hello Lambda!");// &#125;).start(); // 4.实现callable接口 Thread thread = new Thread(new FutureTask&lt;String&gt;(new MyCall())); thread.start(); // 5.使用线程池 ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello ThreadPool!"); &#125; &#125;); executorService.shutdown(); &#125; private static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println("Hello MyThread!"); &#125; &#125; private static class MyRun implements Runnable &#123; @Override public void run() &#123; System.out.println("Hello MyRun!"); &#125; &#125; static class MyCall implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("Hello MyCall"); return "Success"; &#125; &#125;&#125; 线程的常见方法 sleep causes the thread to definitely stop executing for a given amount of time; if no other thread or process needs to be run, the CPU will be idle (and probably enter a power saving mode). yield basically means that the thread is not doing anything particularly important and if any other threads or processes need to be run, they should run. Otherwise, the current thread will continue to run. join The join() method of a Thread instance is used to join the start of a thread’s execution to end of other thread’s execution such that a thread does not start running until another thread ends. If join() is called on a Thread instance, the currently running thread will block until the Thread instance has finished executing. join(n):It will put the current thread on wait until the thread on which it is called is dead or wait for specified time (milliseconds). 参考：Java Concurrency – yield(), sleep() and join() methods 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class T03_YieldJoin &#123; private static class YieldThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " in Control"); &#125; &#125; &#125; private static class JoinThread extends Thread &#123; @Override public void run() &#123; Thread t = Thread.currentThread(); System.out.println("Current thread: " + t.getName()); // checks if current thread is alive System.out.println("Is Alive? " + t.isAlive()); &#125; &#125; public static void main(String[] args) &#123; // 把当前任务放入到等待队列中，让别的线程优先执行（但有可能还是拿到当前的任务执行，比如等待队列没有任务时）// testYield(); // 当前线程调用了别的线程，调用join()时让当前线程等待（堵塞），当调用线程执行完了，自己再执行。 testJoin(); &#125; private static void testJoin() &#123; Thread t = new Thread(new JoinThread()); t.start(); // Waits for 1000ms this thread to die.If thread is dead，execute next instruction try &#123; t.join(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("\nJoining after 1000"+ " mili seconds: \n"); System.out.println("Current thread: " + t.getName()); // Checks if this thread is alive System.out.println("Is alive? " + t.isAlive()); &#125; private static void testYield() &#123; Thread thread = new YieldThread(); thread.start(); for (int i = 0; i &lt; 5; i++) &#123; Thread.yield(); System.out.println(Thread.currentThread().getName() + " in Control"); &#125; &#125;&#125; 线程状态 新建状态——new Thread()，对象实例化后就是新建状态了。 Runnable状态 Ready就绪状态——thread.start()，任务被扔到CPU等待队列中，等待被运行。 Running状态——被CPU调度器选中，开始执行，当顺利执行完后，进入Teminated结束状态，如果执行了yield()，当前线程会进入Ready就绪状态，等CPU调度器选中时，又进入Running状态。 Teminated结束状态——顺利执行，任务进入Teminated结束状态后，不能重新start()。 Bolcked阻塞 ——在执行同步代码块时没有获取锁资源，等获取锁了进入就绪状态。 Waiting等待——在运行状态时调用o.wait()、t.join()、LockSupport.park()进入Waiting状态，调用o.notify()、o.notifyAll()、LockSupport.unpack()又回到Running状态。 TimedWaiting等待——在运行状态时调用o.wait(n)、t.join(n)、Thread.sleep(n)进入TimedWaiting状态，与Waiting相似，只是按照时间等待，如果时间到了，或者线程结束则继续执行。 参考：Lifecycle and States of a Thread in Java 123456789101112131415161718192021222324252627282930313233343536373839404142public class T04_ThredState &#123; private static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(this.getState()); for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t = new MyThread(); System.out.println(t.getState()); t.start(); // 就绪状态和运行状态统称为Runnable状态 System.out.println(t.getState()); try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(t.getState()); // 线程执行完之后，不能重新start，报IllegalThreadStateException异常，start方法中有状态校验，必须为新建状态，见源码！ // t.start(); &#125;&#125;]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>thread base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：并发编程]]></title>
    <url>%2F2020%2F01%2F06%2Fcsapp%2Fconcurrent-programmings%2F</url>
    <content type="text"><![CDATA[并发编程简介 并发 如果逻辑控制流，在时间上重叠，那么它们就是并发的 应用级并发的作用 访问慢速I/O设备 与人交互 通过推迟工作以降低延迟 服务多个网络服务 在多核机器上进行并行计算 三种构造并发程序的方法 进程 With this approach, each logical control ﬂow is a process that is scheduled and maintained by the kernel. Since processes have separate virtual address spaces, ﬂows that want to communicate with each other must use some kind of explicit interprocess communication (IPC) mechanism. I/O多路复用 This is a form of concurrent programming where applications explicitly schedule their own logical ﬂows in the context of a single process. Logical ﬂows are modeled as state machines that the main program explicitly transitions from state to state as a result of data arriving on ﬁle descriptors. Since the program is a single process, all ﬂows share the same address space. 线程 Threads are logical ﬂows that run in the context of a single process and are scheduled by the kernel. You can think of threads as a hybrid of the other two approaches, scheduled by the kernel like process ﬂows and sharing the same virtual address space like I/O multiplexing ﬂows. 基于进程的并发编程 base knowldge 线程是最小执行的单位，进程是最小资源分配的单位 概念 使用fork()、exec()、waitpid()等函数，对进程进行控制 一个构造并发服务器的自然方法是，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个客户端提供服务 过程 第一步：服务器接受客户端的连接请求 第二步：服务器派生一个子进程为这个客户端服务 第三步：服务器接受另一个连接请求 优劣 进程有独立的地址空间，不会覆盖另一进程的虚拟存储器，避免许多令人迷惑的错误。 独立的地址空间使得进程共享状态信息变得更加的困难，为了共享信息，必须使用显示的IPC(进程间通信)机制。 另一个缺点是，速度较慢，因为进程控制和IPC的开销很高。 基于I/O多路复用的并发编程 描述 创建自己的逻辑流，并利用I/O多路复用来显示地调度流，因为只有一个进程，所有的流共享整个地址空间。 使用select函数，要求内核挂起进程，只有一个或多个I/O事件发生后，才将控制返回给应用程序。 基于线程的并发编程 线程 就是运行在进程上下文中的逻辑流 一个进程可以有多个线程 线程由内核调度 每个线程都有它自己的线程上下文，包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码 所有运行在一个进程里的线程共享该进程的整个虚拟地址空间 线程执行模型 主线程、对等线程、对等池(线程池) 一个线程的上下文比进程的上下文小得多，也比进程的上下文切换快得多 和一个进程相关的线程组成一个对等池，独立于其他线程创建的线程 主线程和其他线程的区别仅仅在于它总是进程中第一个运行的线程 一个线程可以杀死它的任何对等线程，或者等待它的任何对等线程终止 每个对等线程读写相同的共享数据 Posix线程 创建线程 终止线程 回收已终止的线程 分离线程 初始化线程 共享变量信号量并行性竞争与死锁]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：Web服务器]]></title>
    <url>%2F2019%2F12%2F08%2Fcsapp%2Fnetwork-programming-two%2F</url>
    <content type="text"><![CDATA[Web服务器 Web基础 HTTP协议——超文本传输协议（Hypertext Transfer Protocol） 定义 Web客户端和服务器之间的交互用的一个基于文本的应用级协议。 一个客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。 HTML语言——超文本标记语言（Hypertext Markuo Language） 定义 区别于常规的文件检索服务，一个HTML程序包含指令，它们告诉浏览器如何显示这页中的各种文本和图形对象。 Web内容 定义 内容是与一个MIME（Multipurpose Internet Mail Extension，多用途的网际邮件扩充协议）类型相关字节序列 常用的MIME类型 text/html text/plain application/json image/gif image/jpeg 两种方式提供内容 静态内容 取出一个磁盘文件，并将它的内容返回给客户端，磁盘文件为静态内容，过程叫做服务静态内容。 动态内容 运行一个可执行文件，并将它的输出返回给客户端，执行文件输出的是动态内容，过程称为服务动态内容。 URL——通用资源定位符（Univwesal Resource Locator） 例如 http://www.google.com:80/index.html http://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213 HTTP事务 静态内容的事务图 HTTP请求 组成：一个请求行（第5行）+零个或多个请求报头（第6行）+空的文本行（第7行标识终止报头） 请求行的格式：method URI version HTTP请求支持的方法：GET、POST、OPTIONS、HEAD、PUT、DELETE和TRACE URI：统一资源标识符（Uniform Resource Identifier）是相应URL的后缀，包括文件名和可选的参数 HTTP响应 组成：一个响应行（第8行）+零个或多个响应报头（第9～13行）+空行（第14行标识终止报头）+响应主体（第15～17行） HTTP状态码图 服务动态内容 客户端如何将程序参数给服务器？ GET请求通过URI中传递，用？分隔文件名和参数，用&amp;分隔参数 POSt请求的参数放在主体中 服务器如何将参数传递给子进程？ it calls fork to create a child process and calls execve to run the /cgi-bin/adder program in the context of the child. Programs like the adder program are often referred to as CGI programs because they obey the rules of the CGI standard. Before the call to execve, the child process sets the CGI environment variable QUERY_STRING to 15000&amp;213, which the adder program can reference at run time using the Linux getenv function. 服务器如何将其他信息传递给子进程？ CGI deﬁnes a number of other environment variables that a CGI program can expect to be set when it runs. Figure 11.26 shows a subset. 子进程将它的输出发送到哪里？ A CGI program sends its dynamic content to the standard output. Before the child process loads and runs the CGI program, it uses the Linux dup2 function to redirect standard output to the connected descriptor that is associated with the client. Thus, anything that the CGI program writes to standard output goes directly to the client. Notice that since the parent does not know the type or size of the content that the child generates, the child is responsible for generating the Content-type and Content-length response headers, as well as the empty line that terminates the headers. CGI程序示例 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author chenjianrong-lhq 2019年12月08日 21:22:16 * @Description: 网络编程客户端 * @ClassName: ClientApplication */public class ClientApplication &#123; public static String IP = &quot;www.baidu.com&quot;; public static Integer PORT = 80; public static void main(String[] args) &#123; String param = &quot;提供动态内容，需要派生一个子进程，并在子进程的上下文中运行一个CGI程序，来提供各种类型的动态内容。子进程通过请求URI获取的CGI参数初始化QUERY——STRING环境变量。然后子进程重定向它的标准输出到已连接文件描述符，然后加载并运行CGI程序。CGI运行的结果会直接显示在服务器端。&quot;; /**step1 定义 Socket 对象、OutputStream 对象和一个 InputStream 对象并完成初始化**/ Socket socket = null; OutputStream os = null; InputStream is = null; try &#123; socket = new Socket(IP, PORT); /**step2.建立与服务器端的连接并将数据发送到服务器端**/ socket.setSoTimeout(60 * 1000); os = socket.getOutputStream(); os.write(param.getBytes(&quot;utf-8&quot;)); Thread.sleep(1000);// ByteArrayOutputStream bos = new ByteArrayOutputStream(); /**step3.从输入流中读出服务器的反馈信息并输出到控制台**/ byte[] buffer = new byte[1024]; is = socket.getInputStream(); int count = 0;// do &#123;// count = is.read(buffer);// bos.write(buffer, 0, count);// &#125; while (is.available() != 0); count = is.read(buffer); System.out.println(&quot;服务端反馈的数据是：&quot; + new String(buffer, 0, count)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; /**step4 关闭流及 Socket 对象**/ try &#123; if (os != null) &#123; os.close(); &#125; if (is != null) &#123; is.close(); &#125; if (socket != null) &#123; socket.close(); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;&#125; 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author chenjianrong-lhq 2019年12月08日 21:56:09 * @Description: 网络编程服务端 * @ClassName: ServerApplication */public class ServerApplication &#123; public static String IP = &quot;www.baidu.com&quot;; public static Integer PORT = 80; public static void main(String[] args) &#123; /**step5 创建ServerSocket、Socket、OutputStream、InputStream以及端口号并初始化**/ ServerSocket serverSocket = null; Socket socket = null; OutputStream os = null; InputStream is = null; try &#123; /**step6 开启服务器并接收客户端发送的数据**/ serverSocket = new ServerSocket(PORT); System.out.println(&quot;服务器开启，等待连接...&quot;); socket = serverSocket.accept(); is = socket.getInputStream(); byte[] buffer = new byte[1024]; int len = is.read(buffer); System.out.println(&quot;客户端发送的内容为：&quot; + new String(buffer, 0, len)); /**step7 使用输出流对象将信息返回给客户端**/ os = socket.getOutputStream(); os.write(&quot;我是服务器端&quot;.getBytes()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; /**step8 关闭流对象、ServerSocket对象以及Socket对象**/ try &#123; os.close(); is.close(); serverSocket.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TINY Web服务器参考博客：网络编程]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：网络编程（一）]]></title>
    <url>%2F2019%2F12%2F01%2Fcsapp%2Fnetwork-programming%2F</url>
    <content type="text"><![CDATA[客户端——服务端编程模型 简介 定义 一个网络应用是由一个服务器进程和一个或者多个客户端进程组成，服务端管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。 举例 a Web server manages a set of disk ﬁles that it retrieves and executes on behalf of clients. An FTP server manages a set of disk ﬁles that it stores and retrieves for clients. An email server manages a spool ﬁle that it reads and updates for clients. 基本操作 客户端——服务器模型中基本操作是事务。 客户端——服务端事务 事务模型图 步骤 When a client needs service, it initiates a transaction by sending a request to the server. For example, when a Web browser needs a ﬁle, it sends a request to a Web server. The server receives the request, interprets it, and manipulates its resources in the appropriate way. For example, when a Web server receives a request from a browser, it reads a disk ﬁle. The server sends a response to the client and then waits for the next request.For example, a Web server sends the ﬁle back to a client. The client receives the response and manipulates it. For example, after a Web browser receives a page from the server, it displays it on the screen. 注意 进程点对点 客户端和服务器是进程，而不是常常提到的机器或者主机 事务可以跨主机 一台主机可以同时运行在不同的客户端和服务端，而且一个客户端和服务端的事务可以在同一台或是不同的主机上运行。 网络 I/O设备——网络 简介 对于一个主机而言，网络只是又一种I/O设备，作为数据源和数据接收方。 网络主机的硬件图 以太网段 组成 由电缆（通常是双绞线）和一个叫做集线器的小盒子组成 概念图 桥接以太网 组成 使用电缆和叫做网桥（bridge）的小盒子，多个以太网段可以连接成较大的局域网，称为桥接以太网。 概念图 路由器、互联网——局域网与广域网互联 局域网 集线器+网桥+电缆 局域网概念图 互联网络 在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器的特殊计算机连接起来，组成一个互联网络（internet） 互联网概念图 不同主机间网络通信 通信图 步骤 The client on host A invokes a system call that copies the data from the client’s virtual address space into a kernel buffer. The protocol software on host A creates a LAN1 frame by appending an internet header and a LAN1 frame header to the data. The internet header is addressed to internet host B. The LAN1 frame header is addressed to the router. It then passes the frame to the adapter. Notice that the payload of the LAN1 frame is an internet packet, whose payload is the actual user data. This kind of encapsulation is one of the fundamental insights of internetworking. The LAN1 adapter copies the frame to the network. When the frame reaches the router, the router’s LAN1 adapter reads it from the wire and passes it to the protocol software. The router fetches the destination internet address from the internet packet header and uses this as an index into a routing table to determine where to forward the packet, which in this case is LAN2. The router then strips off the old LAN1 frame header, prepends a new LAN2 frame header addressed to host B, and passes the resulting frame to the adapter. The router’s LAN2 adapter copies the frame to the network. When the frame reaches host B, its adapter reads the frame from the wire and passes it to the protocol software. Finally, the protocol software on host B strips off the packet header and frame header. The protocol software will eventually copy the resulting data into the server’s virtual address space when the server invokes a system call that reads the data. 全球IP因特网 IP地址 因特网客户端——服务端应用程序的基本硬件和软件组织 因特网（特性）——一个世界范围的主机集合 主机集合映射为一组32位的IP地址 这组IP地址被映射为一组称为因特网域名（Internet domain name）的标识符 因特网主机上的进程能够通过连接（connection）和任何其他因特网主机上的进程通信 IP地址 一个32位无符号整数 IP地址通常用点分十进制表示法来表示 例如：128.2.194.242 就是地址0x8002c2f2的点分十进制表示 inet_aton 函数将一个点分十进制（cp）转化为一个网络字节顺序的IP地址（inp） inet_ntoa 函数将一个个网络字节顺序的IP地址转化为它所对应的点分十进制串 因特网域名 产生原因 IP地址（大整数）很难记忆，另定义了一组更加人性化的域名，以及一种将域名映射到IP地址的机制。 域名是一串用句点分隔的单词（字母、数字和破折号），例如 kittyhawk.cmcl.cs.cmu.edu 域名的层级 常见的一级域名有com、edu、gov、org和net 一旦一个组织得到了一个二级域名，那么它就可以在这个子域中创建任何新的域名了 DNS域名系统 由上百万的主机条目结构组成，其中每条定义了一组域名和一组IP地址之间的映射 因特网连接 套接字地址 一个套接字是连接的一个端点，每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用”地址：端口”来表示 当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口。然而，服务器套接字地址中的端口通常是某个知名的端口，是和这个服务对应的。 连接 一个连接是它两端的套接字地址是唯一确定的，这对套接字地址叫做套接字对，由下列元组来表示（cliaddr:cliport,servaddr:servport） 其中cliaddr是客户端的IP地址，cliport是客户端的端口，servaddr是服务器的IP地址，而servport是服务器的端口。 例如 Web客户端的套接字地址是128.2.194.242:51213，其中端口号51213是内核分配的临时端口号 Web服务端的套接字地址是208.216.181.15:80，其中端口是和Web服务相关联的知名端口号]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：地址翻译]]></title>
    <url>%2F2019%2F11%2F25%2Fcsapp%2Faddress-translation%2F</url>
    <content type="text"><![CDATA[简介 定义： address translation is a mapping between the elements of an N- element virtual address space (VAS) and an M-element physical address space (PAS) MAP: VAS → PAS ∪ ∅MAP(A) =A’ (if data at virtual addr. A are present at physical addr. A_ in PAS)MAP(A) = ∅ (if data at virtual addr. A are not present in physical memory) 使用页表的地址翻译图 Figure 9.12 shows how the MMU uses the page table to perform this mapping. A control register in the CPU, the page table base register (PTBR) points to the current page table. The n-bit virtual address has two components: a p-bit virtual page offset (VPO) and an (n − p)-bit virtual page number (VPN). The MMU uses the VPN to select the appropriate PTE. For example, VPN 0 selects PTE 0, VPN 1 selects PTE 1, and so on. The corresponding physical address is the concatenation of the physical page number (PPN) from the page table entry and the VPO from the virtual address. Notice that since the physical and virtual pages are both P bytes, the physical page offset (PPO) is identical to the VPO. 页面命中 Figure 9.13(a) shows the steps that the CPU hardware performs when there is a page hit.(注：VA——虚拟地址，PTEA——页表条目地址，PTE——页表条目，PA——物理地址)Step 1. The processor generates a virtual address and sends it to the MMU.Step 2. The MMU generates the PTE address and requests it from the cache/main memory.Step 3. The cache/main memory returns the PTE to the MMU.Step 4. The MMU constructs the physical address and sends it to the cache/main memory.Step 5. The cache/main memory returns the requested data word to the pro-cessor. 页面不命中 Unlike a page hit, which is handled entirely by hardware, handling a page fault requires cooperation between hardware and the operating system kernel (Figure 9.13(b)).Steps 1 to 3. The same as steps 1 to 3 in Figure 9.13(a).Step 4. The valid bit in the PTE is zero, so the MMU triggers an exception,which transfers control in the CPU to a page fault exception handler in the operating system kernel.Step 5. The fault handler identiﬁes a victim page in physical memory, and if that page has been modiﬁed, pages it out to disk.Step 6. The fault handler pages in the new page and updates the PTE in memory.Step 7. The fault handler returns to the original process, causing the faulting instruction to be restarted. The CPU resends the offending virtual address to the MMU. Because the virtual page is now cached in physical memory, there is a hit, and after the MMU performs the steps in Figure 9.13(a), the main memory returns the requested word to the processor. 地址翻译的优化方式 结合高速缓存和虚拟存储器利用TLB加速地址翻译多级页表综合：端到端的地址翻译]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：系统级I/O]]></title>
    <url>%2F2019%2F11%2F25%2Fcsapp%2Fsystem-level-IO%2F</url>
    <content type="text"><![CDATA[简介 I/O(输入与输出) 定义:是在主存和外部设备（如磁盘驱动器、终端和网络）之间拷贝数据的过程。 学习Unix I/O的好处 了解Unix I/O将帮助你理解其他的系统概念。 有时你除了使用Unix I/O以外，你别无选择。 Unix I/O Unix文件： 定义：一个Unix文件就是一个各字节的序列：B0，B1，B2，…，Bk,…，Bm-1 文件： 定义：所有的I/O设备，如网络，磁盘和终端，都被模型化为文件，而所有的输入输出都被当作对相应的文件读和写来执行，这种将设备优雅地映射成文件的方式，允许Unix内核引出一个简单、低级的应用接口，称为Unix I/O。 一些基础的操作： 打开文件 改变文件的位置 读写文件 关闭文件 打开和关闭文件读和写文件用RIO包健壮的读写读取文件元数据共享文件]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：虚拟存储器]]></title>
    <url>%2F2019%2F11%2F14%2Fcsapp%2Fvirtual-memory%2F</url>
    <content type="text"><![CDATA[简介 定义 虚拟存储器是对I/O设备与主存的抽象。 虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。 虚拟存储器的目标 高速缓存 存储器管理工具 存储器保护工具 理解虚拟存储器的原因 中心的 强大的 危险的 讲解思路 前一部分描述虚拟存储器是如何工作的 后一部分描述应用程序如何使用和管理虚拟存储器 物理和虚拟寻址 主存定义 计算机系统被组织成一个由M个连续的字节大小的单元组成的数组 物理寻址图 虚拟寻址图 地址翻译 将一个虚拟地址转换为物理地址的任务叫做地址翻译 MMU（存储器管理单元） 属于CPU中的一部分，该硬件利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理 地址空间 定义 地址空间是一个非负整数地址的有序集合：{0,1,2,…},如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。 虚拟地址空间 在一个带虚拟存储器的地址空间中，CPU从一个有N=2n个地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间：{0,1,2,…,N-1} 一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如：一个包含了N=2n个地址的虚拟地址空间就叫做一个n位地址空间。 思考：32位或者64位虚拟地址空间的系统，其虚拟地址数分别是多少，最大可能的虚拟地址是多少？ 物理地址空间 它与系统中物理存储的M个字节相对应：{0,1,2,…,M-1} 虚拟存储器的思想 主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。 小结 地址空间的概念很重要，因为它清楚的区分了数据对象（字节）和它们的属性（地址） 作为缓存工具 虚拟页 定义：As with any other cache in the memory hierarchy, the data on disk (the lower level) is partitioned into blocks that serve as the transfer units between the disk and the main memory (the upper level). VM systems handle this by partitioning the virtual memory into ﬁxed-size blocks called virtual pages (VPs). Each virtual page is P = 2p bytes in size. 物理页 定义：Similarly, physical memory is partitioned into physical pages (PPs), also P bytes in size. (Physical pages are also referred to as page frames.) 物理页的状态 未分配 Pages that have not yet been allocated (or created) by the VM system. Unallocated blocks do not have any data associated with them,and thus do not occupy any space on disk. 已缓存 Allocated pages that are currently cached in physical memory. 未缓存 Allocated pages that are not cached in physical memory. 一个VM系统是如何使用主存作为缓存 页表 页表结构 页命中 VM页命中 缺页 VM缺页 分配 分配一个新的虚拟页面 作为存储器管理工具 简介 操作系统为系统中的每个进程都维护一个独立的页表 按需页面调度和独立的虚拟地址空间的结合，对系统中存储器的使用和管理造成了深远的影响。 VM如何为进程提供独立的地址空间 简化链接 每个进程的存储器影像使用相同的基本格式，文本节，数据和bss节，栈 这样的一致性，极大的简化了链接器的设计和实现，允许链接器生成全链接的可执行文件。 简化加载 加载器从不实际从磁盘拷贝数据到存储器 在每个页被初次引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令被引用一个存储器位置时引用的，虚拟存储器系统会按需要自动调入数据页。 简化共享 进程之间需要共享代码和数据，可以通过虚拟存储器实现 操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个拷贝，而不是在每个进程中都包括单独的内核和C标准库的拷贝。 简化存储器的分配作为存储器保护工具 为操作系统提供手段来控制对存储器系统的访问，不允许一个用户进程修改它的只读文本段。 每个PTE中已经添加了3个许可位，SUP位表示进程表示进程是否必须运行在内核模式下才能访问该页。 READ和WRITE位控制对页面的读和写访问。 用虚拟存储器来提供页面级别的存储器保护]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：异常控制流与进程]]></title>
    <url>%2F2019%2F11%2F03%2Fcsapp%2Fexceptions-processes%2F</url>
    <content type="text"><![CDATA[本章简介 异常控制流 定义 现代系统通过使用控制流发生突变对系统各种状态的变化作出反应，我们把这些突变称为异常控制流（Exceptional Control Flow） 理解异常控制流的好处 理解重要的系统概念 理解应用程序是如何与操作系统交互的 编写有趣的新应用程序 理解并发 理解软件异常如何工作 本章讲解思路 与操作系统交互 这一章的重要性在于学习应用是如何与操作系统交互，交互是围绕ECF的，将从一个计算机系统中所有层次上各种形式的ECF展开 从异常开始，异常位于硬件与操作系统交界的部分 讨论系统调用，他们是应用程序提供到操作系统的入口点的异常 提升抽象的层次，描述进程号，他们位于应用和操作系统的交界之处 最后，讨论非本地跳转，这是ECF的一种应用形式 异常 异常处理 异常 异常就是控制流中的突变，用来响应处理器状态中的某些变化 事件 状态变化称为事件，事件可能和当前指令的执行直接相关 异常表 在任何情况，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序（称为异常处理程序） 异常的剖析 异常跳转 处理程序将控制返回给当前指令Icurr，即当前事件正在执行的指令。 处理程序将控制返回给Inext,即如果没有发生异常，将会执行的下一条指令。 处理程序终止被中断的程序。 异常号 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号，这些号码是由处理器的设计者或者操作系统内核分配的。 异常表 在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得条目k包含异常k的处理程序地址。 异常的类别异步异常 中断 中断是异步发生的，来自处理器外部I/O设备信号 返回结果后，程序继续执行下一条指令，就像没有发生中断一样 硬件中断的异常处理程序称为中断处理程序 同步异常（故障指令） 陷阱 有意的异常，执行一条指令的结果，最常用途——系统调用 在用户程序和内核之间提供一个像过程一样的接口 系统调用与普通函数调用的区别 普通的函数调用运行在用户模块中，用户模式限制了函数可以执行的指令类型，而且它们只能访问与调用函数相同的栈。 系统调用运行在内核模式中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。 故障 故障由错误情况引起，一般是潜在可恢复的错误,它能够被故障处理程序修正。 常见的是缺页异常 终止 不可修复的错误引起，例如：DRAM与SRAM被损坏时发生的奇偶错误。 终止处理 终止处理程序将控制传递给一个内核abort例程，该例程终止这个应用程序 Linux/IA32系统定义异常 常见的异常 除法错误 一般保护故障 缺页 机器检查 IA32异常示例图 进程 进程 异常是允许操作系统提供进程的概念所需要的基本构造块 进程的经典定义是一个执行中的程序的实例 上下文 系统中的每个程序都是运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的。 这个状态包括存放在存储器中的程序的代码和数据，它的栈，通用的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程是对应用程序的关键抽象 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器。 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。 逻辑控制流 定义 程序计数器PC的值叫做逻辑控制流 逻辑控制流图 案例 考虑一个运行三个进程的系统，处理器的一个物理控制流分发成了三个逻辑流。每个进程一个，三个逻辑流的执行是交错的。 进程A运行了一会儿，然后是进程B开始运行完成。然后，进程C运行了一会，进程A接着运行直到完成。最后，进程C可以运行到结束了。 图的关键点在于进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。 逻辑流形式 异常处理程序、进程、信号处理程序 线程和java进程 并发流 并发流 多个流并发地执行的一般现象称为并发，并发使计算机运行得更快 并发的思想与流运行的处理器核数或者计算机数无关。如果每个流在时间上重叠，那么它们就是并发。 并行流 并行流是并发流的一个真子集，如果两个流并发的运行在不同的处理器或者计算机上，那么我们程它们为并行流。 并行使计算机能做的更多，它们并行的运行，且并行地执行。 私有地址空间 定义 一个进程为每个程序提供它自己的私有地址空间 组成 地址空间底部是保留给用户程序的，包括通常的文本、数据、堆和栈段。 进程地址空间图 用户模式和内核模式 模式位 处理器通过使用某个控制寄存器中的一个模式位，来限制一个应用可以执行的指令以及它可以访问的地址空间范围。 当设置模式位时，进程就运行在内核模式中，一个运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。 没有模式位时，进程就是运行在用户模式中。用户模式中的进程不允许执行特权指令，比如停止处理器，改变位模式，或者发起一个I/O操作。 模式转化 初始时 运行应用程序代码的进程初始时是在用户模式中。 用户模式转内核模式 唯一方法，调用中断、故障、或者陷入系统调用的异常 内核模式转用户模式 处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把内核模式改回为用户模式 上下文切换 定义 上下文就是内核重新启动一个被抢占的进程所需的状态 操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。 上下文切换图 上下文切换 保存当前进程的上下文 恢复某个先前被抢占的进程被保存的上下文 将控制传递给这个新恢复的进程]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：存储器层次结构]]></title>
    <url>%2F2019%2F10%2F20%2Fcsapp%2Fstorage-technologies%2F</url>
    <content type="text"><![CDATA[存储技术 随机访问存储器 SRAM 用作高速缓存存储器 DRAM 作为主存以及图形系统的帧缓冲区 对比 SRAM具有多个晶体管，访问快，不敏感，造价高，应用于高速缓存存储器。 磁盘 磁盘构造 磁盘 磁盘是由盘片构成，每个盘片有两面称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转（单位：RPM）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。 扇区 每个表面由一组称为磁道的同心圆组的。每个磁道被划分为一组扇区，每个扇区包含相等数据位（通常是512字节）。扇区之间由一些间隙分隔开，这些间隙中不存储数据位，用来标识扇区的格式化位。 磁盘构造 盘片，盘面，主轴，磁道，扇区，柱面 磁盘容量 磁盘容量＝字节数/扇区 * 平均扇区/磁道 * 磁道数/表面 * 表面数/盘片 *盘片数/磁盘 访问时间 访问时间=寻道时间+旋转时间+传送时间 传送时间与寻道时间、旋转时间比较，很少 寻道时间和旋转时间大致相等 将寻道时间乘以2，看作是磁盘访问时间的估计值 磁盘的动态特性 寻道时间 为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。依赖于读/写头以前的位置和传动臂在盘面上移动的速度。 旋转时间 一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个bit旋转到读/写头下。依赖于当读/写头到达目标扇区时盘面的位置和磁盘的旋转速度。 传送时间 当目标扇区的第一个bit位于读/写头下时，驱动器就可以开始读或者写该扇区的内容了。一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。 逻辑磁盘块 可将磁盘分为B个扇区大小的逻辑块的序列，编号为0，1，…，B-1。磁盘中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和物理磁盘扇区（盘面、磁道、扇区）之间的映射关系。 固态硬盘 固态硬盘 固态硬盘(SSD)的存储介质分为两种，一种是采用闪存（FLASH芯片）作为存储介质(如笔记本硬盘、存储卡、优盘等)，另外一种是采用DRAM作为存储介质(目前应用范围较窄)。而传统旋转硬盘是使用机械驱动器作为存储介质。SSD插到I/O总线上标准硬盘插槽（通常是USB）中，行为就和旋转硬盘一样。 对比 SSD相比旋转硬盘，随机访问时间更快，能耗更低，同时也更结实，但价格较贵。 局部性 局部性原理 在数据访问时，具有“引用邻近于其他引用过的数据项的数据项，或者最近引用过的数据项本身”的这种倾向，叫作局部性原理。 局部性原理对硬件和软件系统的设计和性能都有着极大的影响。 对程序数据引用的局部性 时间局部性 在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用。 取指令的局部性 空间局部性 在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。 局部性小结 重复引用同一个变量的程序有良好的时间局部性 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性很差。 对于取指令来说，循环有很好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。 存储器层次结构 存储器层次结构 层次结构图 L0层寄存器 一个时钟周期的访问时间，缓存的是字，大小4字节或者8字节。 L1～L3层高速缓存（SRAM） 几个时钟周期的访问时间，缓存的行，64字节块。 主存（DRAM） 几十到几百个时钟周期，部分文件。 本地磁盘 磁盘扇区，数万个时钟周期。 分布式文件系统 网络传输，传输更慢。 缓存的概念 缓存 高速缓存是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存。 块 第k+1层的存储器被划分成连续的数据对象片，称为块。每个块都有一个唯一的地址或名字，使之区别于其他的块。 大块可以减少访问次数。 存储器层次结构中基本的缓存原理 缓存命中 当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中查找d。如果d刚好缓存在第k层中，那么就是我们所说的缓存命中。 结构层次小结 利用时间局部性 由于时间局部性，同一数据对象可能会被多次使用。一旦一个数据对象在第一次不命中时被拷贝到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。 利用空间局部性 块通常包含有多个数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后拷贝该块的花费。 ​]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校招面试题个人整理]]></title>
    <url>%2F2019%2F09%2F26%2Fschool-inter-questions%2F</url>
    <content type="text"><![CDATA[java基础1. Object类中有什么方法，讲一讲各个方法的作用？ 答： toString() 打印对象实例的信息内容（描述我是谁） getClass() 获取类信息Class对象（骨子里特性） equals() 判断两个对象的地址引用是否相等，如果方法被覆盖的话，比较的是内容（谁会与我共鸣呢）。 hashCode() 获取对象的hashCode值,用于区分对象实例的唯一性（每个人都是独一无二的）。 wait() 当线程执行wait方法时，会使该对象进入等待池，释放锁资源，让其他线程执行。 notify() 当线程执行notify时，会唤醒等待的线程。 clone() 对象的浅拷贝（描述我是从哪来） finalize() 垃圾回收不再被引用的对象，释放内存(描述我要到哪去)。 2. sleep()与wait()方法的区别？ 答： sleep是Thread的静态方法，使得调用线程进入休眠状态，休眠的时候依然占据对象锁，其他线程拿不到锁会阻塞，但是会让出CPU资源给其他线程，等到休眠时间结束，线程就进入到就绪状态，和其他线程一起竞争CPU。 而wait是Object类中的方法，当一个线程执行到wait方法时，它就进入一个和该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll()方法来唤醒等待的线程。 3. 说一下“==”与equals()的区别？ 答： “==”对于基本类型来说，比较的是内容（比如int类型，比较的是数值大小）。如果是引用类型，则比较的是对象的引用地址。 equals是Object基类中的方法，实现是比较引用地址（==），如果被覆盖，则比较的是内容。 4. equals与hashcode的区别？ 答： 这两个方法主要用于Set,HashTable中，如果对象要用Set(去重)，HashTable存储(散列)，则应该考虑重写hashCode方法。 如果两个对象的equals方法相等，则调用hashCOde返回的哈希码值也相等。 但是，hashCode相等，不一定equals方法相等。 注意，通常需要在重写hashCode()方法时重写equals方法，以便维护hashCode方法的 general contract，该方法声明equals相等的对象必须具有相等的散列代码。(看Object对象的源码) 5. 抽象类与接口的区别，本质区别是什么？ 答：抽象类是为了实现代码的重用（复用），而接口是为了降低代码的耦合度。 6. java中打印HelloWorld的执行流程？ 答： javac编译HelloWorld.java,得到HelloWorld.class字节码文件。 JVM将字节码文件加载进内存中(即方法区的类代码区中)。 JVM找到HelloWorld的main方法，传递String类型参数的地址到主方法的args中去，并在栈区为args开辟内存空间，返回一个void的返回值。 创建一个“HelloWorld”对象，对象在方法区的常量数据区开辟空间，其属性值为“HelloWorld”。 定义一个String类型的变量s(在栈区开辟空间)，变量s存放对象“HelloWorld”的地址。 JVM找到标准类库中的System.class类并加载到内存中(即方法区的类代码区中),System初始化时会创建PrintStream标准字节输出流对象，调用println()方法将变量s的值打印到屏幕上。 流程图如下所示 7. linux熟悉的命令 答： 如果自己部署过服务器，那这个问题还不是so easy.可以参考这篇 终端命令小入门 pwd 打印当前所在目录 cat 打印文本文件内容 vim 编辑文本 tar 压缩文件 ssh 登录服务器 sudo 以系统管理者的身份执行指令 chmod 修改文件权限 mkdir 创建文件夹 mv 移动 cp 拷贝 rm -rf 强制删除 查看服务器上跑的服务 ps -ef|grep sssc|grep jar 模糊搜索日志 cat sssc-soa-app_applicationLog_2019-07-25-3.log | grep “startup” 8. 为什么组合优先于继承？ 答： 继承耦合度高，组合使用java多态的特性降低耦合度。 比如，采用继承的方式，当父类需要发生变动时，而其所有的子类都会反映出这种变动。而组合却可以抽象出一个共有的接口，然后传入指定的实现类，让其他不相关类避免受影响。 数据结构1. List元素实现删除有哪些注意的？ 答：Collection集合相关类做删除操作时，不能边遍历边删除，因为内部维持了expectedModCount这么一个字段，如果modCount != expectedModCount并不等于，则会抛出ConcurrentModificationException异常。 2. 讲一下HashMap与HashTable的区别？HashMap的扩容方式，get()方法和put()方法，最好能写出代码。ConCurrentHashMap的实现原理？ 答： 3. 数组和链表的区别，ArrayList的扩容方式？ 答： 4. 队列与栈的区别，介绍常见的使用场景？ 答： 5. 手写一个Hashmap的遍历？ 答： 6. HashSet是怎么实现的？ 答： 7. 手写二叉树的遍历。 答： 算法1. 快排与冒泡的区别？手写一个试试？ 答： 2. 手写一个二分查找和归并排序？ 答： 3. 单链表的反转？迭代与递归的实现方式？ 答： JVM1. 按照你的理解，讲讲JVM内存结构？ 答： 2. 讲讲垃圾回收，常见的垃圾回收算法有什么？ 答： 3. 什么情况下会触发FULL GC?什么情况下会触发Mini GC？ 答： 网络1. 输入URL到页面加载发生了什么？ 答： 2. 讲一讲TCP三次握手,四次挥手，画一下 答： 3. 悲观锁与乐观锁的区别？ 答： 4. servlet API中forward()与redirect()的区别？ 答： 5. 讲一下get与post的区别？ 答： 6. 常见http的协议状态有哪些？ 答： 7. TCP与UDP的区别？ 答： 8. 讲讲序列化的底层实现原理。 答： 数据库1. 讲一讲数据库的优化有哪些？ 答： 主从同步，读写分离 分库分表 水平分表 垂直分表 建立索引，提高查询性能 缓存，减少对数据库的访问 2. 数据库怎么建立索引，索引有哪几种？ 答：参考文章Mysql创建索引 在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。 主键索引，普通索引，唯一索引 ALTER TABLE（用来创建普通索引、UNIQUE索引或PRIMARY KEY索引） ALTER TABLE table_name ADD INDEX index_name (column_list) ALTER TABLE table_name ADD UNIQUE (column_list) ALTER TABLE table_name ADD PRIMARY KEY (column_list) CREATE INDEX （对表增加普通索引或UNIQUE索引） CREATE INDEX index_name ON table_name (column_list) CREATE UNIQUE INDEX index_name ON table_name (column_list) 注：不能用CREATE INDEX语句创建PRIMARY KEY索引 注：PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引 删除索引 DROP INDEX index_name ON talbe_name ALTER TABLE table_name DROP INDEX index_name ALTER TABLE table_name DROP PRIMARY KEY 注：如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。 注：如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 查看索引 show index from tblname 字段解析 Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。 Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE） Seq_in_index 索引中的列序列号，从1开始。 Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 Cardinality 索引中唯一值的数目的估计值。 使用索引注意事项 查询较多，修改较少适合创建索引，经常插入、删除、修改的表不适合 建立索引会有相应的存储消耗 复合索引效率更高 3. 对redis了解吗？Redis有哪些数据结构？用来干什么？使用场景？ 答： Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合) String（字符串）：set与get Hash(哈希)：hmset与hgetall list（列表) : lpush与lrange set（集合）：sadd与smembers zset(sorted set：有序集合):zadd与zrangbyscore 4. 手写创建表，给表添加字段，修改字段的sql语句 答： 给表添加字段 alter table t_cloud_user add salemoney DECIMAL(12,2) DEFAULT ‘0’ COMMENT ‘销售额’; 修改字段 alter table t_cloud_user change m1 button VARCHAR(200) DEFAULT NULL COMMENT ‘button按钮’; 新建索引 alter table t_sssc_salary add index Code_WAGENO(code,WAGENO); create index Code_WAGENO on t_sssc_salary(code,WAGENO); 删除索引 DROP INDEX index_name ON talbe_name; ALTER TABLE table_name DROP INDEX index_name; 5. 主从同步延时的解决方案 缩小延时时间 修改主从库的配置参数，提高sql的执行效率 数据库的版本（5.6.3之后采取多线程同步） 提高从服务器的硬件性能（CPU，内存，SSD磁盘） 网络（局域网缩小同步延时时间） 不选择走从库 对于不经常更新的表，查询的时候配置直接走从库。 对于常更新的表（比如薪资表），更新之后放入缓存，查询的时候查缓存 ​ 多线程1. 并发与并行，同步与异步，线程与进程的区别？ 答： 2. 谈一谈线程池，常用的线程池有哪几种？线程池有什么作用？ 答： 3. 线程池怎么使用？如何设置核心线程数，队列长度，以及最大线程数。 答： 4. 创建线程有哪几种方式？ 答： 5. 线程有哪几种状态，如何进行转换的？ 答： 6. synchronized的底层是怎么实现的？ 答： 7. 手写生产者，消费者代码 答： 8. 如何避免死锁？ 答： 框架与模式1. 讲一下熟悉的设计模式？单例模式有哪几种？手写一个单例模式 答： 2. 单例模式和工厂模式的本质区别在哪里？ 答： 3. 简单介绍一下springMVC的执行流程？ 答： 4. 简单介绍一下Spring的两大核心？ 答： 5. 看过spring的源码吗？说说底层是怎么实现的？ 答： –]]></content>
      <categories>
        <category>interview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：计算机系统漫游]]></title>
    <url>%2F2019%2F09%2F01%2Fcsapp%2Fcs-tour%2F</url>
    <content type="text"><![CDATA[一个C语言程序的产生 之前在 走近计算机，走进二进制，爪哇国的诞生讲到一个java程序是怎么执行的，然而依然是知其然，而不知其所以然。今天特意来用C语言写一个程序，看看它是怎么在计算机上跑起来的。 源码 hello.c 12345#include &lt;stdio.h&gt;int main()&#123; printf("%s\n", "Hello,world!");&#125; 编译 源代码通过编译器编译得到目标程序 这个时候会在桌面生成目标程序hello【可直接运行】 目标程序文件里面都是 二进制 编译系统 编译时分工是这样的 计算机体系结构 总线 总线是贯穿整个系统的一组电子管道，它携带信息字节并负责在各个部件间传递。 按照部件之间信息传递划分：系统总线，存储器总线，I/O总线 按照功能划分：控制总线、数据总线、地址总线 I/O设备 输入/输出（I/O)设备是系统与外部世界的联系通道 一共有五种：鼠标、键盘、显示器、磁盘、扩展槽（常见的网卡） 主存 主存是一个临时存储设备，在处理器执行程序是，用来存放程序和程序处理的数据。 除去高速缓存使用SRAM外，主存一般使用的是DRAM硬件技术 CPU处理器 中央处理单元（CPU）,简称处理器，是解释（或执行）存储在主存中指令的引擎。 由三部分组成：控制器，运算器和寄存器 体系结构图 目标程序的执行 现在我们目标程序有了，那么怎么执行呢，从用户输入字符到打印结果到屏幕上，计算机到底经历了什么？ 执行时对话是这样的 存储设备层次结构 从上面的过程可以看到，hello程序初始时在磁盘上，当程序加载时，它又被复制到主存中，当处理器运行程序时，指令又从主存复制到处理器，当程序执行完时，“hello，world”又得复制回显卡，这一系列过程中都涉及数据的复制，如果复制的速度跟不上，那么计算机就可能会瘫痪。 我们知道，寄存器与CPU信息传递速度是主存的数百倍级别，是磁盘的百万倍级别，可是，寄存器能存的数据太小，并且同样大小存储造价比磁盘贵得不知道多少个数量级。为了提升计算机性能同时，又不想有太多的造价负担，高速缓存应运而生。 高速缓存的原理 空间局部性 就是说内存上如果某一地址空间的数据频繁的被CPU访问，那么其旁边的存储单元也有可能被访问。 时间局部性 在某一段时间内，内存上如果某一地址空间的数据频繁的被CPU访问，那么在未来很可能会再次访问。 存储设备层次结构 操作系统的抽象 基本功能 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备 抽象 文件是对I/O设备的抽象，虚拟存储器是对主存和磁盘I/O设备的抽象，进程则是对处理器、主存和I/O设备的抽象，虚拟机，提供对整个计算机（包括操作系统、处理器和程序）的抽象。 结构图： 进程与线程 进程 进程是操作系统对一个正在运行的程序一种抽象. 在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件. 而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的，操作系统实现这种交错执行的机制称为上下文切换。 实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。 线程 一个进程可以包含多个线程，但至少包含一个线程。 书上是这样说的，在现代系统中，一个进程实际上是可以由多个吗称为线程的执行单元，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。 并且多线程之间比多进程之间更容易共享数据，线程一般来说比进程更高效。 并发与并行 并发 使计算机做得更多 单核处理器在某时间段（宏观上）处理多个任务。 注，是指宏观上（即某一时间段），其实从微观看来（在任何一个时刻），单处理器系统都只能执行一个进程的代码。 并行 使计算机处理的更快 同一个进程里面的任务可以在多个处理器上运行。 并发与并行对比图 参考资料: 学习笔记深入理解计算机系统（原书第二版）]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHELL命令汇总]]></title>
    <url>%2F2019%2F04%2F10%2Fshell-commands%2F</url>
    <content type="text"><![CDATA[SHELL命令汇总在Mac使用小技巧中提到了终端命令操作，但是概括得不全，加上之前没有接触过linux命令，面试时问到时很是慌得一批，不过现在有了Mac本，终于有理由逼自己一把了，哈哈，让我们一起来学习吧！ 查看隐藏文件夹defaults write com.apple.finder AppleShowAllFiles TRUE killall Finder不想显示被隐藏的文件defaults write com.apple.finder AppleShowAllFiles FALSE killall Finder使文件不隐藏chflags nohidden /Users/alongso_pro/Desktop（只对隐藏文件/文件夹有用）使文件隐藏chflags hidden /Users/alongso_pro/Desktop（只对可见文件或文件夹有用）sudo命令为系统超级管理员755 代表用户对该文件拥有读，写，执行的权限。创建文件touch .aa打开文件open .aa配置环境变量source .aa开启tomcat进入tomcat的bin目录，键入sudo sh startup.sh关闭tomcat服务sh ./shutdown.sh查看端口被哪个程序占用sudo lsof -i tcp:8080根据进程的PID，可以将进程杀死sudo kill -9 1659如何查看系统中每个进程:ps -A ps -e命令提供了运行中系统动态的视图top查看当前目录的路径pwd /Users/alongso_pro/Desktop使用绝对路径进入文件夹，不改变当前目录:cd / 使用相对路径进入文件夹，改变当前目录cd Users/alongso_pro/Desktop qianmoyushengMacBook-Pro:Desktop alongso_pro$ 查看当前目录下的所有文件夹,不改变当前目录(list directory contents)： ls -l/-R/-a 绝对路径/相对路径 -l,查看目录中每个文件的权限 -R,显示目录下所有的文件夹和文件 -a,显示目录下所有的文件夹和隐藏文件 man+所有命令可以查看该命令的信息介绍(format and display the on-line manual pages)： man ls、 man open 、man chflags 也可以敲下该命令直接回车。 man ls: 命令后在最后出现一个end,返回继续输入命令:q或者ctr+c将所有截图保存为JPG，而不是系统默认的PNGdefaults write com.apple.screencapture type -string “jpg&quot;文件的拷贝ln -s ~/Desktop/党员党费详情.xlsx ~/workfile/ ln [-Ffhinsv] source_file [target_file] ln [-Ffhinsv] source_file ... target_direcho,相当于println--write arguments to the standard outputsay 语音say -f /Users/alongso_pro/Desktop/《三国演义》罗贯中.txtcat 打印文本内容-- concatenate and print files cat /Users/alongso_pro/Desktop/《三国演义》罗贯中.txthead-- display first lines of a filetail-- display the last part of a filenl-- line numbering filter一个有趣的ASCII版动漫:“星球大战：新希望”telnet towel.blinkenlights.nl chrome的小恐龙游戏：在没连网的情况下在Chrome地址栏输入：`chrome://dino/`]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac使用小技巧]]></title>
    <url>%2F2019%2F03%2F10%2Fmac-skills%2F</url>
    <content type="text"><![CDATA[Mac使用小技巧 最近新入手了一台Mac笔记本，发现Mac OS使用起来特别人性化，Mac系统是基于Unix内核的图形化操作系统.对于一位开发者而言，我最欣赏的是能在终端上随心所欲，对电脑进行任何操作，当你实现了某个功能时候，心中不油而然生出一种莫名的成就感，长此以往，也能激发我对程序开发的热情。我一直相信，Mac笔记本不只是开发工具，当它摆在你面前，它更像一件艺术品。为了快速上手Mac，这里总结了一些小技巧。 快捷键篇拷贝文件的路径option+command+C根据路径打开文件command+shift+G快速进入硬盘最高目录command+shift+C快速关闭app或者tab页窗口command+w/command+Q最小化窗口Commmand+m(相当于点击窗口的最小化&apos;-&apos;)窗口最大化Command + control + F快速隐藏command+H新建应用程序窗口command+N刷新网页Command+R撤销/重做command+Z/command+Shift+Z返回文件上一级Command + 方向全面截屏快捷键command+shift+3部分截屏快捷键command+shift+4（这个挺麻烦，我还是喜欢用wechat截图工具）录屏（快速打开屏幕快照）Shift + Command + 5快速查看/操作您不仅可以预览文件，现在还可以进行各种编辑操作，如裁剪照片、签名 PDF 表单和修剪视频片段，以标记图像。轻松搜索Command + 空格键 如果想查看文件所在路径，可按住command（但是我想打开文件的所在目录怎么办呢？）拷贝文件command+C&amp;&amp;command+V移动文件先拷贝文件， 然后进入你要拷贝到的文件夹，空白处右键，按住alt键，点击将项目移动到这里新建浏览器窗口command+shift+n使用浏览器定位地址栏command+L缩放字体command加上+/-键打开偏好设置command+,缩放快捷键（相当于缩放镜）option+command+(-/+)清空废纸篓shift+command+delete直接清倒废纸篓shift+option+command+delete打开某个文件command+O(=双击)重命名回车键（=间隔的两次点击）查看某个文件夹中隐藏的文件shift+command+.恢复之前是否被隐藏的状态shift+command+.新的tab页中打开链接按住command，点击链接tab页之间的切换shift+command+左右方向键操作篇桌面分屏在同一个桌面的两个窗口，按住窗口最大化按钮拖动到左上角，然后点击另外一个窗口。如果不再同一个桌面，先将一个窗口最大化，然后将另外一个桌面的窗口拖进来手机遥感keynote播放ppt时可以用手机来进行遥控新建检索索引点击文件/文件夹—简介，修改注释alis，然后通过comand+space输入注释的文本英文提示快捷键F5或者带bar中显示的提示（智能选取-pages,keynote，wechat也适用）对磁盘权限进行检查和修复sudo periodic daily weekly monthly自带输入法使用技巧拼音分词，打开键盘可以设置快捷键，（omw-on my way!）shift+6可以输入表情符号移动底下的窗口时为了上面的窗口被遮挡按住command进行拖动文件检查器选中文件，右键按住alt，点击show inspector，查看几个文件，操作，图片还能幻灯片显示屏幕共享操控设置 &gt; 共享中开启「屏幕共享」，之后进入访达 &gt; 点按「网络」&gt; 连接要共享的 Mac，然后点按「共享屏幕」参考链接 终端命令篇查看文件/文件夹占用的存储空间du -sh */dir/file查看活动监视器top htop终端颜色装饰的命令(需自己安装) 安装参考链接 查看所有执行过的命令history 打开文件夹，文件，应用程序和网址open / || open http://baidu.com查看剪切板内容pbpaste 也可以通过可视化窗口查看：finder—&gt;edit—&gt;show cliboard软件推荐篇截屏软件XnipXnip——截屏了以后可以选择保存到哪个目录下视频播放器IINAQuickTim是Mac自带的视屏播放器，可以打开mp4、mov等格式的视频，却无法打开rmb、rm、flv等格式的视频，我用IINA了一段时间，感觉体验不错。印象笔记在笔记这块，我用的是印象笔记，功能相当强大，支持markdown和mindMap格式,用习惯了相当不错。]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习路线规划]]></title>
    <url>%2F1994%2F10%2F02%2Fmyresume%2Flearn_route_planning%2F</url>
    <content type="text"><![CDATA[岗位描述 负责内容 负责错题本的开发和维护工作 分库分表技术选型，制定数据迁移方案 推题算法融合，将原有的两套题库系统融入成一套 项目架构 Spring Cloud架构，DAO层Mybatis，数据库mysql 缓存中间件Redis、ES、消息中间件Kafka、注册中心K8S、配置中心Spring Config、网关 Spring Gateway 版本管理 Gitlab 服务依赖 jar包仓库gradle 安全 鉴权 数据传输加密 部署 Docker、K8s，使用gitlab-runner+rancher的方式实现ci/cd 监控 actuator监控服务 ELK日志收集 手头的事数据库技术选型 两张大表（数量级都在七千万级别）需要做关联查询，后续会快速增长到亿级别，目前还没有分表，需要分表。考虑的分布式数据库有TiDB，分表中间件shading sphere，做技术选型，并实践。 推题算法融合 对原有两套推题服务进行融合，将知识图谱的推题思想抽取出来，融入到jpk的推题中，根据用户行为，答题对错，得出用户的知识点薄弱，推送知识点难度相当的题目。 学习规划mysql调优、sharding sphere、redis、spring boot源码（7）、springCloud（13）、网约车（32）、算法（基础+进阶）、kafka、ES]]></content>
      <categories>
        <category>learn_route_planning</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F1994%2F10%2F02%2Fmyresume%2Fnew_resume_forth%2F</url>
    <content type="text"><![CDATA[个人信息 陈建蓉/男/1994 学历：西南大学(211)/本科/计算机专业 毕业时间：2018年 工作年限：3年 微信公众号：阡陌余生 技术博客：https://alongsocjr.github.io 应聘信息 期望职位：Java高级工程师 上岗时间：可随时到岗 手机号：17718480976（同微信） 邮箱：alongsocjr@163.com 技能清单 了解class文件结构 ，理解class文件的详细信息，熟悉常用的字节码指令集。 掌握Mysql事务隔离级别与锁的机制，多年实战经验，对索引及存储引擎有深入研究，有线上调优经验。 熟练掌握Java基础，熟悉JUC 、集合框架、设计模式；熟练常用 算法，有较强的代码优化能力。 熟悉JMM、JVM和GC底层算法，熟悉多种常见的垃圾回收器，熟悉JVM调优，有实战经验。 熟悉使用Redis缓存技术及应用场景，熟悉持久化机制以及缓存击穿、缓存雪崩、缓存穿透等解决方案。 掌握RabbitMq、Zookeeper中间件的使用，手写过分布式锁的实现。 熟练SpringBoot、Spring、Mybatis，多年实战经验，可以通过需求快速构建项目，看过核心源码。 工作经历猿辅导（在线教育独角兽）（2020年10月~至今）岗位：服务器研发工程师 描述：就职于基础研发平台部，主要负责财务线上ERP相关系统的开发和维护工作，参与财务报销系统的全体重构，从0到1的技术落地。同时参与计费系统、ERP前置系统对外接口的开发。 阳光保险 （2018年7月~2020年10月）岗位：JAVA开发工程师 描述：以应届生的身份加入阳光保险，在校招生培训中获得优秀学员称号，项目小组作品荣获一等奖。在寿险营销渠道项目组，主要负责新老系统架构迁移工作，参与薪资计算、考勤追踪等核心项目开发，在2019年度创新项目评比中，由我主导的消息推送平台荣获三等奖。 项目经验财务报销系统 （2020年10月~至今）项目描述：通过OA系统申请的报销单，审批通过后进入报销系统，对单据进行付款、生成日记账、归档等处理，代替了原有线下手工人工操作付款以及对账的方式，提高工作效率。 技术栈：SpringBoot+Dubbo+Zookeeper+SpringJDBC+Mysql+Xxl Job+Swagger 担任职责： 数据库建模与mysql优化 制定定时任务解决方案 负责基础数据模块的开发 负责服务器资源申请和前期项目搭建 薪资计算引擎 （2018年7月~2020年10月）项目描述：以消息为驱动 触发薪资实时计算，实现了业务员薪资的实时预警，代理人出单半小时内能看到所出最新保单带来的薪资变化。解决了原有薪资计算存在的计算滞后、反复查询、重复计算等问题。 技术栈：SpringBoot+Dubbo+Zookeeper+RabbitMq+Redis+OneProxy+Mysql 核心点： 使用redis作二级队列流量削峰，提高了系统吞吐量，同时对MQ一级队列中全国的计算消息有序分组。 使用分布式ZK锁保证多台服务之间，同一机构的计算是串行的，不同机构的计算是并行的。 使用线程池管理系统服务资源，减少线程的来回创建，一个线程负责计算一家机构内所有的消息。 担任职责： 参与了项目的整体规划与设计 优化了分布式锁的选择 设计了防止消息丢失的方案 对接企业微信，对系统异常实时监控 考勤大屏追踪 （2019年5月~2019年10月）项目描述：追踪全国代理人出勤情况，将考勤数据从线下搬至线上，可通过调用接口监控营业区代理人职场画面。 技术栈：SpringBoot+Dubbo+Zookeeper+Redis+Mysql+SqlServer 核心点： 配置双数据源，从SqlServer数据库取当天打卡信息基础数据，从Mysql数据库取历史出勤数据。 可以选择全国、二级、三级和营业区不同维度统计，也可按照职级和子渠道进行统计。 担任职责： 搭建新的服务，模块梳理以及缓存设计 负责外围系统网络权限的开放与接口的联调 解决上线初期的性能问题与bug 担任开发组长，负责核心业务开发]]></content>
      <categories>
        <category>resume</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>job</tag>
      </tags>
  </entry>
</search>
