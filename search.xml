<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2020%2F06%2F20%2Fpatterns%2Fstate%2F</url>
    <content type="text"><![CDATA[简介状态模式 有点类似策略模式，同样是变化，只是应对变化的方式不一样而已。策略模式面对变化，是采取将变化的部分与不变的部分分离开来，采取封装算法族的方式进行抽象，具体实现只需对不同接口进行组合。而状态模式，变化的部分取决于对象的内部状态，通过当前的状态来决定每个方法的具体实现。 思路《Head First设计模式》给了一个糖果机的案例，它的运行机制是这样的：首先糖果机有四种状态，分别是没有25分钱、有25分钱、售出糖果、糖果售罄。同时，导致糖果机状态变化也对应着四个动作，分别是：投入25分钱、退回25分钱、转动曲柄、发放糖果。糖果机的状态转化关系如下： 如图，糖果机的实现应该包含四个方法，而且每个方法的具体行为跟糖果机当前的状态有关系。比如说，当没有25分钱时是不能退回25分钱和售出糖果的。当转动曲柄的时候，如果没有糖果应该提醒顾客已售空。 实现在使用状态模式之前，我们的 代码实现 可能是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142public class GumballMachine &#123; final static int SOLD_OUT = 0; // 售罄状态 final static int NO_QUARTE = 1; // 没有25分钱 final static int HAS_QUARTER = 2; // 有25分钱 final static int SOLD = 3; // 售出糖果 int state = SOLD_OUT; // 默认为售罄状态，因为没有糖果 int count = 0; public GumballMachine(int count) &#123; this.count = count; if (count &gt; 0) &#123; // 初始化时如果大于0，为没有25分钱 state = NO_QUARTE; &#125; &#125; // 投入硬币 public void insertQuarter() &#123; if (state == HAS_QUARTER) &#123; System.out.println("You cna't insert another quarter"); &#125; else if (state == NO_QUARTE) &#123; state = HAS_QUARTER; System.out.println("You inserted a quarter"); &#125; else if (state == SOLD_OUT) &#123; System.out.println("You can't insert a quarter,the machine is sold out"); &#125; else if (state == SOLD) &#123; System.out.println("please wait,we're already giving you a guaball"); &#125; &#125; // 退回硬币 public void ejectQuater() &#123;&#125; // 转动曲柄 public void turnCrank() &#123;&#125; // 发放糖果 public void dispense() &#123;&#125; // 其他方法 &#125; 这样子实现也没什么问题，但是随着业务的变更，比如需要有10%的可能会掉下两个糖果，发现上面的代码并没有遵循开闭原则、状态转化埋藏在条件语句中，并不好理解。更重要的是没有将会变化的部分封装，牵一发而动全身，未来很有可能导致隐藏的bug。 重构在重构之前，我们先梳理一下逻辑： 首先，我们定义一个State接口，在这个接口内，糖果机的每个动作都有一个实现的方法。 然后，为机器的每个状态实现状态类，这些状态类将负责在对应的状态下进行的行为。 最后，我们要摆脱旧的条件代码，取而代之的是，将动作委托到状态类。 类图设计如下： 状态接口定义为 12345678910public interface State &#123; void insertQuater(); // 投入硬币 void ejectQuater(); // 退回硬币 void turnCrank(); // 转动曲柄 void dispense(); // 发放糖果&#125; 糖果机的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class StateGumballMachine &#123; State noQuaterState; State hasQuaterState; State soldState; State soldOutState; State state = soldState; int count = 0; public StateGumballMachine(int count) &#123; noQuaterState = new NoQuaterState(this); hasQuaterState = new HasQuaterState(this); soldState = new SoldState(this); soldOutState = new SoldOutState(this); this.count = count; if (count &gt; 0) &#123; state = noQuaterState; &#125; &#125; // 投入硬币 public void insertQuarter() &#123; state.insertQuater(); &#125; // 退回硬币 public void ejectQuater() &#123; state.ejectQuater(); &#125; // 转动曲柄 public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; // 发放糖果 public void releaseBall() &#123; System.out.println("A gumball comes rolling out the slot..."); if (count != 0) &#123; count = count - 1; &#125; &#125;&#125; 对应没有25分钱的状态类实现为： 1234567891011121314151617181920212223242526272829public class NoQuaterState implements State &#123; StateGumballMachine stateGumballMachine; public NoQuaterState(StateGumballMachine stateGumballMachine) &#123; this.stateGumballMachine = stateGumballMachine; &#125; @Override public void insertQuater() &#123; System.out.println("You inserted a quarter"); stateGumballMachine.setState(stateGumballMachine.getHasQuaterState()); &#125; @Override public void ejectQuater() &#123; System.out.println("You haven't inserted a quater"); &#125; @Override public void turnCrank() &#123; System.out.println("You turned,but there are no gumballs"); &#125; @Override public void dispense() &#123; System.out.println("You need to pay first"); &#125;&#125; 售出糖果的状态实现 12345678910111213141516171819202122232425262728293031323334public class SoldState implements State &#123; StateGumballMachine stateGumballMachine; public SoldState(StateGumballMachine stateGumballMachine) &#123; this.stateGumballMachine = stateGumballMachine; &#125; @Override public void insertQuater() &#123; System.out.println("please wait,we're already giving you a guaball"); &#125; @Override public void ejectQuater() &#123; System.out.println("Sorry,you already turned the crank"); &#125; @Override public void turnCrank() &#123; System.out.println("Turing twice doesn't get you another gumball!"); &#125; @Override public void dispense() &#123; stateGumballMachine.releaseBall(); if (stateGumballMachine.getCount() &gt; 0) &#123; stateGumballMachine.setState(stateGumballMachine.getNoQuaterState()); &#125; else &#123; stateGumballMachine.setState(stateGumballMachine.getSoldOutState()); &#125; &#125;&#125; 从上面 代码实现 很容易看出，每个状态是如何进行转化的，而且如果需要再添加一种状态的话，也是很容易进行扩展的。总而言之言之，状态模式提升了代码的可读性和可扩展性。 那么，现在回到刚才那个问题： 需要添加可能会一下出两颗糖果的可能，代码应该怎么实现呢？ 定义书上定义为： 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 类关系图为：]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板方法]]></title>
    <url>%2F2020%2F06%2F05%2Fpatterns%2Ftemplate%2F</url>
    <content type="text"><![CDATA[简介模板方法，顾名思义，就是个方法，其实质是对算法的封装。通过继承的方式，将公共的代码封装在父类中，实现代码的复用，将变化的部分抽象成抽象方法，交给子类去实现。通过模板方法，我们就算法封装成先干什么、后干什么，最后干什么，子类实现只需提供对变化部分的具体实现，具体步骤无需在重新定义。一般情况，为了更好的保护程序，不被子类篡改算法，模板方法会用final 修饰。 实现《Head First设计模式》举了一个冲茶和冲咖啡的例子，由于他们包含相同的部分（比如烧开水，装入杯子），但是又包含不同的部分（泡法、加入食材），因此不变的代码可以复用，变化的代码交给子类定义，实现代码如下： 1234567891011121314151617181920public abstract class CaffeineBeverage &#123; final void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; protected abstract void brew(); protected abstract void addCondiments(); private void pourInCup() &#123; System.out.println("Pouring into cup"); &#125; private void boilWater() &#123; System.out.println("Boiling water"); &#125;&#125; 子类需要继承父类，提供具体的实现 12345678910111213public class Tea extends CaffeineBeverage &#123; @Override protected void brew() &#123; System.out.println("Steeping the tea"); &#125; @Override protected void addCondiments() &#123; System.out.println("Adding Lemon"); &#125;&#125; 定义书上定义为： 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 类图为： 扩展钩子hook在定义的父类中，我们可以定义一个空方法。当子类需要使用时，可以去覆盖该方法，当没覆盖时，就什么都不干。 好莱坞原则该原则有点类似前面的依赖倒置原则 别调用（打电话）我们，我们会调用（打电话）你。 应用模板方法一个典型的例子就是定义排序算法，比如冒泡排序、插入排序、选择排序等等。 源码案例双亲委派模型、AQS算法、spring的refresh方法 实际开发计算引擎消息架构、报表打印实现]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2020%2F05%2F30%2Fpatterns%2Fcommands%2F</url>
    <content type="text"><![CDATA[简介命令模式，通过对请求命令的封装，对命令的请求方和执行方进行解偶，书本上举例了顾客点餐的过程，顾客下单点餐，然后服务员将菜单拿给厨师制作，通过菜单实现了顾客与服务员，服务员与厨师之间的解偶。 实现定义一个命令接口，接口只有execute方法 1234public interface Command &#123; void execute();&#125; 对命令的一种实现，比如：打开电灯泡，这里封装了灯泡对象 12345678910111213public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125; 遥控器可以执行命令对象，至于命令具体是怎么执行，我不需要关心，因为封装在请求里面了 12345678910111213141516public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl() &#123; &#125; public void setCommand(Command command) &#123; this.slot = command; &#125; public void buttonWasPressed() &#123; slot.execute(); &#125;&#125; 对遥控器进行简单测试 12345678910111213141516171819public class SimpleRemoteControlTest extends AbstractTest &#123; SimpleRemoteControl simpleRemoteControl = null; Light light = null; Command command = null; @Before public void setUp() throws Exception &#123; simpleRemoteControl = new SimpleRemoteControl(); light = new Light(); command = new LightOnCommand(light); &#125; @Test public void buttonWasPressed() &#123; simpleRemoteControl.setCommand(command); simpleRemoteControl.buttonWasPressed(); &#125; &#125; 通过测试我们看到，遥控器可以set不同的命令，至于命令的接收者封装在了命令的实现当中，遥控器漠不关心，只是执行了command.execute()方法，具体干嘛了也不知道，这样实现了客户请求与请求执行之间的解偶，我们的类关系图如下： 定义在书上定义为： 将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 类图为： 应用在实际的开发中，我们用到命令模式的地方有：线程池、工作队列。 命令可以支持撤销操作，所以一个常见的用于日志请求，比如电脑死机数据恢复处理，mysql日志备份和还原。]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2020%2F05%2F24%2Fpatterns%2Ffactory%2F</url>
    <content type="text"><![CDATA[简介工厂模式，顾名思义，就是制造对象的工厂。在学习之前，是存在很大的误解的，之前认识的工厂是简单工厂，它并不属于工厂模式的范畴，真正的工厂模式有两种，分别是工厂方法模式、抽象工厂模式。 工厂方法模式是使用抽象方法，使用子类继承的方式去实现。抽象工厂模式是抽象出一个工厂的接口，用具体的工厂去实现接口，然后采用组合的方式，去解藕。总而言之，两者使用的场景不一样，感觉差别挺大。 静态工厂本章案例是制造Pizza，讲解的思路是：一个店面给顾客制造不同口味的披萨，发现效益不错，别的地方的商店想加盟，希望也能套用你的模板，再到不同地方的商店希望在本地有对应原料加工工厂。可见，随着业务的扩张，带来的变化变化也越来越多，这个时候各个模式就在应对这种变化中产生了静态工厂、工厂方法、抽象工厂 首先是静态工厂，在使用静态工厂前，顾客下订单的实现应该是这样的： 12345678910111213141516171819202122public class PizzaStore &#123; Pizza orderPizza(String type) &#123; Pizza pizza = null; // 变化的部分 if ("cheese".equals(type)) &#123; pizza = new CheesePizza(); &#125; else if ("peperoni".equals(type)) &#123; pizza = new PepperoniPizza(); &#125; else if ("clam".equals(type)) &#123; pizza = new ClamPizza(); &#125; // 不变的部分 pizza.preprae(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 在上面代码中，我们发现ifelse代码是经常发生改变的，每增删一种口味的Pizza就要修改这段代码，这必将造成系统难以维护。在策略模式中学到了应该将变化的部分和不变的部分分离出来，那么我们对这部分代码做一个封装，这就是简单工厂了，单独负责Pizza的创建。 实现的代码如下： 123456789101112131415161718public class SimplePizzaFactory &#123; public Pizza create(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new CheesePizza(); &#125; else if ("peperoni".equals(type)) &#123; pizza = new PepperoniPizza(); &#125; else if ("clam".equals(type)) &#123; pizza = new ClamPizza(); &#125; else if ("veggie".equals(type)) &#123; pizza = new VeggiePizza(); &#125; else &#123; System.out.println("本店没有该口味披萨，请换购其他类型"); &#125; return pizza; &#125;&#125; 当新增新口味的Pizza时，我们只需修改这里的代码，create方法可以声明为静态的，当调用的时候可以不需要创建对象，直接调用。但这种设计不容易扩展，运行的时候不能修改create的行为。 那么，当有不同的加盟商到来时，这个时候create方法不得不变，要怎么办呢？这个时候我们可以这样做： 但是，更大的变化再等着我们，有些加盟商说，想要自己的一套bake、cut、box的方式。 工厂方法工厂方法要求不同的厂商提供自己的create方法，同时可以提供自己一套烘烤、切片、包装的方式。这个时候，工厂方法来解救我们。 简单工厂将create方法进行了抽象，交给子类去实现。当定义的Pizza有自己的烘烤、切片、包装方式时，在子类定义的时候需要进行覆盖。 实现为： 12345678910111213141516public abstract class PizzaStore &#123; Pizza orderPizza(String type) &#123; // 变化的一部分 Pizza pizza = creatPizza(type); // 不变的一部分 pizza.preprae(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; abstract Pizza creatPizza(String type);&#125; 加盟商只需实现该方法，当该加盟商新增一种口味时，只需在以下实现中做一下修改，相比于简单工厂的方式，更加易于维护，而且对系统的影响度更低。 12345678910111213public class NYStylePizzaStore extends PizzaStore &#123; @Override Pizza creatPizza(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new NYStyleCheesePizza(); &#125; else if ("peperoni".equals(type)) &#123; pizza = new NYStylePepperoniPizza(); &#125; return pizza; &#125;&#125; 讲到这里，是不是对工厂方法有了大概的了解，我们来看看到底什么是工厂方法吧！ 工厂方法模式 书上定义为： 定义了一个创建对象的接口，但由于子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 到这里，可以回顾一下，如果使用简单工厂去实现，会是什么样的？会出现一个高度依赖的工厂类，当新增或删减时，对系统的影响是很大的。这样使得PizzaStore类高度依赖所有的Pizza对象，这里违背了我们新学到的一个设计原则依赖倒置原则： 要依赖抽象，不要依赖具体类。 这个原则说明了：不能让高层组建依赖低层组件，而且，不管高层或底层组件，两者都应该依赖于抽象。 所谓高层组件，是由其底层组件定义其行为的类。在这里，PizzaStore是高层组件，因为它的行为是由Pizza定义的，PizzaStore创建所有不同的Pizza对象，准备、烘烤、切片、装盒；而Pizza本身属于底层组件。 抽象工厂到这里，系统已经有了良好的弹性框架，而且遵循设计原则。但是，我们的设计远远没有结束，比萨店成功的关键在于新鲜、高质量的原料，要是在当地建立一个原料的工厂，还能实现更大的利润。 我们首先得定义原料工厂： 1234567891011121314public interface PizzaIngredientFactory &#123; Dough createDough(); Sauce createSauce(); Cheese createCheese(); VeggiePizza createVeggiePizza(); Pepperoni createPepperoni(); Clams createClams();&#125; 将Pizza的parepar进行抽象 12345678910111213141516171819public abstract class Pizza &#123; String name; // 面团 Dough dough; // 酱料 Sauce sauce; // 一套佐料 Cheese cheese; Pepperoni pepperoni; Clams clams; abstract void preprae();&#125; 其实这里就有点类似于工厂方法了，交给子类去实现 12345678910111213141516public class CheesePizza extends Pizza &#123; PizzaIngredientFactory pizzaIngredientFactory; public CheesePizza(PizzaIngredientFactory pizzaIngredientFactory) &#123; this.pizzaIngredientFactory = pizzaIngredientFactory; &#125; @Override void preprae() &#123; System.out.println("Preparing " + name); dough = pizzaIngredientFactory.createDough(); sauce = pizzaIngredientFactory.createSauce(); cheese = pizzaIngredientFactory.createCheese(); &#125;&#125; 最后定义具体的PizzaStore 123456789101112131415161718public class NYPizzaStore extends PizzaStore &#123; PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); @Override Pizza creatPizza(String type) &#123; Pizza pizza = null; if ("cheese".equals(type)) &#123; pizza = new CheesePizza(ingredientFactory); pizza.setName("NY Style Cheese Pizza"); &#125; else if ("clam".equals(type)) &#123; pizza = new ClamPizza(ingredientFactory); pizza.setName("NY Style Clam Pizza"); &#125; return pizza; &#125;&#125; 最后测试一下： 12PizzaStore pizzaStore = new NYPizzaStore();Pizza pizza = pizzaStore.orderPizza("cheese"); 可以跟踪一下代码执行 先是创建一个NYPizzaStore实例：PizzaStore pizzaStore = new NYPizzaStore(); 有了Pizza店了，接受订单：pizzaStore.orderPizza(&quot;cheese&quot;); orderPizza会先调用creatPizza方法：Pizza pizza = creatPizza(type); creatPizza方法调用时，涉及到原料工厂了：pizza = new CheesePizza(ingredientFactory); 拿到Pizza后，会调用prepare方法： 123456void preprae() &#123; System.out.println("Preparing " + name); dough = pizzaIngredientFactory.createDough(); sauce = pizzaIngredientFactory.createSauce(); cheese = pizzaIngredientFactory.createCheese();&#125; 最后，得到准备好的Pizza，orderPizza就会接着烘烤、切片、装盒。 抽象工厂模式在书上定义为： 提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。 代码链接 模型如图所示：]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2020%2F04%2F15%2Fpatterns%2Fstrategy%2F</url>
    <content type="text"><![CDATA[简介《Head Filst 设计模式》的第一章，讲的就是策略模式，策略模式算是一切模式的根本。在我理解看来，所有的模式都是由于随着业务的不断扩大，为了使得系统具有良好的扩展性、维护性而产生的，一种设计模式反应个很多个类之间的关系，使得系统耦合性更低，更容易扩展和维护。 思路策略模式讲解了一个关于Duck的相关设计案例，Duck有display、quack(呱呱叫)、swim的行为。起初的时候，设计是使用继承，发现随着变化，有的鸭子会fly，需要在父类里面加上fly方法，这下惨了，其实有些鸭子是不会飞的（不得不覆盖，空实现），导致噩梦的产生。 这是违背了原则3，由于继承带来的强耦合性。 后来考虑将quack、fly是变化的，那就把他们都抽象为一种行为吧，抽象出quackable、flyable接口怎么样，子类只要有以上两种行为，就去实现这个接口。但是问题又来了，如果有100种鸭子，就有100种flyable的实现，太可怕了吧，这样就没能代码复用。 代码复用才是我们设计的根本啊。 然后，设计模式登场了。 原则1：找出应用中可能需要变化之处，把它么独立出来，不要和那些不需要变化的代码混合在一起。 由于，在所有的实现中，swim的实现是唯一的，这是不会变的。而quack、fly是变化的，那么我们将这一部分抽象出去，交给一个专门的地方去实现，当需要使用的时候，我只需使用组合的方式，这样就能降低耦合度了。当然，我不能使用实现类组合的方式，因为，这样耦合度也太高了。那么，就使用接口吧！ 原则2：针对接口编程，而不是针对实现编程。 最后，我们的思路是这样的： Duck依然是抽象类，里面有swim实现方法、display抽象方法、还依赖了两个接口，分别是QuackBehavior接口、FlyBehavior接口，在quack方法里调用QuackBehavior.quack()、在fly方法里调用FlyBehavior.fly()，至于实现是什么，交给子类去决定。 原则3：多用组合，少用继承。 那么，子类决定的方式有哪两种方式呢 第一是使用构造器 第二是使用set方法 最后，类的实现是这样的： 总之，策略模式就是将这种变化封装了起来，放在另一个地方实现。那么，你脑子里面有类图了吗？有了之后就可以将代码落地了，哈哈！ 定义在书上其定义为： 定义了算法族，分别封装了起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 应用在我们工作中，策略模式的典型应用就是if条件很多的情况，将这部分变化的代码拿出来，不要将不变的代码混在一起，使用接口的方式降低耦合性，具体实现交给子类去实现。 补充这是我的代码实现、类图，欢迎来star😄 代码链接]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二进制与字节码]]></title>
    <url>%2F2020%2F04%2F12%2Fjvm%2Fbytecode%2F</url>
    <content type="text"><![CDATA[二进制自古以来，就有太极生两仪，两仪生四象，四象生八卦的文化传说。天与地，明与暗，是与非，有与无，宇宙万物貌似都是在这两个极端之间存在的。然而在计算机的世界里，这个世界又是怎样存在的呢，对的，就是用二进制来表示的。 转化十进制转二进制 250除二取余数，后面的余数居最高位，得11111010 十进制转八进制 250除八取余数，后面的余数居最高位，得372 二进制转八进制 11111010补全前面的位数，9位（3的倍数）得011 111 010，得372 表示数据在计算机中是通常是用二进制表示的，但是当加减运算时，是通过补码的方式来表示的，表示方式有原码与反码，补码。 正数的原码与反码，补码都相同，即它的二进制数 负数的补码稍微复杂一些。【所有的数据运算都是采用补码进行的】 负数补码的推算 方法一：直接推算法 利用原码加上补码等于0的特性，比如：5的二进制为0101+（-5的补码）=0（十进制）,得-5的补码为1111 1011 方法二：公式推算法 负数的补码=正数的二进制取反+1, 比如5的二进制取反为11111010，+1之后，得1111 1011 计算机语言介绍完二进制后，我们来了解一下有哪些计算语言 定义是指用于人与计算机之间通讯的一种特殊语言，是人与计算机之间传递消息的媒介。 分类低级语言机器语言直接用二进制指令表达。指令是用0和1组成的一长串代码。有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言使用一些特殊的符号代替机器语言的二进制码（又称符号语言），计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言，依赖于硬件体系，开发难度较大。 高级语言高级语言是相对于低级语言来说的，高级语言是按照人的思维编写出来的语言，比如C语言、C++、JAVA、Python等，其可读性高，但执行效率较低级语言低，编写的程序叫作源程序。 那么问题来了，对于高级语言，如果程序想运行，必须翻译成计算机能识别的低级语言才行，那么，高级语言是怎么翻译的呢？这就要借助编译器或者解析器了。 翻译语言分类编译型语言 如图所示，程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候（.exe），就不用再进行翻译了。这类语言编写的程序启动稍慢，执行稍快。比如C语言、C++ 解释型语言 不需要编译，运行时使用一个专用的解释器去翻译，每一条语句都是执行的时候才翻译，所以这类程序每执行一次就要翻译一次，这类语言编写的程序启动稍快，执行稍慢。比如Python 混合型语言 混合型语言，比如java，对源码进行编译后能得到class字节码文件，然后JVM拿到文件后会进行解释成C++语言，然后通过C++编译器编译成汇编语言。具体情况如下图： 适用场景 运行速度要求高,优选编译型。比如C语言做游戏开发 跨平台性，优选解释型，java主要用于做企业平台 字节码用IDE编写好JAVA源代码之后，会自动编译成class文件（字节码文件），里面存放的是Class类的信息【这里并不是将程序编译成机器语言，可以将字节码文件看作中间语言，在程序运行时，由JVM将字节码再翻译成机器语言】 运行机制 对于不同的操作系统，需要安装对应的JVM虚拟机，JVM通过字节码文件进行解释编译运行程序，因此java具有跨平台性。我们只需在系统上安装对应系统版本的JVM，我们就能将class文件运行起来。jvm会加载class文件进内存，java一般默认是混合模式编译，即解释器+热点代码编译，起始阶段采用解释执行，对于多次调用的方法或者循环，采用JIT即时编译。我们可以手动配置jvm使用什么模式： -Xmixed 默认为混合模式，开始解释执行，启动速度较快，对热点代码实行检测和编译 -Xint 使用解释模式，启动很快，执行稍慢 -Xcomp 使用纯编译模式，执行很快，启动很慢 Java模型 JVM：Java虚拟机（Java Virtual Machine）它是运行所有Java程序的虚拟计算机，好比是街机游戏的模拟器。 JRE：Java运行环境（Java Runtime Environment）如果要运行Java程序，就需要JRE，JRE里包含JVM和java类库。 JDK：Java开发工具（Java Development Kit）包含开发Java程序的所有工具(javac、java)，JDK里包含JRE和开发调试工具。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2020%2F04%2F12%2Fpatterns%2Fsingleton%2F</url>
    <content type="text"><![CDATA[简介单例模式，也叫单件模式。顾名思义，就是程序中只有一个实例。一般在我们实际工作中，会经常遇到这个模式，所以，掌握这个模式是应该的。 定义单件方式可以有很多中方法定义，可根据不同的应用场景来选择最合适的定义方式。根据目前所学习的知识，可分为以下五种，某些可能在多线程的环境下回出现安全问题，需要改进。 《Head Filst 设计模式》中定义为： 单件模式确保程序中一个类只有一个实例，并且能够提供访问这个实例的全局访问点。 饥汉式也叫饿汉式，二话不说 ，当jvm加载类时，就将类的静态实例初始化。 12345678910111213public class SingleInstanceT00 &#123; // 构造器私有化 private SingleInstanceT00() &#123; &#125; public static SingleInstanceT00 instance = new SingleInstanceT00(); public static SingleInstanceT00 getInstance()&#123; return instance; &#125;&#125; 在没有空间限制的情况下，可以选择这样使用。但是更优雅的做法是，调用的时候进行初始化，也就是延迟初始化。 延迟初始化延迟初始化会带来线程安全的问题，比如改造后的代码为： 12345678910111213141516171819202122public class SingleInstanceT01 &#123; // 构造器私有化 private SingleInstanceT01() &#123; &#125; public static SingleInstanceT01 instance = null; public static SingleInstanceT01 getInstance() &#123; if (instance == null) &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; instance = new SingleInstanceT01(); &#125; return instance; &#125;&#125; 经测试后发现，多个线程同时进入getInstance后，得到的不是同一个实例。 为了使得线程安全，解决方案也分为很多种，有synchronized同步方法、双重检查锁定和静态内部类初始化三种。 同步方法使用synchronized对getInstance方法进行同步处理，但会导致不必要的性能开销。如果getInstance()方法被多个线程频繁调用，将会导致程序执行的性能下降。只有不频繁调用的时候，可能是理想状态。实现方式为： 1234567891011121314151617181920212223public class SingleInstanceT02 &#123; // 构造器私有化 private SingleInstanceT02() &#123; &#125; public static SingleInstanceT02 instance = null; // 同步方法作用域太大，性能低 public static synchronized SingleInstanceT02 getInstance() &#123; if (instance == null) &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; instance = new SingleInstanceT02(); &#125; return instance; &#125;&#125; 使用synchronized 同步方法时可以不用加volatile，因为synchronized 可以保证原子性。 双重检查锁定双重检查锁定使用synchronized同步代码块的方式成功的优化了性能。只有第一次进来的时候，才需要加锁。其他时候进来的时候先判断instance是否为空，如果不为空的话，就直接进行返回。 12345678910111213141516171819202122232425262728public class SingleInstanceT03 &#123; // 构造器私有化 private SingleInstanceT03() &#123; &#125; public static volatile SingleInstanceT03 instance = null; public static SingleInstanceT03 getInstance() &#123; if (instance == null) &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 同步代码块 DCL synchronized (SingleInstanceT03.class) &#123; if (instance == null) &#123; instance = new SingleInstanceT03(); &#125; &#125; &#125; return instance; &#125;&#125; 注意：加volatile是为了防止指令的重排序，在jvm执行指令时，instance = new SingleInstanceT03() 分了三步： 第一步：给对象分配内存空间 第二步：将instance指向刚分配的内存地址（此时还是半初始化状态，有属性的话，属性尚未赋值） 第三步：初始化对象 如果没有加volatile，第二步和第三步会交换执行，导致其他线程拿到的是半初始化的实例，导致线程安全问题。 类初始化这也是延迟初始化的一种，基于类初始化实现的。实现原理是每个对象对应有一个初始化锁，初始化时线程需要获取该对象对应的初始化锁。如果没有获取，那么线程必须等到初始化锁释放了才能获取。 12345678910111213141516171819public class SingleInstanceT04 &#123; private SingleInstanceT04() &#123; &#125; private static class InnerInitialClass &#123; public static SingleInstanceT04 instance = new SingleInstanceT04(); &#125; // 原理：每个对象对应有一个初始化锁，初始化时线程需要获取该对象对应的初始化锁 public static SingleInstanceT04 getInstance() &#123; try &#123; // 模拟多线程，使效果更明显 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return InnerInitialClass.instance; &#125;&#125; 应用在《Head Filst 设计模式》提到，使用单件模式的地方很多。常见的有线程池、连接池、缓存、日志对象。 还用一些不常见的，对话框、处理偏好设置、注册表的对象、充当打印机、显卡等设备的驱动程序的对象。]]></content>
      <categories>
        <category>patterns</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[是时候揭开线程池这块面纱了（二）]]></title>
    <url>%2F2020%2F03%2F18%2Fconcurrentart%2Fthreadpool-usages2%2F</url>
    <content type="text"><![CDATA[线程池状态定义在简单介绍完线程池的基本概念后，这篇文章我们来分析一下，线程池它具体是如何工作的。首先我们看一下线程池的状态。线程池的设计是这样子的，它将线程池的状态和目前工作线程的线程数用一个变量来进行了存储，就是ctl变量 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 首先这是一个原子类，int类型，32位，前3位是用来标识线程池的状态的，后29位是用来表示线程池当中工作的线程数的。 通过使用原子类，这样就能保证线程池的状态和工作线程数的原子性了。那么，我们当前线程池的状态常量是如何标识的呢，以及当我们想要查询线程池的工作线程数，是怎样运算的呢。 123456789101112131415161718private static final int COUNT_BITS = Integer.SIZE - 3; // 29位用来存工作线程数private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 所能存放工作线程的最大数 2^29-1// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 运行状态 补码形式为：1110 00……private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 关闭状态 0private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 停止状态 0001 00……private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 清理状态 0010 00……private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 终止状态 0011 00……// Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; // 后29位取1 按位与操作private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; // 后29为取0 与运算private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; // 根据状态和工作数生成ctlprivate static boolean runStateLessThan(int c, int s) &#123; return c &lt; s;&#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; 线程池有5种状态，按大到小的顺序如下：RUNNING&lt;SHUTDOWN&lt;STOP&lt;TIDYING&lt;TERMINATED 使用原子类来存储两个变量，保证了共享变量的原子性，以及它按照位操作提升了很大的性能 状态解析RUNNING：in operation 运行，当线程池初始化的时候，线程池就处于RUNNING状态，处于该状态时，线程池可以接受任务，并且处理缓冲的任务。 SHUTDOWN：turn off 关闭，当调用shutdown()方法时，线程池从RUNING转化为SHUTDOWN状态，该状态的线程池不接受任务，只处理缓冲的任务 STOP：stop 停止，当调用shutdownNow()方法时，会将（RUNING/SHUTDOWN状态）转换成该状态，处于该状态的线程池不接受任务，不处理缓冲任务，并且中断全部正在处理的任务interrupt running tasks TIDYING：清理，当任务中断了，并且线程工作数为0，就会进入清理状态，清理现场。 When the thread pool is in the SHUTDOWN state, the blocking queue is empty and the tasks executed in the thread pool are also empty, it will be SHUTDOWN - &gt; tidying. When the task executed in the thread pool is empty in the STOP state, it will be STOP - &gt; tidying. TERMINATED：终止，结束，当terminated()方法执行完后，就会进入该状态 When the thread pool terminates completely, it becomes terminated. When the thread pool is in tidying state, after executing terminated(), it will be tidying - &gt; terminated. 状态转化1234567891011* RUNNING -&gt; SHUTDOWN* On invocation of shutdown(), perhaps implicitly in finalize()* (RUNNING or SHUTDOWN) -&gt; STOP* On invocation of shutdownNow()* SHUTDOWN -&gt; TIDYING* When both queue and pool are empty* STOP -&gt; TIDYING* When pool is empty* TIDYING -&gt; TERMINATED* When the terminated() hook method has completed* 通过介绍我们知道，线程池初始化时处于RUNNING状态，当线程池调用shutdown()方法时，线程池就关闭了，只处理当前已经进来的任务。当任务处理完之后，线程池会调用terminated()方法，执行完后线程池进入TERMINATED状态。当然还有另一中方式，不管线程池有没有调用shutdown()方法，如果调用了shutdownNow()，会中断正在执行的线程，线程中断需要调用sleep方法，当队列和线程池线程为空时，线程池就会进入stop状态。当池中线程为空时，terminated()方法执行完后进入TERMINATED状态。 构造方法123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); // 主线程不能小于0 if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 队列和线程工厂、策略不能为null this.acc = System.getSecurityManager() == null ?null :AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime);//将时间传入的unit和keepAliveTime转换为ns this.threadFactory = threadFactory; this.handler = handler;&#125; 提交执行task的过程​ 解释当提交一个新任务到线程池时，线程池的处理流程如下： 线程池判断核心线程数是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果是，则进入步骤2。 线程池判断工作队列是否已满。如果没有满，将新提交的任务存储在工作队列中。如果满了，则进入步骤3。 线程池判断线程池中线程是否都处于工作状态（已满）。如果没有，则创建一个新的工作线程。如果满了，则交给饱和策略来处理这个任务。 execute方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 如果任务不能提交，要么是因为当前线程池关闭了，要么是因为队列满了需要触发饱和策略 */public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); // worker数量比核心线程数小，直接创建worker执行任务 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // worker数量超过核心线程数，任务直接进入队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // 线程池状态不是RUNNING状态，说明执行过shutdown,需要对新加入的任务做reject操作 // 这儿为什么需要recheck,是因为任务入队前后，线程池的状态可能发生变化。但是一般检查一下，并没啥用。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 这儿为什么需要判断0值，是因为线程池构造方法中，允许线程池的核心数为0，如果遇上SynchronousQueue类型的队列，我也能创建线程去消费，不会一直阻塞 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 如果线程池不是运行状态，或者任务进入队列失败，则会尝试创建worker执行任务 // 注意3点 // 1. 线程池不是运行状态时，addWorker方法内部会去判断线程池状态 // 2. addWorker的第二个参数表示是否创建核心线程 // 3. addWorker方法返回false，说明任务执行失败，需要执行reject操作 else if (!addWorker(command, false)) reject(command);&#125; execute方法本身来说并不难，我们来这样子分析。 第一步，传入来的command不能为空 第二步，取到当前ctl，拿到当前工作线程数与核心数比较，如果小于，直接创建worker执行任务，否则进入下一步。 注意，addWorkerf方法的第二个参数表示是否核心线程。方法本身会去判断当前线程池状态和数量的，如果addWork失败，方法会返回false，表示添加任务失败，在重新获取一下ctl，用于下一步 第三步，走到这一步说明，不是核心数满了，就是线程池shutdown了。看一下当前线程池状态，如果是运行状态，就尝试往队列中放任务，如果放成功了返回true，放任务前后都得去拿一下当前的ctl，再去判断一下线程池是否shutdown了，如果shutdown了，就把任务从队列中remove掉。如果没有shutdown，会去判断当前工作线程数。 如果为0，我就启动一个线程，并且这里传入的firstTask还是null，这是为什么呢? 第四步，这一步相当重要，走到这一步，说明线程池不是运行状态了，或者任务进入队列失败了，为了消费任务，会尝试创建（非核心）worker执行任务，如果创建失败，则要采取饱和策略，执行reject操作。 addWorker源码解析干了两件事情 使用CAS算法将workerCount加一 将任务装入到worker中，并且将work添加到工作线程集合workers中,开始执行任务 worker是一个任务单元，继承了AQS类，本身是把锁，而且构造方法是RUNNALE任务，因此可以使用start方法执行线程中的run方法 如果线程启动失败，将这个worker从当前线程池works集合中删除，并且将workerCount减一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 外层自旋 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; // 如果状态&gt;SHUTDOWN,返回false ! (rs == SHUTDOWN &amp;&amp; // 如果状态=SHUTDOWN，且task!=null,返回false firstTask == null &amp;&amp; // 如果状态=SHUTDOWN，且队列为空，返回false ! workQueue.isEmpty())) return false; // 内层自旋 for (;;) &#123; int wc = workerCountOf(c); // 判断工作线程数，是否超过最大值和标准值 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 使用一次CAS算法，使得c++,就是wc++ if (compareAndIncrementWorkerCount(c)) // 如果成功，跳出外部循环进入第二部分 break retry; // 如果失败，应该是有线程把ctl改了，比较一下 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) // 不等于的话进入外部循环自旋，重新获取ctl continue retry; // else CAS failed due to workerCount change; retry inner loop（等于的话，内部自旋） &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; // worker的添加必须是串行的，必须得加锁 mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 重新检查线程池状态 int rs = runStateOf(ctl.get()); // 如果处于RUNNING状态或者SHUTDOWN时传递的任务为空 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // 如果worker已经调用过start方法了，则不再创建了 if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 创建并且加入到works成功 workers.add(w); // 更新largestPoolSize变量 int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // 启动worker线程 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; // worker启动失败，说明线程状态发生了变化（关闭操作被执行），需要执行shutdown相关操作 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; worker任务单元worker是一个任务单元，他里面包含了一个线程，和一个任务，然后还记录了我这个worker干过多少个任务等等。 123456789101112131415161718192021222324252627282930313233343536private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; // 这里使用了我们之前定义的线程工厂，传入的参数我当前的worker this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; // run方法的实现在runWorker里面 runWorker(this); &#125; //省略代码……&#125; runworker核心线程执行逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; // for GC // 允许外部中断 w.unlock(); // allow interrupts // 用于判读是否进入过自旋 boolean completedAbruptly = true; try &#123; // 自旋 // 如果task不为空，则开始执行task // 如果不为空，则从队列中获取task开始执行 // 阻塞队列的特性：就是当队列为空的时候，当前线程会被阻塞 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt // 如果线程池正在停止，则对当前线程中断 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // beforeExecute和afterExecute 是为扩展功能用的，在当前类实现默认为空 beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; // for GC w.completedTasks++; // 已完成任务数加一 w.unlock(); &#125; &#125; completedAbruptly = false; //表示已经自旋完成 &#125; finally &#123; // 自旋操作被退出，说明线程池正在结束，要把wc--，并且从workers删除当前worker processWorkerExit(w, completedAbruptly); &#125;&#125; 这里相当于用到了一种装饰者模式，将一个task包装成一个带有锁特性的执行者。这个执行者不仅可以消费当前的任务，getTask 还能从阻塞队列中获取任务消费，当队列为空的时候，线程会被阻塞住。当有任务过来的时候，又可以执行了。当任务执行完之后，processWorkerExit 方法是线程worker的出口。他会处理wc和workers集合，并且尝试将当前线程中断。 参考： Deep understanding of thread pool ThreadPool Executor Do you know the underlying implementation of thread pools?Thread Pool Module Summary 能说说什么是线程吗？线程模块总结]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AQS与ReentrantLock]]></title>
    <url>%2F2020%2F03%2F16%2Fconcurrentart%2Faqs%2F</url>
    <content type="text"><![CDATA[定义AQS是并发体系中一个非常重要的类，ReentrantLock就是基于AQS实现的，AQS底层使用了LockSupport类实现对线程的等待通知机制，相比于wait和notify方法，使用的更加的灵活，所以，要学习并发线程的底层知识，这个类你必须要学明白。 初始化默认初始化，为非公平锁，为什么？ 1234567891011121314151617/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125;/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; Sync类他们都是继承Sync抽象类，Sync继承了AQSAbstractQuenedSynchronizer 抽象类，AQS是并发里面十分重要的一个类，jdk1.7中ConcurrentHashMap曾使用过ReentranLock用于分段锁，在线程池中Worker(任务单元)也是用到了AQS。因此，要学习并发，必须把这个类学明白。 类图 AQS类123456789101112131415public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; private transient volatile Node head; private transient volatile Node tail; private volatile int state; static final class Node &#123; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; &#125;&#125; 在AQS内部维护了state字段，表示当前资源是否已经有线程对他进行了加锁，每一次加锁，该值都会加一，每次解锁，该值都会减一。 源码lock在lock方法，我们看到它调用了sync.lock()，sync.lock调用了acquire(1). 1234567891011public void lock() &#123; sync.lock();&#125;static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125;&#125; 再跟进到acquire(1)里，可以看到AQS的一个模板方法 12345678public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123; selfInterrupt(); &#125; &#125;&#125; 这里可以知道acquire干了三件事情 tryAcquire：当前线程尝试获得锁（state），如果获得锁成功，则结束。如果获取失败，进入步骤2 addWaiter：添加一个等待者，将当前线程以排他形式扔到队列里面 acquireQueued：以排队的方式将阻塞的线程一个一个唤醒 tryAcquireFairSync对tryAcquire的实现 12345678910111213141516171819202122232425262728293031static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 首先是先拿到当前线程，获取当前state值，看一下是否等于0，等于0表示我当前可以对他进行加锁，但是公平锁我需要去检查一下队列，看当前队列是否有别的线程已经在排队了，如果有的话，就返回空，如果没有（即为空或者当前线程是队头），就返回false，hasQueuedPredecessors实现如下： 123456789101112131415/* @return &#123;@code true&#125; if there is a queued thread preceding the * current thread, and &#123;@code false&#125; if the current thread * is at the head of the queue or the queue is empty * @since 1.7 */public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 没有其他线程的话，就给自己上锁，使用CAS(compareAndSetState)将state从0设置为1，如果这中间state被别的线程改了，则加锁失败，返回false。 如果state!=0的话，会检查当前线程是否是拥有锁的线程，如果是，将state+1，表示重入。 addWaiter当tryAcquire拿到锁以后就结束了，表示加锁成功。如果拿不到锁，那么就将调用addWaiter方法，将当前线程添加到队列的尾端，相当于排队等待被唤醒嘛，来看看它是如何实现的。 1234567891011121314151617181920212223242526272829303132/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; return node;&#125; addWaiter方法有一个参数，指定了传Node.EXCLUSIVE 排他锁或者是Node.SHARED 共享锁，addWaiter做了两件事情： 一上来就使用一次CAS将要添加的线程加入到队列尾部，这是在队列不为空的情况下操作的，所以得先判断一下。 如果失败的话，那说明有竞争，已经有线程也在往队列里面排，那么我就不断的试，直到将线程续接在队列的尾部。 acquireQueued当线程插入到队列中后，那么队列里的线程会排队的去获得锁，那么是如何实现的呢？（这些线程是不是全阻塞了啊） 1234567891011121314151617181920212223242526272829/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return &#123;@code true&#125; if interrupted while waiting */final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 首先它看一看前置节点是不是头节点，如果不是，那就阻塞parkAndCheckInterrupt。如果是，那就尝试获取锁，这里会和头节点产生竞争，如果竞争到锁，表示头节点已经释放了（因为头节点总是先获得锁，等释放后才会唤醒队列里的线程），然后将当前节点置为头节点。如果没有竞争到锁，说明头节点还没有释放，然后检查一下，停止尝试释放锁cancelAcquire unlock那么，程序是如何释放锁并且释放完后，是如何通知到的后置节点的呢，有必要去看一下unlock方法了 unlock方法调用了sync.release(1)方法，AQS对该方法实现如下 12345678910111213141516171819/** * Releases in exclusive mode. Implemented by unblocking one or * more threads if &#123;@link #tryRelease&#125; returns true. * This method can be used to implement method &#123;@link Lock#unlock&#125;. * * @param arg the release argument. This value is conveyed to * &#123;@link #tryRelease&#125; but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from &#123;@link #tryRelease&#125; */public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 这里干了两件事情： tryRelease：释放锁 unparkSuccessor：唤醒头节点 tryRelease释放锁很简单，将state-1，如果是0的话，需要将锁的当前拥有者置为空。 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; unparkSuccessor这里唤醒的话，不是唤醒队列里的所有线程，而是唤醒队列的头节点，因此在唤醒之前需要判断一下队列是否为空。 12345678910111213141516171819202122232425262728293031/** * Wakes up node's successor, if one exists. * * @param node the node */private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 可以看到AQS内部对每一个线程Node同时维护一个waitStatus字段，这是唤醒其他线程的核心。如果队列中线程被为空或者被cancelled，就会递归找到没有cancelled的那个节点。 公平锁与非公平锁那么，学到这里，我们来回答一下开头那个问题，为什么要默认为非公平锁？公平锁与非公平锁的区别？ 看过代码知道，公平锁是要排队的，当线程竞争时，多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 那么非公平锁是什么个概念呢？非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 对比一下代码，也是调用了sync.lock方法 123456789101112131415161718192021/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 这里，一来就去使用CAS尝试获取锁，如果刚好锁释放了，队列的头节点还没加锁，当前线程就有可能拥有这把锁。否则的话，调用 acquire(1)方法 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire模版方法是一样的，分三步：加锁、加锁不行放等待队列，看看排队是否到我获取锁了。 唯一的区别是tryAcquire的实现方式。这里不会去检查队列hasQueuedPredecessors，因为非公平锁，是无序的，如果state为0的话，就直接使用一次CAS竞争，谁先拿到锁，谁就先执行，否则就阻塞等待。 12345678910111213141516171819202122/** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 总结综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2020%2F03%2F14%2Falgorithm%2Fsortway-algorithm%2F</url>
    <content type="text"><![CDATA[今日复习任务：实现数据从小到大的排序方式，分别有冒泡、选择、插入、快排、归并 冒泡排序思想：大的数往往上冒，每遍历一次，后面的几位是排好顺序的。第一次遍历得到最大的数，在末尾，第二次遍历，次大的数在倒数第二位，需要遍历n-1次，所有的才能排好顺序。 12345678910111213 /** * @Description 选择排序 * TODO 时间复杂度 O(n^2) **/public static void maoPaoSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j+1); &#125; &#125; &#125;&#125; 优化 123456789101112131415161718/*** @Description 选择排序* TODO 性能优化 对于已经排好序的部分，直接退出外部循环，因为存在重复比较。**/public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; boolean isOrder = true; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); isOrder = false; &#125; &#125; if (isOrder) &#123; break; &#125; &#125;&#125; 由于有大量的重复比较，在每次比较的时候，用一个变量标识表示这轮遍历是否都已经排好顺序了，如果都排好顺序了，就直接跳出循环。可想而知，当排好序的情况下，是最好的情况，时间复杂度为O(n)。最坏情况是O(n^2),对于同样大小的数是不需要移动的，可以保证之前的顺序，所以是稳定的。 选择排序思想：有点类似冒泡，每次也是得到一个排好顺序的位置。选择一个数，逐个跟其他的比较大小。比如，取第一个，如果有比它小的数，则交换位置。 12345678910111213/** * @Description 选择排序 * TODO 最好,最坏，平均的情况 都是 n^2 【不稳定】 **/public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; swap(arr, i, j); &#125; &#125; &#125;&#125; 选择排序不管是有序无序都会进行选择比较，因此时间复杂度都是O(n^2)，为什么不是稳定的？ 因为每次比较都可能会交换问题，比如3，2，2，1，1，相邻的两个2在第一轮遍历的时候顺序就打乱了。 插入排序思想：把元素分为两部分，前部分是排好队的部分，后部分是还没有排好队的，当第一次遍历时，第一个元素是排好队的，第二个及之后的元素是需要插入到前面的，所以每次遍历的时候，拿第i+1个元素与前面的元素逐个比较，如果小于，交换元素。指针j继续往前移动，直到arr[i]大于arr[j]或者j&lt;=0 1234567891011/** * @Description 插入排序 * TODO 时间复杂度 O(n^2) 最坏O(n^2) 最好 O(n) 稳定 **/ public static void chaRuSort(int arr[]) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &gt; 0 &amp;&amp; arr[j - 1] &gt; arr[j]; j--) &#123; swap(arr, j - 1, j); &#125; &#125;&#125; 优化 123456789101112/** * @Description 插入排序 * TODO 最好的情况 n^2,最坏的情况，n^2,平均情况 n^2 【稳定】 **/public static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int key = arr[i]; for (int j = i - 1; j &gt;= 0 &amp;&amp; key &lt; arr[j]; j--) &#123; swap(arr, j + 1, j); &#125; &#125;&#125; 原理是一样的，更加容易理解一些，并且性能更好，因为每次比较的时候可以利用局部性缓存原理。 优化 1234567891011121314/** * @Description 插入排序 * TODO 对swap方法的优化，避免多次数据的赋值交换 **/public static void insertSort_improve(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int key = arr[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; key; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[j + 1] = key; &#125;&#125; 跟前一种思想一样，只是没有使用swap方法了，前面遍历，移动位置，最后找到key应该插入的位置，赋值就OK。 优化 12345678910111213141516/** * @Description 插入排序 * TODO 避免不必要的重复，最好情况下时间复杂度为 n(o) **/public static void insertSortImprove(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int key = arr[i]; for (int j = i - 1; j &gt;= 0; j--) &#123; if (key &lt; arr[j]) &#123; swap(arr, j + 1, j); &#125; else &#123; break; &#125; &#125; &#125;&#125; 避免不必要的重复比较，如果一开始比较比前面的数小，那直接跳出本次内部循环。 快速排序思想：选择一个哨兵，以这个为基准，对剩余的元素进行比较，小的排左边，大的排右边。当进行完一次遍历后，找到了当前哨兵所应该在的位置。然后对左右两部分递归，选择各自的哨兵，进行排序，当排完之后，就是有序的了。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @Description 快速排序 * TODO 使用分而治之的思想,平均时间复杂度为O(nlgn) 不稳定，交换有点类似选排 * 最坏的情况是选到的哨兵两个极端（最大值/最小值），导致O(n^2) **/public static void quick_sort(int[] arr) &#123; quick_Sort(arr, 0, arr.length - 1);&#125;private static void quick_Sort(int[] arr, int min, int max) &#123; if (max &gt; min) &#123; int partIndex = partition(arr, min, max); quick_Sort(arr, min, partIndex - 1); quick_Sort(arr, partIndex + 1, max); &#125;&#125;private static int partition(int[] arr, int min, int max) &#123; int key = arr[min]; while (max &gt; min) &#123; while (max &gt; min &amp;&amp; arr[max] &gt;= key) &#123; max--; &#125; // 将从右往左数比哨兵第一小的数赋值给左侧第一个数 arr[min] = arr[max]; while (max &gt; min &amp;&amp; arr[min] &lt;= key) &#123; min++; &#125; // 将从左往右数第一个比哨兵大的数，赋值给max处的下标，再比较min与max的大小 // 进入下一次循环，直到min=max arr[max] = arr[min]; &#125; arr[max] = key; return max;&#125; 程序有两处容易犯错的地方，第一处是quick_Sort()方法的递归调用，调用外部递归是因为，每次要使的左右两边有序。第二处是partition()方法有两处while循环，当内部循环之后，两处的交换赋值，需要注意。 快排的平均时间复杂度为O(nlogn)，对于排好序（升序或者倒序）的数组，表现的性能最差，因为每次遍历，选择到的哨兵是最大的或者最小的，导致每次遍历完，左侧的要么全是最大的或是最小的，导致没有二分的效果，时间复杂度接近于O(n^2)。 为了避免这种情况，重点在于选择哨兵的方法，我们可以选择数组的中间的那个数做哨兵，也能使用随机数选择，避免出现最快的情况。 三位数取中 12int index = (min + max) / 2;int key = arr[index]; 随机选择哨兵 123Random random = new Random(47);int index = random.nextInt(max - min) + min;int key = arr[index]; 归并排序思想：使用分而治之的方法，对一个大的任务分解成多个子任务，进行处理，将子任务处理完得到的解合并，就是所求问题的解。在归并排序中，将带排序的元素分成大小大致相同的两个子集合，分别对子集合进行排序（其实对子集合排序很简单，再对子集合进行分，分，分，直到分成单个元素，然后将单个元素进行从小到大合并，得到的就是有序的子集合），最终将排好序的子集合合并成所要排好序的集合。 其分而治之思想实现为： 123456789101112131415/** * @return void * @Author chenjianrong-lhq * @Description 平均时间复杂度 nlogn 稳定 * @Date 2020-04-05 18:26 * @Param [arr, left, right] **/public static void mergeSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int middle = (left + right) &gt;&gt; 1; mergeSort(arr, left, middle); // 分 mergeSort(arr, middle + 1, right); merge(arr, left, middle, right); // 治、合 &#125;&#125; 上面一步很容易理解，也有点类似快排。其重要的实现在于将单个元素进行从小到大合并，其中间的过程会产生多个有序的子集合，因为涉及到递归，必会开辟多个栈空间进行方法的运算和存储，所以相比于非递归，递归算法的运算效率较低，在计算时间上和占用空间上都差于非递归实现。当然，可以想一想如何消除递归，用非递归方法实现归并排序？ 将单个元素进行从小到大合并实现，可以简单的抽象为有两个排好序的长度为n/2数组，现在要按照从小到大组合成长度为n的数组，这组合的过程中要考虑多个不同的情况，共以下三 种： 左边的数全部比右边小 右边的数全部比左边的小 左边的数有比右边的小，也有比右边的大的（这个时候先取小的，再遍历比较） 具体 实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940private static void merge(int[] arr, int low, int middle, int high) &#123; // 定义组合后的数组 int[] temp = new int[arr.length]; // 组合数组的下标标识 int k = low; // 左部分的开始下标 int i = low; // 右部分的开始下标 int j = middle + 1; // 从左至右开始遍历 for (int m = low; m &lt; high; m++) &#123; if (m &gt; middle) &#123; // 表示左边元素已经处理 temp[k] = arr[j]; k++; j++; &#125; else if (j &gt; high) &#123; // 表示右边的元素已经处理 temp[k] = arr[i]; k++; i++; &#125; else if (arr[i] &gt; arr[j]) &#123; // 表示左边的数大于右边，取右边 temp[k] = arr[j]; k++; j++; &#125; else &#123; // 表示左边的数小于右边，取左边 temp[k] = arr[i]; k++; i++; &#125; &#125; // 数组的拷贝 for (int n = 0; n &lt; temp.length; n++) &#123; arr[n] = temp[n]; &#125;&#125; 总结以上几种排序是我们最熟悉的排序，也是面试时候经常会问到的排序，理解每种排序的思想远远比记住代码更重要。 最后我们总结归纳： 稳定的排序有三种：冒泡、插入、归并 在已经排好序的情况下 ，应该选择哪几种排序：优化的冒泡、插入]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[双向链表LinkedList]]></title>
    <url>%2F2020%2F03%2F13%2Fcollection%2Flinkedlist%2F</url>
    <content type="text"><![CDATA[定义LinkedList的本质是双向链表，与ArrayList相比，LinkedList的插入和删除速度更快，但是随机访问速度则很慢。LinkedList除了实现AbstractLIst抽象类外，还实现了另一个接口Deque，即double-ended queue，这个接口同时具有队列和栈的性质。 123456789101112131415public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; public LinkedList() &#123; &#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125;&#125; 由于链表是使用节点的方式，将内存单元通过附加引用的方式关联的，所以初始化的时候，是不需要指定容量的，也不存在扩容一说。 增添LinkedList默认在尾部增添节点，所以add方法效率有可能高于ArrayList，因为有可能扩容，涉及到数组的复制 add(ele)12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; add(index,ele)12345678public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 当插入下标等于尾节点时，插入尾部，否则，调用 linkBefore方法，插入下标处 123456789101112void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 这里用到了node方法，寻找下标的位置元素 123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 可以看到，node方法进行了一些优化，不是全部遍历的，而是根据靠近头节点还是尾节点进行遍历（相比于全部遍历速度提升了一倍） 删除remove(index)123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; //使节点失效，断掉链接 // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; remove(obj)123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; remove(obj)方法是和ArrayList一样的，从头开始遍历，没什么区别！ clear()12345678910111213141516public void clear() &#123; // Clearing all of the links between nodes is "unnecessary", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; 遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;]]></content>
      <categories>
        <category>collection</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ArrayList顺序表]]></title>
    <url>%2F2020%2F03%2F11%2Fcollection%2Farraylist%2F</url>
    <content type="text"><![CDATA[定义ArrayList的本质是顺序表，内部实现是使用数组存储的，集合扩容时会创建更大的数组空间，把原来的数据复制到新数组中。ArrayList支持对元素的快速随机访问，但是插入和删除时速度会很慢，因为这个过程可能要移动其他的元素。 默认大小1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; 初始化12345678910111213141516private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认初始化状态的校验public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //指定为空，当add时才会扩容&#125; public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; 当没有指定容量时，内部数组指定为空数组，当add的时候才会扩容。 一般明确集合数据量范围的话，我们必须初始化容量，不然遇到大数据量时，会进行多次的扩容，进行数组的复制，降低系统性能。那么，数组是如何扩容的呢？ 扩容12345678910111213141516171819202122232425262728293031323334353637// 当size++大于length的时候，对容器进行1.5倍扩容public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //增加初始化判断 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //当最多能放的数大于length，进行扩容 grow(minCapacity); &#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5陪扩容 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 当添加100个元素时，容器的扩容跟踪为： 10（new）——10(add first)——15（add 16）——22（add 23）——33（add 34）——49（add 50）...... 这里如果估量一下，如果有1000个元素，会进行多少次扩容呢？ Arrays.copyOf方法实现 123456789101112public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); //调用本地方法扩容 return copy; &#125; 最大容量123456789private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //去掉低三位private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //返回能够扩容的最大值 Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 增添123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; //默认加在最后面 ensureCapacityInternal(size + 1); elementData[size++] = e; return true; &#125;/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); //校验index是否越界 ensureCapacityInternal(size + 1); // Increments modCount和自动扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;/* * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. * @exception IndexOutOfBoundsException if copying would cause * access of data outside array bounds. * @exception ArrayStoreException if an element in the &lt;code&gt;src&lt;/code&gt; * array could not be stored into the &lt;code&gt;dest&lt;/code&gt; array * because of a type mismatch. * @exception NullPointerException if either &lt;code&gt;src&lt;/code&gt; or * &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); System.arraycopy本地方法参数说明 src：原数组 srcPos：原数组开始复制的下标 dest：目标数组 destPos：目标数组开始下标 length：要复制的元素个数 删除普通remove1234567891011121314151617181920212223/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; //按下标remove rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 快速remove123456789101112131415161718192021222324252627282930313233343536373839404142/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */private void fastRemove(int index) &#123; // 去掉校验和返回值 modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 遍历为什么遍历删除指定对象时，不能边遍历，边使用list.remove()和list.add()做删除和增加操作？ 验证1234567891011121314// output:Exception in thread "main" java.util.ConcurrentModificationExceptionprivate static void testArrayList() &#123; ArrayList arrayList = new ArrayList(); arrayList.add("123"); arrayList.add("345"); arrayList.add("1"); arrayList.add("23"); for (Object ele : arrayList) &#123; if ("123".equals(ele)) &#123; arrayList.remove(ele); //除非这里break;或者return； &#125; &#125; System.out.println(arrayList);&#125; 因为forEach遍历，编译后是使用内部迭代器Iterator的next方法遍历的，在List中维护了一个modCount字段，表示修改的次数，而Iterator内部也维护了一个字段expectedModCount，每次遍历的时候，会去比较这两个字段的值是否相等，就是checkForComodification()方法，如果不等，就会抛出ConcurrentModificationException异常 而使用fori遍历做删除，add的话，有可能会出现问题，如下例，为安全起见一般不建议这么用。 123456789101112131415161718192021//output:[Student&#123;name='male'&#125;, Student&#123;name='female'&#125;, Student&#123;name='female'&#125;]public static void main(String[] args) &#123; //准备数据 List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("male")); list.add(new Student("male")); list.add(new Student("female")); list.add(new Student("female")); list.add(new Student("male")); //普通for循环遍历删除 for (int i = 0; i &lt; list.size(); i++) &#123; Student student = list.get(i); if ("male".equals(student.getName())) &#123; list.remove(i); //使用集合的删除方法删除// i--; //删完之后i不减一，回到之前的值开始遍历 &#125; &#125; System.out.println(list.toString()); &#125; Iterator遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); //检查modcount try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) // fail-fast机制，多处会使用这个判断 throw new ConcurrentModificationException(); &#125;&#125; 实例12345Iterator iterator = branchList.iterator();while (iterator.hasNext()) &#123; Object ele = iterator.next(); System.out.println(ele);&#125; fail-fast在ArrayList设计了一个内部List类，为什么要设计这个类? 12345678910111213141516171819202122232425262728293031public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125;private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123;...&#125; public E get(int index) &#123;...&#125; public int size() &#123;...&#125; public void add(int index, E e) &#123;...&#125; public E remove(int index) &#123;...&#125; protected void removeRange(int fromIndex, int toIndex) &#123;...&#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;...&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; ...&#125; public Iterator&lt;E&gt; iterator() &#123;...&#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123;...&#125;&#125; 由于SubList提供了add()、remove()、addAll()方法的实现，均加了checkForComodification() 方法的校验，且对他们的操作会影响外部类，所以使用的时候特别注意。这样一种设计使用了适配器模式，当我们对子集合进行修改、插入、删除操作时，可以操控父集合的元素。但一定要注意，当我们对声明子集合后，再对父集合进行了修改，那么子集合的遍历与修改都会报fail-fast异常。 1234567891011121314151617181920212223private static void testFailfast() &#123; List&lt;String&gt; masterList = new ArrayList&lt;&gt;(); masterList.add("one"); masterList.add("two"); masterList.add("three"); masterList.add("four"); masterList.add("five"); List&lt;String&gt; branchList = masterList.subList(0, 2); //masterList.remove(0); // 打开后对branchList做遍历、修改、删除操作会报ConcurrentModificationException branchList.clear(); branchList.add("six"); branchList.add("seven"); System.out.println(masterList); branchList.remove(0); //output:[six, seven, three, four, five] System.out.println(branchList); //output:[seven] System.out.println(masterList); //output:[seven, three, four, five] &#125; 这个案例告诉我们 当取完子对象后，父对象与子对象有了联系，就不能随意的改变了，当父对象更改时，再对子对象操作，就会报fail-fast错误。 当建立联系后，子对象的更改会影响到父对象，彼此影响，所以使用的时候，一定不要同时对两个对象做修改操作。 asList &amp; toArray由于ArrayList底层是由数组实现的，那么，肯定是存在数组转集合和集合转数组的方法。我们常使用Arrays.asList(T [])将数组转换为List集合，注意使用该方法时，不能对子集合进行add、remove、clear等操作，因为，返回的ArrayList是一个内部类，没有提供以上方法的实现。 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 日过使用了，就会报fail-fast错误。如果一定要使用修改的话，一般我们是这么声明的。 12String[] strs = new String[2];ArrayList list=new ArrayList(Arrays.asList(strs)); ArrayList集合本身提供了一个集合转数组的方法，就是toArray方法。当我们使用这个方法的时候，一定要注意一些小坑。我们先来看一个例子，猜测一下会打印什么？ 12345678910111213141516171819private static void testArrayList() &#123; ArrayList arrayList = new ArrayList(); arrayList.add("male"); arrayList.add("male"); arrayList.add("female"); arrayList.add("female");// String[] objs = (String[]) arrayList.toArray(); Object[] objs = arrayList.toArray(); String[] strs = new String[2]; String[] strs1 = new String[5]; arrayList.toArray(objs); arrayList.toArray(strs); arrayList.toArray(strs1); System.out.println(Arrays.asList(objs)); System.out.println(Arrays.asList(strs)); System.out.println(Arrays.asList(strs1)); &#125; 最终的打印结果为： [male, male, female, female][null, null][male, male, female, female, null] 分析一下，第一条结果很明确，能完成复制，当时当我使用无参的方法时，该方法返回的是Object[]，不能转化为String[]，会报ClassCastException异常。第二条当数组声明的长度比集合小的时候，返回全是空。当大于的时候，能进行复制，其余的默认为null，这是什么导致的呢，我们来看看源码。 无参方法实现 123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 无参方法返回Object数组 有参方法实现 123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 当小于集合大小时，我们看到这里返回了一个复制好的数组，但是入参数组a被忽略了，所以a还是空，如果声明另一个数组要接受的话，是有值的。 我们看看Arrays.copyOf()方法是如何实现的 123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 可以看到，这里copy new了一个空的数组，长度为newLength,然后调用本地方法进行了复制，返回。 当我们集合转数组的时候，要注意，将数组的长度声明为list.size()，这性能往往高于大于时候的长度。]]></content>
      <categories>
        <category>collection</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[是时候揭开线程池这块面纱了（一）]]></title>
    <url>%2F2020%2F03%2F04%2Fconcurrentart%2Fthreadpool-usages%2F</url>
    <content type="text"><![CDATA[引言 今天在上班的路上，想到一个例子，就是一个病人感染上了新冠病毒要上医院去住院隔离治疗，方舱医院如果床位不够，就会导致医院响应不了病人的请求，只能拒绝。但是要能够响应又得临时搜集资源、组建材料搭建病房和床位，这必然会消耗大量的时间，也会耽搁了病人的病情。那么，要是实现了床足够多，达到床等人的话，就能够迅速的接待病人，进行隔离治疗，使病情得到及时的控制。 这个例子让我想到了线程池，假设对服务器的每一个请求都是一个任务调度，当大量的请求过来的时候，必然由于服务器空间资源限制，导致服务器响应缓慢，更可能导致系统崩溃。当大量的请求处理完之后，线程也就会销毁掉，当下次请求再来的时候，又得去创建线程，导致不必要的系统开销，同时降低了系统的响应速度。如果，我们能够在服务器预备一个专门响应的线程池，当请求来的时候我只要取一个线程去处理任务，处理完之后，我不销毁又放回到池子中，这样的话，我就能随到随取。我还想使这个池子有一定的可塑性，当大量的请求过来的时候，我想使更多的线程去响应，但当处理完之后，该销毁的销毁，不该销毁的还留在池子中，这样能同时响应的请求就更多了。当然，当服务器请求处理不过来，我也可能不想把这个请求给扔掉，我想我处理完后，再来处理之后的请求，只是可能需要你等一等！ 好吧，这就是我们今天要讲的线程池了。 好处 降低资源消耗。避免反复创建线程而不必要的资源开销。 提高响应速度。随来随用，当任务到来无需创建线程就能立即响应。 提高线程的可管理性。控制系统的最大并发数，避免线程创建过多导致系统运行缓慢甚至崩溃的情况发生，同时可以对线程池统一分配、调优和监控。 思考 线程池如何定义？线程池的种类？缓冲队列有哪几种？饱和策略有哪些？这几种线程池该如何使用？ 当线程池刚刚创立还没有Task到来的时候，线程池中的线程处于什么状态？ 当Task到来的时候，线程池中的线程是如何得到通知的？ 当线程池中的线程完成工作，如何回到池子里？ Task是什么东西？ 基本概念线程池接口线程池中定义了几个重要的接口，分别是Executor、ExecuterService。 Executor叫做执行者，有execute(Runnable command)方法。 1234567891011121314public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; 而ExecuterService继承了Executer，定义了线程池对线程的生命周期管理方法，重要的是它还提供了一套submit提交任务的机制。submit表示将任务提交给线程池，至于什么时候执行我就不管了，所以任务执行是异步的。 123456789101112public interface ExecutorService extends Executor &#123; void shutdown(); //结束 List&lt;Runnable&gt; shutdownNow(); //马上结束 boolean isShutdown(); //是否结束了 boolean isTerminated(); //是不是任务都执行完了 boolean awaitTermination(long timeout, TimeUnit unit); //等待结束，时间到了还不结束的话，就给返回false &lt;!--submit 相关方法--&gt; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task);&#125; 我们知道Runnable没有返回值，但是当我需要返回值的话，那就应该使用Callable接口。 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 当任务异步执行完后 ，我该如何通知给调用方呢，这就牵扯出一套Future、RunnableFuture和FutureTask相关概念了。 submit方法返回的是一个Future接口，可理解为未来执行完的一个结果，这个接口里面定义了get方法，主线程可以通过调用get()方法拿到任务的执行结果。所以Callable一般是配合线程池和Future来用的。 但是，更加灵活的一种方式，我们可以把Callable和Future进行封装到一个类里面，这个类就是FutureTask,代表的是我即是一个Task也能是一个用来存这个任务的结果的对象，因此，我就得有任务可执行的属性。因为FutureTask实现了RunableFuture,而RunnableFuture即实现了Runnable又实现了Future。 类图如下： 123456789101112131415161718public class T05_Callable &#123; static class MyCall implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("Hello MyCall"); TimeUnit.SECONDS.sleep(3); return "Success"; &#125; &#125; public static void main(String[] args) throws Exception&#123; // 实现callable接口 FutureTask futureTask = new FutureTask&lt;String&gt;(new MyCall()); Thread thread = new Thread(futureTask); thread.start(); System.out.println(futureTask.get()); &#125;&#125; 注意：主线程调用get方法，任务没有执行完时会被阻塞，直到任务执行完或者抛异常结束。当然，可以指定最大阻塞时间V get(long timeout, TimeUnit unit)，当时间到了就不继续等待了，但是会抛出TimeoutException异常。 线程池定义目前jdk定义的线程池有两种类型，第一种是是普通的线程池ThreadPoolExecutor，第二种是ForkJoinPool，这篇文章我们先分析一下ThreadPoolExecutor相关的线程池。 ThreadPoolExecutor的父类是AbstractExecutorService，而AbstractExecutorService是个抽象类，主要实现了ExecutorService的submit方法，上面知道，ExecutorService也继承了Executor。所以，ThreadPoolExecutor相当于线程池的执行器，可以往这个池子里面扔要执行的任务。 类图如下： 那么，ThreadPoolExecutor是如何定义的呢，它的核心参数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize：核心线程数 maximumPoolSize：最大线程数 keepAliveTime：线程的空闲时间，超出这个时间，非核心线程就会销毁。 unit：空闲时间单位 workQueue：任务队列 threadFactory: 线程工厂 handler：拒绝策略。目前jdk提供四种拒绝策略，一般默认的是抛出异常Abort这种，一般我们需要自己定义策略，根据不同的业务需求进行不同的操作，比如打印错误日志、将任务保存到kafka或者MQ、也可以将数据保存到redis或者数据库。四种拒绝策略分别是 Abort：抛异常 Discard：扔掉，不抛异常 DiscardOldest：扔掉排队时间最久的 CallerRuns：调用者处理服务 注意：线程池在阿里的开发规范上建议不使用jdk自定义的四种ThreadPoolExecutor，建议自己根据不同的业务场景自定义线程池。比如我们可以实现ThreadFactory接口，自定义newThread方法，方便线程的管理以及问题的回溯。 线程池的种类在jdk中提供了一些默认的线程池实现，主要有四种。它们的生成方式是封装在一个专门的线程池工具类中，叫做Executors，它可以看作线程池的工厂。 SingleThreadPool单线程线程池，只有一个线程工作，保证扔进去的任务是顺序执行的。为什么会有单线程线程池呢？第一是有任务队列，保证任务按顺序执行。第二是可通过线程池管理线程的生命周期。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; CachedThreadPool可缓冲线程池，cachepool核心数是0，最大是Integer.MAX_VALUE，队列使用的是SynchronousQueue（这是一个阻塞调用者的队列），keepAliveTime=60s，工作原理为当来第一个任务时，会new Thread，之后的任务会校验是否有线程没在忙，没有的话就来他处理，否则再new 一个，处理完之后60s销毁。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; FixedThreadPool固定线程池，fixedpool核心数和最大线程数是相等的，通过传参传入，队列使用的是无界队列，keepAliveTime=0s。工作原理为我就指定了最多工作的线程数为这么多。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 那么，CachedThreadPool和FixedThreadPool应该怎样使用呢？根据当前业务场景评估任务量以及平稳度，如果是忽高忽低，在保证任务进来之后会马上处理，不会堆积的情况下，可使用CachedThreadPool。如果评估任务来的是平稳的，数量也有一定的范围，可使用FixedThreadPool。 ScheduledThreadPool定时任务线程池，核心数自己定义，最大数为Integer.MAX_VALUE，队列为DelayedWorkQueue。他提供了定时任务的实现机制. 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; 可通过调用scheduleAtFixedRate方法间隔多长时间在一固定的频率上执行一次这个任务。该方法有四个参数，第一个是任务，initialDelay表示开始执行是延迟的时间，period表示间隔时间，unit表示间隔时间的单位。 1234public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); 总结至此，线程池的基本概念就就讲完了，稍微总结一下： Callable类似于Runnable，但是有返回值，并且call方法还有可能抛异常 Future是用来储存任务执行完的结果的 FutureTask的本质是Future加上Runnable，即可以执行又能存结果，可以使用CompletableFuture管理多个线程的结果。 SingleThreadPool`只有一个线程的线程池 CachedThreadPool有弹性的线程池，只要没闲着的，就来一个启动一个 FixedThreadPool固定了线程池的线程数 ScheduledThreadPool线程池主要为了执行定时任务的 在我们实际开发中，一般都是自定义线程池，但是如果不了解原理的话，很容易滥用，导致一些系统运行缓慢甚至崩溃的问题。为此，分析源码的文章就留着下篇了。]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CAS实现与原子类actomic]]></title>
    <url>%2F2020%2F03%2F03%2Fconcurrentart%2Fcas-implement%2F</url>
    <content type="text"><![CDATA[悲观锁与乐观锁悲观锁定义：对于同一数据的并发操作，悲观锁认为当我在使用数据的时候一定有其他线程也会来访问和修改数据，因此在获取数据的时候会加锁，确保数据不会被别的线程修改。 应用：Java中，synchronized关键字和Lock的实现类都是悲观锁。 乐观锁定义：乐观锁认为在对访问数据进行时，没有别的线程来修改数据，所以不需要加锁。但是为了确保只有自己在对数据进行了操作，自己在更新数据的时候会去判断以前有没有别的线程对数据进行了修改。如果数据没有更新，当前线程会将自己修改的数据成功写入；如果数据被更新了，则根据不同的实现方式执行不同的操作（例如报错和循环重试） 应用：java的原子类的自增操作就是通过CAS自旋算法实现的。 应用场景 悲观锁适合写操作多的场景，先加锁可以保证数据正确性。 乐观锁适合读操作多的场景，不加锁特性可以提高读操作的性能。 CAS定义：CAS全程是Compare And Swap (cmpxchg指令)，它是一种无锁的算法，在不使用锁（没有线程阻塞）的情况下实现多线程间的变量同步。由于它实现的特性，也叫做自旋锁、乐观锁。 源码分析1count.incrementAndGet(); // 替代count++ AtomicInteger.incrementAndGet方法调用了unsafe.getAndAddInt方法 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; 看一下AtomicInteger的定义 123456789101112public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; 根据定义我们可以看出各属性的作用： unsafe： 获取并操作内存的数据。 valueOffset： 存储value在AtomicInteger中的偏移量。 value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。 接下来查看Unsafe.getAndAddInt方法的实现 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; 分析源码可以看到： getIntVolatile方法获取给定对象o中的偏移量处的值var5 然后调用compareAndSwapInt方法，比较+更新 是个原子操作，这是通过CPU的 cmpxchg指令去实现的 compareAndSwapInt就是cas操作，可看作cas(V，Excepted，NewValue)，V就是要修改的值，Excepted是当前的期望值，NewValue是要修改的值。 当V==Excepted时，将V更新为NewValue，否则，返回flase，继续while循环再次调用cmpxchg指令进行重试，直到成功为止。 CAS带来的问题ABA问题描述：因为CAS需要在操作值时候，检查值有没有发生变化，如果没有发生变化，但是如果一个值原来是A，变成了原来的B，又变成了A，但是用CAS检查出来它没有变化，但是实际上是变化了的。 影响：如果是基础类型，不产生影响。如果是引用类型，可能会产生一些影响，这个影响对业务来说可能不可忽略。 解决思路：在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A” JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 AtomicStampedReference.compareAndSet方法的实现 123456789101112public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); &#125; 循环时间长开销大描述：CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作描述：对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 AtomicReference类的定义，使用了泛型 123456789101112public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -1848883965231344442L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile V value; public AtomicReference(V initialValue) &#123; value = initialValue;&#125; //传递对象 How CAS (Compare And Swap) in Java works]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[synchronized底层实现原理]]></title>
    <url>%2F2020%2F02%2F28%2Fconcurrentart%2Fsynchronized-implement-prinpiple%2F</url>
    <content type="text"><![CDATA[synchronized定义 Multi-threaded programs may often come to a situation where multiple threads try to access the same resources and finally produce erroneous and unforeseen results.So it needs to be made sure by some synchronization method that only one thread can access the resource at a given point of time. 应用方式 对于普通同步方法，锁是当前实例对象 对于静态同步方法，锁是当前类的class对象 对于同步方法块，锁是synchronized括号里配置的对象 原理 JVM基于进入和退出Monitor对象来实现方法、代码块同步的，两者实现的细节不一样，但都是使用monitorenter和monitorexit指令来实现的。monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法的结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。 任何对象都有一个Monitor与之 关联，当且一个Monitor被持有后，它将处于锁定状态。 线程执行到monitorenter指令时，将会尝试获取对象的锁。 而对于没有获取到对象锁的线程会阻塞在方法的入口，知道获取锁的线程执行 monitorexit之后才能尝试继续获取锁。 流程如下： 验证源码 123Object o = new Object();synchronized (o) &#123;&#125; 使用jclasslib查看汇编指令 对象在内存中的存储 由三部分组成：markword（8个字节）、class pointer（4个字节）、instance data 内存对齐，每个对象在内存中占的字节数必须是8的倍数，即%8=0，如果不满足，则会补齐至8的倍数。 对象头 在64位虚拟机下，markword是64位 用markword中最低的三位代表锁状态，其中1位是偏向锁位：无锁—0 01、偏向锁—1 01 后面两位是普通锁位：轻量级锁—00、重量级锁—01 参考：synchronized 关键字原理 锁升级描述JDK较早的版本，都是使用synchronized,很多人称为重量锁， 重量锁 效率比较低，因为它要向操作系统申请资源。jdk1.6对synchronized进行了优化，为了减少获取和释放锁带来的消耗，引入了轻量级锁和偏向锁 的概念。锁一共有4种状态，级别从低到高分别是无锁 - 偏向锁 - 轻量级锁（自旋锁）-重量级锁 无锁Object o = new Object() 锁的状态为：0 01 无锁态 100000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 执行o.hashCode()后，对象头变为hashcode+0 01 100000000 00000000 00000000 00000111 10000000 11001011 01110111 00000001 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 关闭偏向锁 -XX:+UseBiasedLocking -client -Xmx512m -Xms512m 问题：新实例化对象o是无锁，当对象使用sync(o)之后，为什么对象是轻量级锁状态而不是偏向锁状态呢？ 因为偏向锁的启动有4s的时延，为什么要有时延呢？JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。 可使用以下命令关闭时延 -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -client -Xmx1024m -Xms1024m 偏向锁偏向锁，偏向加锁的第一个线程。 适用于锁不存在多线程竞争，并且应由一个线程多次获得锁。markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个。 获得锁当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，以后该线程进入或者退出同步块时不需要进行 CAS 操作来加锁和释放锁。只需检查一下锁对象的 Mark Word 中是否存储了当前线程的ID，如果是，表示当前已经获得偏向锁，否则再去检查一下 Mark Word 中偏向锁位是否是1，如果不是，使用 CAS竞争锁，如果是，使用 CAS 将对象头的偏向锁指向当前线程。 释放锁当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，偏向锁的撤销需要等到全局安全点（在这个时间点上没有正在执行的字节码），接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁，来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。 偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。这时应该关闭偏向锁，使程序直接进入轻量锁状态。 轻量级锁锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁。 加锁线程在进入同步块之前，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。 如果更新成功，当前线程就获得了锁。 如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。 如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。 不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。 解锁轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁) 轻量锁能提升性能的原因： 认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。 重量级锁自旋超过10次，升级为重量级锁（如果太多线程自旋 CPU消耗过大，不如升级为重量级锁）。当升级为重量级锁时，其他线程试图获取锁时，会阻塞进入等待队列（不消耗CPU），直到持有锁的线程释放锁后会唤醒这些线程，被唤醒的线程会再次一起竞争锁。 其他优化适应性自旋在使用 CAS 时，如果操作失败，CAS 会自旋再次尝试。由于自旋是需要消耗 CPU 资源的，所以如果长期自旋就白白浪费了 CPU。JDK1.6加入了适应性自旋: 如果某个锁自旋很少成功获得，那么下一次就会减少自旋。 总结综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 参考：美团 不可不说的Java“锁”事]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volatile底层实现原理]]></title>
    <url>%2F2020%2F02%2F27%2Fconcurrentart%2Fvolatile-implement-prinpiple%2F</url>
    <content type="text"><![CDATA[volatile定义 Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获取这个变量。 线程的可见性123456789101112131415161718192021222324public class VolatileApplication &#123; // 当使用volatile时，主线程修改完内存中的flag后，对等线程会从内存中读取到flag被修改后的值，正常结束！ private static /*volatile*/ boolean flag = true; public static void main(String[] args) throws InterruptedException &#123; new Thread() &#123; @Override public void run() &#123; while (flag) &#123; &#125; System.out.println("对等线程执行完毕"); &#125; &#125;.start(); Thread.sleep(1000); flag = false; System.out.println("主线程执行完毕"); &#125;&#125; 原理java源码： 1instance = new Singleton(); //instance是volatile变量 汇编： 10x01a3deld:movb $0✖️0,0✖️1104800(%esi);oxo1a3de24:lock addl $0✖️0,(%esp); lock指令干了两件事情： 将当前处理器缓存行的数据写会到系统内存 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效 缓存一致性 由于CPU的运行速度远远大于向内存读取的速度，所以为了提高效率，加入了高速缓存机制，即处理器不会直接和内存进行通信，而是先将物理内存的数据读到内部缓存（L1，L2，L3或其他），再进行操作 。保存的一致性就是保证多个缓存中共享数据的一致性，目前主要是通过MESI协议来保证的。 MESI 协议 Modified、Exclusive、 Share or Invalid状态而命名的，用来标识每个缓存行的状态（由两个状态位表示），每个缓存行（缓存的数据基本单位）都处于M、E、S和I这四种状态之一。 伪共享 当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class T02_CacheLinePadding &#123; // 不对齐的结果耗时：227ms，对齐的结果耗时：79ms private static class Padding &#123; /*volatile*/ long p0, p1, p2, p3, p4, p5, p6; &#125; private static class T extends Padding &#123; volatile long x = 0L; &#125; public static T[] arr = new T[2]; static &#123; arr[0] = new T(); arr[1] = new T(); &#125; public static void main(String[] args) &#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000000L; i++) &#123; arr[0].x = i; &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000000L; i++) &#123; arr[1].x = i; &#125; &#125; &#125;); long startTime = System.currentTimeMillis(); thread1.start(); thread2.start(); try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("总耗时：" + (System.currentTimeMillis() - startTime) + "ms"); &#125;&#125; 避免伪共享 缓存行隔离 利用缓存行在现代计算机中占8字64字节的特性，为避免多线程缓存一致性带来的性能影响，引入了缓存行对齐，在定义对象时，如果对象在内存中不占64字节，就补齐64字节，保证对象中的数据缓存在不同的缓存行中。 缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高 参考：杂谈 什么是伪共享（false sharing） Concurrency with LMAX Disruptor – An Introduction 指令重排序定义 CPU内部的一个优化，当CPU同时先后执行两条指令，一条是从内存中读指令，一条是执行操作数据指令，CPU由于读指令更耗时，会对指令进行重新排序，先执行操作数据的指令，再执行读指令，当然是这两条指令的变量必须是没有关联，不会互相影响的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class T04_Disorder &#123; private static int x = 0, y = 0; private static int a = 0, b = 0; public static void main(String[] args) throws InterruptedException &#123; int i = 0; for (; ; ) &#123; i++; x = 0; y = 0; a = 0; b = 0; Thread one = new Thread(new Runnable() &#123; @Override public void run() &#123; shortWait(100L); a = 1; x = b; &#125; &#125;); Thread two = new Thread(new Runnable() &#123; @Override public void run() &#123; b = 1; y = a; &#125; &#125;); one.start(); two.start(); one.join(); two.join(); String result = "第" + i + "次 (" + x + "," + y + "）"; if (x == 0 &amp;&amp; y == 0) &#123; System.err.println(result); break; &#125; else &#123;// System.out.println(result); &#125; &#125; &#125; private static void shortWait(long interval) &#123; long startTime = System.currentTimeMillis(); long endTime; do &#123; endTime = System.currentTimeMillis(); &#125; while (endTime - startTime &lt;= interval); &#125;&#125; 问题 对象的半初始化 1234567public class T &#123; int m = 8; public static void main(String[] args) &#123; T t = new T(); &#125;&#125; DCL单例到底需不需要加volatile修饰符 这里的 volatile 关键字主要是为了防止指令重排。原理如下： singleton = new Singleton();这段代码其实是分为三步： 分配内存空间，t.m=0 初始化对象，执行构造函数，t.m=8 将 singleton 对象指向分配的内存地址 加上 volatile 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于报错。 JSR内存屏障 两条指令间如果加了内存屏障，CPU运行的时候就不能对指令进行重排序。 volitile如何解决指令重排序 volatile i ACC_VOLATILE JVM的内存屏障 hotspot实现 查看虚拟机中的C++源码文件如下： bytecodeinterpreter.cpp 12345int field_offset = cache-&gt;f2_as_index(); if (cache-&gt;is_volatile()) &#123; if (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123; OrderAccess::fence(); &#125; orderaccess_linux_x86.inline.hpp 12345678910inline void OrderAccess::fence() &#123; if (os::is_MP()) &#123; // always use locked addl since mfence is sometimes expensive#ifdef AMD64 __asm__ volatile ("lock; addl $0,0(%%rsp)" : : : "cc", "memory");#else __asm__ volatile ("lock; addl $0,0(%%esp)" : : : "cc", "memory");#endif &#125;&#125; 参考：你应该知道的 volatile 关键字]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发编程的挑战]]></title>
    <url>%2F2020%2F02%2F26%2Fconcurrentart%2Fchallenge-concurrency-progrramming%2F</url>
    <content type="text"><![CDATA[上下文切换减少上下文切换的方法 无锁并发编程 CAS算法 使用最少线程 协程(在一个线程中实现多任务调度) 监控程序查看进程中的线程 jstack 30587 &gt; /app/sssc-soa-starindex/dump1 分析线程信息文件 grep java.lang.Thread.State dump1 | awk ‘{print $2$3$4$5}’ | sort | uniq -c 查看线程状态，是否堵塞或进行多次的上下文切换重新配置线程池信息，重启服务，查看线程运行效果，是否进行了多次线程切换死锁导致死锁的原因 第一个线程等待第二个线程释放资源，而第二线程在等待第一个线程释放资源。 产生死锁的条件 互斥等待（同步的原理） Hold and Wait 循环等待 无法剥夺的等待 避免死锁的方法 一次性获取from和 to锁，无法实现 按顺序获取锁 加入超时，如果超时，就释放锁（不推荐） 资源限制的挑战什么是资源限制 在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。比如硬件资源限制有宽带的上传/下载速度、硬件读写速度和CPU的处理速度。软件资源限制有数据库的连接数和socket连接数等。 资源限制引发的问题 并发程序在资源限制的情况下，运行起来比串行还慢。 解决资源限制引发的问题 使用集群，多机部署 软件资源：线程池、连接池复用]]></content>
      <categories>
        <category>并发编程的艺术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程基本概念]]></title>
    <url>%2F2020%2F02%2F25%2Fconcurrentart%2Fthread-base-knowledges%2F</url>
    <content type="text"><![CDATA[进程与线程 进程 一个程序就是一个进程，经典定义是：一个执行中程序的实例。 线程 线程是进程执行的最小执行单元，一个进程可以包含多个线程。 什么是线程12345678910111213141516171819202122232425262728293031323334public class T01_whatisThread &#123; // 直接执行run方法,程序顺序执行，执行start方法，主线程与对等线程同时执行，交叉打印！ public static void main(String[] args) &#123;// new T1().run(); new T1().start(); for (int i = 0; i &lt; 10; i++) &#123; try &#123; TimeUnit.MICROSECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Main"); &#125; &#125; private static class T1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; TimeUnit.MICROSECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("T1"); &#125; &#125; &#125;&#125; 线程的创建方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class T02_HowToCreateThread &#123; public static void main(String[] args) &#123; // 1.继承Thread方式 new MyThread().start(); // 2.实现Runnable接口 new Thread(new MyRun()).start(); // 3.使用匿名类 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello,My Anonymous"); &#125; &#125;).start(); // 3.使用Lambda表达式// new Thread(()-&gt;&#123;// System.out.println("Hello Lambda!");// &#125;).start(); // 4.实现callable接口 Thread thread = new Thread(new FutureTask&lt;String&gt;(new MyCall())); thread.start(); // 5.使用线程池 ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello ThreadPool!"); &#125; &#125;); executorService.shutdown(); &#125; private static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println("Hello MyThread!"); &#125; &#125; private static class MyRun implements Runnable &#123; @Override public void run() &#123; System.out.println("Hello MyRun!"); &#125; &#125; static class MyCall implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("Hello MyCall"); return "Success"; &#125; &#125;&#125; 线程的常见方法 sleep causes the thread to definitely stop executing for a given amount of time; if no other thread or process needs to be run, the CPU will be idle (and probably enter a power saving mode). yield basically means that the thread is not doing anything particularly important and if any other threads or processes need to be run, they should run. Otherwise, the current thread will continue to run. join The join() method of a Thread instance is used to join the start of a thread’s execution to end of other thread’s execution such that a thread does not start running until another thread ends. If join() is called on a Thread instance, the currently running thread will block until the Thread instance has finished executing. join(n):It will put the current thread on wait until the thread on which it is called is dead or wait for specified time (milliseconds). 参考：Java Concurrency – yield(), sleep() and join() methods 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class T03_YieldJoin &#123; private static class YieldThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " in Control"); &#125; &#125; &#125; private static class JoinThread extends Thread &#123; @Override public void run() &#123; Thread t = Thread.currentThread(); System.out.println("Current thread: " + t.getName()); // checks if current thread is alive System.out.println("Is Alive? " + t.isAlive()); &#125; &#125; public static void main(String[] args) &#123; // 把当前任务放入到等待队列中，让别的线程优先执行（但有可能还是拿到当前的任务执行，比如等待队列没有任务时）// testYield(); // 当前线程调用了别的线程，调用join()时让当前线程等待（堵塞），当调用线程执行完了，自己再执行。 testJoin(); &#125; private static void testJoin() &#123; Thread t = new Thread(new JoinThread()); t.start(); // Waits for 1000ms this thread to die.If thread is dead，execute next instruction try &#123; t.join(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("\nJoining after 1000"+ " mili seconds: \n"); System.out.println("Current thread: " + t.getName()); // Checks if this thread is alive System.out.println("Is alive? " + t.isAlive()); &#125; private static void testYield() &#123; Thread thread = new YieldThread(); thread.start(); for (int i = 0; i &lt; 5; i++) &#123; Thread.yield(); System.out.println(Thread.currentThread().getName() + " in Control"); &#125; &#125;&#125; 线程状态 新建状态——new Thread()，对象实例化后就是新建状态了。 Runnable状态 Ready就绪状态——thread.start()，任务被扔到CPU等待队列中，等待被运行。 Running状态——被CPU调度器选中，开始执行，当顺利执行完后，进入Teminated结束状态，如果执行了yield()，当前线程会进入Ready就绪状态，等CPU调度器选中时，又进入Running状态。 Teminated结束状态——顺利执行，任务进入Teminated结束状态后，不能重新start()。 Bolcked阻塞 ——在执行同步代码块时没有获取锁资源，等获取锁了进入就绪状态。 Waiting等待——在运行状态时调用o.wait()、t.join()、LockSupport.park()进入Waiting状态，调用o.notify()、o.notifyAll()、LockSupport.unpack()又回到Running状态。 TimedWaiting等待——在运行状态时调用o.wait(n)、t.join(n)、Thread.sleep(n)进入TimedWaiting状态，与Waiting相似，只是按照时间等待，如果时间到了，或者线程结束则继续执行。 参考：Lifecycle and States of a Thread in Java 123456789101112131415161718192021222324252627282930313233343536373839404142public class T04_ThredState &#123; private static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(this.getState()); for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t = new MyThread(); System.out.println(t.getState()); t.start(); // 就绪状态和运行状态统称为Runnable状态 System.out.println(t.getState()); try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(t.getState()); // 线程执行完之后，不能重新start，报IllegalThreadStateException异常，start方法中有状态校验，必须为新建状态，见源码！ // t.start(); &#125;&#125;]]></content>
      <categories>
        <category>thread</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：并发编程]]></title>
    <url>%2F2020%2F01%2F06%2Fcsapp%2Fconcurrent-programmings%2F</url>
    <content type="text"><![CDATA[并发编程简介 并发 如果逻辑控制流，在时间上重叠，那么它们就是并发的 应用级并发的作用 访问慢速I/O设备 与人交互 通过推迟工作以降低延迟 服务多个网络服务 在多核机器上进行并行计算 三种构造并发程序的方法 进程 With this approach, each logical control ﬂow is a process that is scheduled and maintained by the kernel. Since processes have separate virtual address spaces, ﬂows that want to communicate with each other must use some kind of explicit interprocess communication (IPC) mechanism. I/O多路复用 This is a form of concurrent programming where applications explicitly schedule their own logical ﬂows in the context of a single process. Logical ﬂows are modeled as state machines that the main program explicitly transitions from state to state as a result of data arriving on ﬁle descriptors. Since the program is a single process, all ﬂows share the same address space. 线程 Threads are logical ﬂows that run in the context of a single process and are scheduled by the kernel. You can think of threads as a hybrid of the other two approaches, scheduled by the kernel like process ﬂows and sharing the same virtual address space like I/O multiplexing ﬂows. 基于进程的并发编程 base knowldge 线程是最小执行的单位，进程是最小资源分配的单位 概念 使用fork()、exec()、waitpid()等函数，对进程进行控制 一个构造并发服务器的自然方法是，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个客户端提供服务 过程 第一步：服务器接受客户端的连接请求 第二步：服务器派生一个子进程为这个客户端服务 第三步：服务器接受另一个连接请求 优劣 进程有独立的地址空间，不会覆盖另一进程的虚拟存储器，避免许多令人迷惑的错误。 独立的地址空间使得进程共享状态信息变得更加的困难，为了共享信息，必须使用显示的IPC(进程间通信)机制。 另一个缺点是，速度较慢，因为进程控制和IPC的开销很高。 基于I/O多路复用的并发编程 描述 创建自己的逻辑流，并利用I/O多路复用来显示地调度流，因为只有一个进程，所有的流共享整个地址空间。 使用select函数，要求内核挂起进程，只有一个或多个I/O事件发生后，才将控制返回给应用程序。 基于线程的并发编程 线程 就是运行在进程上下文中的逻辑流 一个进程可以有多个线程 线程由内核调度 每个线程都有它自己的线程上下文，包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码 所有运行在一个进程里的线程共享该进程的整个虚拟地址空间 线程执行模型 主线程、对等线程、对等池(线程池) 一个线程的上下文比进程的上下文小得多，也比进程的上下文切换快得多 和一个进程相关的线程组成一个对等池，独立于其他线程创建的线程 主线程和其他线程的区别仅仅在于它总是进程中第一个运行的线程 一个线程可以杀死它的任何对等线程，或者等待它的任何对等线程终止 每个对等线程读写相同的共享数据 Posix线程 创建线程 终止线程 回收已终止的线程 分离线程 初始化线程 共享变量信号量并行性竞争与死锁]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：Web服务器]]></title>
    <url>%2F2019%2F12%2F08%2Fcsapp%2Fnetwork-programming-two%2F</url>
    <content type="text"><![CDATA[Web服务器 Web基础 HTTP协议——超文本传输协议（Hypertext Transfer Protocol） 定义 Web客户端和服务器之间的交互用的一个基于文本的应用级协议。 一个客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。 HTML语言——超文本标记语言（Hypertext Markuo Language） 定义 区别于常规的文件检索服务，一个HTML程序包含指令，它们告诉浏览器如何显示这页中的各种文本和图形对象。 Web内容 定义 内容是与一个MIME（Multipurpose Internet Mail Extension，多用途的网际邮件扩充协议）类型相关字节序列 常用的MIME类型 text/html text/plain application/json image/gif image/jpeg 两种方式提供内容 静态内容 取出一个磁盘文件，并将它的内容返回给客户端，磁盘文件为静态内容，过程叫做服务静态内容。 动态内容 运行一个可执行文件，并将它的输出返回给客户端，执行文件输出的是动态内容，过程称为服务动态内容。 URL——通用资源定位符（Univwesal Resource Locator） 例如 http://www.google.com:80/index.html http://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213 HTTP事务 静态内容的事务图 HTTP请求 组成：一个请求行（第5行）+零个或多个请求报头（第6行）+空的文本行（第7行标识终止报头） 请求行的格式：method URI version HTTP请求支持的方法：GET、POST、OPTIONS、HEAD、PUT、DELETE和TRACE URI：统一资源标识符（Uniform Resource Identifier）是相应URL的后缀，包括文件名和可选的参数 HTTP响应 组成：一个响应行（第8行）+零个或多个响应报头（第9～13行）+空行（第14行标识终止报头）+响应主体（第15～17行） HTTP状态码图 服务动态内容 客户端如何将程序参数给服务器？ GET请求通过URI中传递，用？分隔文件名和参数，用&amp;分隔参数 POSt请求的参数放在主体中 服务器如何将参数传递给子进程？ it calls fork to create a child process and calls execve to run the /cgi-bin/adder program in the context of the child. Programs like the adder program are often referred to as CGI programs because they obey the rules of the CGI standard. Before the call to execve, the child process sets the CGI environment variable QUERY_STRING to 15000&amp;213, which the adder program can reference at run time using the Linux getenv function. 服务器如何将其他信息传递给子进程？ CGI deﬁnes a number of other environment variables that a CGI program can expect to be set when it runs. Figure 11.26 shows a subset. 子进程将它的输出发送到哪里？ A CGI program sends its dynamic content to the standard output. Before the child process loads and runs the CGI program, it uses the Linux dup2 function to redirect standard output to the connected descriptor that is associated with the client. Thus, anything that the CGI program writes to standard output goes directly to the client. Notice that since the parent does not know the type or size of the content that the child generates, the child is responsible for generating the Content-type and Content-length response headers, as well as the empty line that terminates the headers. CGI程序示例 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author chenjianrong-lhq 2019年12月08日 21:22:16 * @Description: 网络编程客户端 * @ClassName: ClientApplication */public class ClientApplication &#123; public static String IP = &quot;www.baidu.com&quot;; public static Integer PORT = 80; public static void main(String[] args) &#123; String param = &quot;提供动态内容，需要派生一个子进程，并在子进程的上下文中运行一个CGI程序，来提供各种类型的动态内容。子进程通过请求URI获取的CGI参数初始化QUERY——STRING环境变量。然后子进程重定向它的标准输出到已连接文件描述符，然后加载并运行CGI程序。CGI运行的结果会直接显示在服务器端。&quot;; /**step1 定义 Socket 对象、OutputStream 对象和一个 InputStream 对象并完成初始化**/ Socket socket = null; OutputStream os = null; InputStream is = null; try &#123; socket = new Socket(IP, PORT); /**step2.建立与服务器端的连接并将数据发送到服务器端**/ socket.setSoTimeout(60 * 1000); os = socket.getOutputStream(); os.write(param.getBytes(&quot;utf-8&quot;)); Thread.sleep(1000);// ByteArrayOutputStream bos = new ByteArrayOutputStream(); /**step3.从输入流中读出服务器的反馈信息并输出到控制台**/ byte[] buffer = new byte[1024]; is = socket.getInputStream(); int count = 0;// do &#123;// count = is.read(buffer);// bos.write(buffer, 0, count);// &#125; while (is.available() != 0); count = is.read(buffer); System.out.println(&quot;服务端反馈的数据是：&quot; + new String(buffer, 0, count)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; /**step4 关闭流及 Socket 对象**/ try &#123; if (os != null) &#123; os.close(); &#125; if (is != null) &#123; is.close(); &#125; if (socket != null) &#123; socket.close(); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;&#125; 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author chenjianrong-lhq 2019年12月08日 21:56:09 * @Description: 网络编程服务端 * @ClassName: ServerApplication */public class ServerApplication &#123; public static String IP = &quot;www.baidu.com&quot;; public static Integer PORT = 80; public static void main(String[] args) &#123; /**step5 创建ServerSocket、Socket、OutputStream、InputStream以及端口号并初始化**/ ServerSocket serverSocket = null; Socket socket = null; OutputStream os = null; InputStream is = null; try &#123; /**step6 开启服务器并接收客户端发送的数据**/ serverSocket = new ServerSocket(PORT); System.out.println(&quot;服务器开启，等待连接...&quot;); socket = serverSocket.accept(); is = socket.getInputStream(); byte[] buffer = new byte[1024]; int len = is.read(buffer); System.out.println(&quot;客户端发送的内容为：&quot; + new String(buffer, 0, len)); /**step7 使用输出流对象将信息返回给客户端**/ os = socket.getOutputStream(); os.write(&quot;我是服务器端&quot;.getBytes()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; /**step8 关闭流对象、ServerSocket对象以及Socket对象**/ try &#123; os.close(); is.close(); serverSocket.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TINY Web服务器参考博客：网络编程]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：网络编程（一）]]></title>
    <url>%2F2019%2F12%2F01%2Fcsapp%2Fnetwork-programming%2F</url>
    <content type="text"><![CDATA[客户端——服务端编程模型 简介 定义 一个网络应用是由一个服务器进程和一个或者多个客户端进程组成，服务端管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。 举例 a Web server manages a set of disk ﬁles that it retrieves and executes on behalf of clients. An FTP server manages a set of disk ﬁles that it stores and retrieves for clients. An email server manages a spool ﬁle that it reads and updates for clients. 基本操作 客户端——服务器模型中基本操作是事务。 客户端——服务端事务 事务模型图 步骤 When a client needs service, it initiates a transaction by sending a request to the server. For example, when a Web browser needs a ﬁle, it sends a request to a Web server. The server receives the request, interprets it, and manipulates its resources in the appropriate way. For example, when a Web server receives a request from a browser, it reads a disk ﬁle. The server sends a response to the client and then waits for the next request.For example, a Web server sends the ﬁle back to a client. The client receives the response and manipulates it. For example, after a Web browser receives a page from the server, it displays it on the screen. 注意 进程点对点 客户端和服务器是进程，而不是常常提到的机器或者主机 事务可以跨主机 一台主机可以同时运行在不同的客户端和服务端，而且一个客户端和服务端的事务可以在同一台或是不同的主机上运行。 网络 I/O设备——网络 简介 对于一个主机而言，网络只是又一种I/O设备，作为数据源和数据接收方。 网络主机的硬件图 以太网段 组成 由电缆（通常是双绞线）和一个叫做集线器的小盒子组成 概念图 桥接以太网 组成 使用电缆和叫做网桥（bridge）的小盒子，多个以太网段可以连接成较大的局域网，称为桥接以太网。 概念图 路由器、互联网——局域网与广域网互联 局域网 集线器+网桥+电缆 局域网概念图 互联网络 在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器的特殊计算机连接起来，组成一个互联网络（internet） 互联网概念图 不同主机间网络通信 通信图 步骤 The client on host A invokes a system call that copies the data from the client’s virtual address space into a kernel buffer. The protocol software on host A creates a LAN1 frame by appending an internet header and a LAN1 frame header to the data. The internet header is addressed to internet host B. The LAN1 frame header is addressed to the router. It then passes the frame to the adapter. Notice that the payload of the LAN1 frame is an internet packet, whose payload is the actual user data. This kind of encapsulation is one of the fundamental insights of internetworking. The LAN1 adapter copies the frame to the network. When the frame reaches the router, the router’s LAN1 adapter reads it from the wire and passes it to the protocol software. The router fetches the destination internet address from the internet packet header and uses this as an index into a routing table to determine where to forward the packet, which in this case is LAN2. The router then strips off the old LAN1 frame header, prepends a new LAN2 frame header addressed to host B, and passes the resulting frame to the adapter. The router’s LAN2 adapter copies the frame to the network. When the frame reaches host B, its adapter reads the frame from the wire and passes it to the protocol software. Finally, the protocol software on host B strips off the packet header and frame header. The protocol software will eventually copy the resulting data into the server’s virtual address space when the server invokes a system call that reads the data. 全球IP因特网 IP地址 因特网客户端——服务端应用程序的基本硬件和软件组织 因特网（特性）——一个世界范围的主机集合 主机集合映射为一组32位的IP地址 这组IP地址被映射为一组称为因特网域名（Internet domain name）的标识符 因特网主机上的进程能够通过连接（connection）和任何其他因特网主机上的进程通信 IP地址 一个32位无符号整数 IP地址通常用点分十进制表示法来表示 例如：128.2.194.242 就是地址0x8002c2f2的点分十进制表示 inet_aton 函数将一个点分十进制（cp）转化为一个网络字节顺序的IP地址（inp） inet_ntoa 函数将一个个网络字节顺序的IP地址转化为它所对应的点分十进制串 因特网域名 产生原因 IP地址（大整数）很难记忆，另定义了一组更加人性化的域名，以及一种将域名映射到IP地址的机制。 域名是一串用句点分隔的单词（字母、数字和破折号），例如 kittyhawk.cmcl.cs.cmu.edu 域名的层级 常见的一级域名有com、edu、gov、org和net 一旦一个组织得到了一个二级域名，那么它就可以在这个子域中创建任何新的域名了 DNS域名系统 由上百万的主机条目结构组成，其中每条定义了一组域名和一组IP地址之间的映射 因特网连接 套接字地址 一个套接字是连接的一个端点，每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用”地址：端口”来表示 当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口。然而，服务器套接字地址中的端口通常是某个知名的端口，是和这个服务对应的。 连接 一个连接是它两端的套接字地址是唯一确定的，这对套接字地址叫做套接字对，由下列元组来表示（cliaddr:cliport,servaddr:servport） 其中cliaddr是客户端的IP地址，cliport是客户端的端口，servaddr是服务器的IP地址，而servport是服务器的端口。 例如 Web客户端的套接字地址是128.2.194.242:51213，其中端口号51213是内核分配的临时端口号 Web服务端的套接字地址是208.216.181.15:80，其中端口是和Web服务相关联的知名端口号]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：地址翻译]]></title>
    <url>%2F2019%2F11%2F25%2Fcsapp%2Faddress-translation%2F</url>
    <content type="text"><![CDATA[简介 定义： address translation is a mapping between the elements of an N- element virtual address space (VAS) and an M-element physical address space (PAS) MAP: VAS → PAS ∪ ∅MAP(A) =A’ (if data at virtual addr. A are present at physical addr. A_ in PAS)MAP(A) = ∅ (if data at virtual addr. A are not present in physical memory) 使用页表的地址翻译图 Figure 9.12 shows how the MMU uses the page table to perform this mapping. A control register in the CPU, the page table base register (PTBR) points to the current page table. The n-bit virtual address has two components: a p-bit virtual page offset (VPO) and an (n − p)-bit virtual page number (VPN). The MMU uses the VPN to select the appropriate PTE. For example, VPN 0 selects PTE 0, VPN 1 selects PTE 1, and so on. The corresponding physical address is the concatenation of the physical page number (PPN) from the page table entry and the VPO from the virtual address. Notice that since the physical and virtual pages are both P bytes, the physical page offset (PPO) is identical to the VPO. 页面命中 Figure 9.13(a) shows the steps that the CPU hardware performs when there is a page hit.(注：VA——虚拟地址，PTEA——页表条目地址，PTE——页表条目，PA——物理地址)Step 1. The processor generates a virtual address and sends it to the MMU.Step 2. The MMU generates the PTE address and requests it from the cache/main memory.Step 3. The cache/main memory returns the PTE to the MMU.Step 4. The MMU constructs the physical address and sends it to the cache/main memory.Step 5. The cache/main memory returns the requested data word to the pro-cessor. 页面不命中 Unlike a page hit, which is handled entirely by hardware, handling a page fault requires cooperation between hardware and the operating system kernel (Figure 9.13(b)).Steps 1 to 3. The same as steps 1 to 3 in Figure 9.13(a).Step 4. The valid bit in the PTE is zero, so the MMU triggers an exception,which transfers control in the CPU to a page fault exception handler in the operating system kernel.Step 5. The fault handler identiﬁes a victim page in physical memory, and if that page has been modiﬁed, pages it out to disk.Step 6. The fault handler pages in the new page and updates the PTE in memory.Step 7. The fault handler returns to the original process, causing the faulting instruction to be restarted. The CPU resends the offending virtual address to the MMU. Because the virtual page is now cached in physical memory, there is a hit, and after the MMU performs the steps in Figure 9.13(a), the main memory returns the requested word to the processor. 地址翻译的优化方式 结合高速缓存和虚拟存储器利用TLB加速地址翻译多级页表综合：端到端的地址翻译]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：系统级I/O]]></title>
    <url>%2F2019%2F11%2F25%2Fcsapp%2Fsystem-level-IO%2F</url>
    <content type="text"><![CDATA[简介 I/O(输入与输出) 定义:是在主存和外部设备（如磁盘驱动器、终端和网络）之间拷贝数据的过程。 学习Unix I/O的好处 了解Unix I/O将帮助你理解其他的系统概念。 有时你除了使用Unix I/O以外，你别无选择。 Unix I/O Unix文件： 定义：一个Unix文件就是一个各字节的序列：B0，B1，B2，…，Bk,…，Bm-1 文件： 定义：所有的I/O设备，如网络，磁盘和终端，都被模型化为文件，而所有的输入输出都被当作对相应的文件读和写来执行，这种将设备优雅地映射成文件的方式，允许Unix内核引出一个简单、低级的应用接口，称为Unix I/O。 一些基础的操作： 打开文件 改变文件的位置 读写文件 关闭文件 打开和关闭文件读和写文件用RIO包健壮的读写读取文件元数据共享文件]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：虚拟存储器]]></title>
    <url>%2F2019%2F11%2F14%2Fcsapp%2Fvirtual-memory%2F</url>
    <content type="text"><![CDATA[简介 定义 虚拟存储器是对I/O设备与主存的抽象。 虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。 虚拟存储器的目标 高速缓存 存储器管理工具 存储器保护工具 理解虚拟存储器的原因 中心的 强大的 危险的 讲解思路 前一部分描述虚拟存储器是如何工作的 后一部分描述应用程序如何使用和管理虚拟存储器 物理和虚拟寻址 主存定义 计算机系统被组织成一个由M个连续的字节大小的单元组成的数组 物理寻址图 虚拟寻址图 地址翻译 将一个虚拟地址转换为物理地址的任务叫做地址翻译 MMU（存储器管理单元） 属于CPU中的一部分，该硬件利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理 地址空间 定义 地址空间是一个非负整数地址的有序集合：{0,1,2,…},如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。 虚拟地址空间 在一个带虚拟存储器的地址空间中，CPU从一个有N=2n个地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间：{0,1,2,…,N-1} 一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如：一个包含了N=2n个地址的虚拟地址空间就叫做一个n位地址空间。 思考：32位或者64位虚拟地址空间的系统，其虚拟地址数分别是多少，最大可能的虚拟地址是多少？ 物理地址空间 它与系统中物理存储的M个字节相对应：{0,1,2,…,M-1} 虚拟存储器的思想 主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。 小结 地址空间的概念很重要，因为它清楚的区分了数据对象（字节）和它们的属性（地址） 作为缓存工具 虚拟页 定义：As with any other cache in the memory hierarchy, the data on disk (the lower level) is partitioned into blocks that serve as the transfer units between the disk and the main memory (the upper level). VM systems handle this by partitioning the virtual memory into ﬁxed-size blocks called virtual pages (VPs). Each virtual page is P = 2p bytes in size. 物理页 定义：Similarly, physical memory is partitioned into physical pages (PPs), also P bytes in size. (Physical pages are also referred to as page frames.) 物理页的状态 未分配 Pages that have not yet been allocated (or created) by the VM system. Unallocated blocks do not have any data associated with them,and thus do not occupy any space on disk. 已缓存 Allocated pages that are currently cached in physical memory. 未缓存 Allocated pages that are not cached in physical memory. 一个VM系统是如何使用主存作为缓存 页表 页表结构 页命中 VM页命中 缺页 VM缺页 分配 分配一个新的虚拟页面 作为存储器管理工具 简介 操作系统为系统中的每个进程都维护一个独立的页表 按需页面调度和独立的虚拟地址空间的结合，对系统中存储器的使用和管理造成了深远的影响。 VM如何为进程提供独立的地址空间 简化链接 每个进程的存储器影像使用相同的基本格式，文本节，数据和bss节，栈 这样的一致性，极大的简化了链接器的设计和实现，允许链接器生成全链接的可执行文件。 简化加载 加载器从不实际从磁盘拷贝数据到存储器 在每个页被初次引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令被引用一个存储器位置时引用的，虚拟存储器系统会按需要自动调入数据页。 简化共享 进程之间需要共享代码和数据，可以通过虚拟存储器实现 操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个拷贝，而不是在每个进程中都包括单独的内核和C标准库的拷贝。 简化存储器的分配作为存储器保护工具 为操作系统提供手段来控制对存储器系统的访问，不允许一个用户进程修改它的只读文本段。 每个PTE中已经添加了3个许可位，SUP位表示进程表示进程是否必须运行在内核模式下才能访问该页。 READ和WRITE位控制对页面的读和写访问。 用虚拟存储器来提供页面级别的存储器保护]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：异常控制流与进程]]></title>
    <url>%2F2019%2F11%2F03%2Fcsapp%2Fexceptions-processes%2F</url>
    <content type="text"><![CDATA[本章简介 异常控制流 定义 现代系统通过使用控制流发生突变对系统各种状态的变化作出反应，我们把这些突变称为异常控制流（Exceptional Control Flow） 理解异常控制流的好处 理解重要的系统概念 理解应用程序是如何与操作系统交互的 编写有趣的新应用程序 理解并发 理解软件异常如何工作 本章讲解思路 与操作系统交互 这一章的重要性在于学习应用是如何与操作系统交互，交互是围绕ECF的，将从一个计算机系统中所有层次上各种形式的ECF展开 从异常开始，异常位于硬件与操作系统交界的部分 讨论系统调用，他们是应用程序提供到操作系统的入口点的异常 提升抽象的层次，描述进程号，他们位于应用和操作系统的交界之处 最后，讨论非本地跳转，这是ECF的一种应用形式 异常 异常处理 异常 异常就是控制流中的突变，用来响应处理器状态中的某些变化 事件 状态变化称为事件，事件可能和当前指令的执行直接相关 异常表 在任何情况，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序（称为异常处理程序） 异常的剖析 异常跳转 处理程序将控制返回给当前指令Icurr，即当前事件正在执行的指令。 处理程序将控制返回给Inext,即如果没有发生异常，将会执行的下一条指令。 处理程序终止被中断的程序。 异常号 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号，这些号码是由处理器的设计者或者操作系统内核分配的。 异常表 在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得条目k包含异常k的处理程序地址。 异常的类别异步异常 中断 中断是异步发生的，来自处理器外部I/O设备信号 返回结果后，程序继续执行下一条指令，就像没有发生中断一样 硬件中断的异常处理程序称为中断处理程序 同步异常（故障指令） 陷阱 有意的异常，执行一条指令的结果，最常用途——系统调用 在用户程序和内核之间提供一个像过程一样的接口 系统调用与普通函数调用的区别 普通的函数调用运行在用户模块中，用户模式限制了函数可以执行的指令类型，而且它们只能访问与调用函数相同的栈。 系统调用运行在内核模式中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。 故障 故障由错误情况引起，一般是潜在可恢复的错误,它能够被故障处理程序修正。 常见的是缺页异常 终止 不可修复的错误引起，例如：DRAM与SRAM被损坏时发生的奇偶错误。 终止处理 终止处理程序将控制传递给一个内核abort例程，该例程终止这个应用程序 Linux/IA32系统定义异常 常见的异常 除法错误 一般保护故障 缺页 机器检查 IA32异常示例图 进程 进程 异常是允许操作系统提供进程的概念所需要的基本构造块 进程的经典定义是一个执行中的程序的实例 上下文 系统中的每个程序都是运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的。 这个状态包括存放在存储器中的程序的代码和数据，它的栈，通用的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程是对应用程序的关键抽象 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器。 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。 逻辑控制流 定义 程序计数器PC的值叫做逻辑控制流 逻辑控制流图 案例 考虑一个运行三个进程的系统，处理器的一个物理控制流分发成了三个逻辑流。每个进程一个，三个逻辑流的执行是交错的。 进程A运行了一会儿，然后是进程B开始运行完成。然后，进程C运行了一会，进程A接着运行直到完成。最后，进程C可以运行到结束了。 图的关键点在于进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。 逻辑流形式 异常处理程序、进程、信号处理程序 线程和java进程 并发流 并发流 多个流并发地执行的一般现象称为并发，并发使计算机运行得更快 并发的思想与流运行的处理器核数或者计算机数无关。如果每个流在时间上重叠，那么它们就是并发。 并行流 并行流是并发流的一个真子集，如果两个流并发的运行在不同的处理器或者计算机上，那么我们程它们为并行流。 并行使计算机能做的更多，它们并行的运行，且并行地执行。 私有地址空间 定义 一个进程为每个程序提供它自己的私有地址空间 组成 地址空间底部是保留给用户程序的，包括通常的文本、数据、堆和栈段。 进程地址空间图 用户模式和内核模式 模式位 处理器通过使用某个控制寄存器中的一个模式位，来限制一个应用可以执行的指令以及它可以访问的地址空间范围。 当设置模式位时，进程就运行在内核模式中，一个运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。 没有模式位时，进程就是运行在用户模式中。用户模式中的进程不允许执行特权指令，比如停止处理器，改变位模式，或者发起一个I/O操作。 模式转化 初始时 运行应用程序代码的进程初始时是在用户模式中。 用户模式转内核模式 唯一方法，调用中断、故障、或者陷入系统调用的异常 内核模式转用户模式 处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把内核模式改回为用户模式 上下文切换 定义 上下文就是内核重新启动一个被抢占的进程所需的状态 操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。 上下文切换图 上下文切换 保存当前进程的上下文 恢复某个先前被抢占的进程被保存的上下文 将控制传递给这个新恢复的进程]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：存储器层次结构]]></title>
    <url>%2F2019%2F10%2F20%2Fcsapp%2Fstorage-technologies%2F</url>
    <content type="text"><![CDATA[存储技术 随机访问存储器 SRAM 用作高速缓存存储器 DRAM 作为主存以及图形系统的帧缓冲区 对比 SRAM具有多个晶体管，访问快，不敏感，造价高，应用于高速缓存存储器。 磁盘 磁盘构造 磁盘 磁盘是由盘片构成，每个盘片有两面称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转（单位：RPM）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。 扇区 每个表面由一组称为磁道的同心圆组的。每个磁道被划分为一组扇区，每个扇区包含相等数据位（通常是512字节）。扇区之间由一些间隙分隔开，这些间隙中不存储数据位，用来标识扇区的格式化位。 磁盘构造 盘片，盘面，主轴，磁道，扇区，柱面 磁盘容量 磁盘容量＝字节数/扇区 * 平均扇区/磁道 * 磁道数/表面 * 表面数/盘片 *盘片数/磁盘 访问时间 访问时间=寻道时间+旋转时间+传送时间 传送时间与寻道时间、旋转时间比较，很少 寻道时间和旋转时间大致相等 将寻道时间乘以2，看作是磁盘访问时间的估计值 磁盘的动态特性 寻道时间 为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。依赖于读/写头以前的位置和传动臂在盘面上移动的速度。 旋转时间 一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个bit旋转到读/写头下。依赖于当读/写头到达目标扇区时盘面的位置和磁盘的旋转速度。 传送时间 当目标扇区的第一个bit位于读/写头下时，驱动器就可以开始读或者写该扇区的内容了。一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。 逻辑磁盘块 可将磁盘分为B个扇区大小的逻辑块的序列，编号为0，1，…，B-1。磁盘中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和物理磁盘扇区（盘面、磁道、扇区）之间的映射关系。 固态硬盘 固态硬盘 固态硬盘(SSD)的存储介质分为两种，一种是采用闪存（FLASH芯片）作为存储介质(如笔记本硬盘、存储卡、优盘等)，另外一种是采用DRAM作为存储介质(目前应用范围较窄)。而传统旋转硬盘是使用机械驱动器作为存储介质。SSD插到I/O总线上标准硬盘插槽（通常是USB）中，行为就和旋转硬盘一样。 对比 SSD相比旋转硬盘，随机访问时间更快，能耗更低，同时也更结实，但价格较贵。 局部性 局部性原理 在数据访问时，具有“引用邻近于其他引用过的数据项的数据项，或者最近引用过的数据项本身”的这种倾向，叫作局部性原理。 局部性原理对硬件和软件系统的设计和性能都有着极大的影响。 对程序数据引用的局部性 时间局部性 在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用。 取指令的局部性 空间局部性 在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。 局部性小结 重复引用同一个变量的程序有良好的时间局部性 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性很差。 对于取指令来说，循环有很好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。 存储器层次结构 存储器层次结构 层次结构图 L0层寄存器 一个时钟周期的访问时间，缓存的是字，大小4字节或者8字节。 L1～L3层高速缓存（SRAM） 几个时钟周期的访问时间，缓存的行，64字节块。 主存（DRAM） 几十到几百个时钟周期，部分文件。 本地磁盘 磁盘扇区，数万个时钟周期。 分布式文件系统 网络传输，传输更慢。 缓存的概念 缓存 高速缓存是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存。 块 第k+1层的存储器被划分成连续的数据对象片，称为块。每个块都有一个唯一的地址或名字，使之区别于其他的块。 大块可以减少访问次数。 存储器层次结构中基本的缓存原理 缓存命中 当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中查找d。如果d刚好缓存在第k层中，那么就是我们所说的缓存命中。 结构层次小结 利用时间局部性 由于时间局部性，同一数据对象可能会被多次使用。一旦一个数据对象在第一次不命中时被拷贝到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。 利用空间局部性 块通常包含有多个数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后拷贝该块的花费。 ​]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[校招面试题个人整理]]></title>
    <url>%2F2019%2F09%2F26%2Fschool-inter-questions%2F</url>
    <content type="text"><![CDATA[java基础1. Object类中有什么方法，讲一讲各个方法的作用？ 答： toString() 打印对象实例的信息内容（描述我是谁） getClass() 获取类信息Class对象（骨子里特性） equals() 判断两个对象的地址引用是否相等，如果方法被覆盖的话，比较的是内容（谁会与我共鸣呢）。 hashCode() 获取对象的hashCode值,用于区分对象实例的唯一性（每个人都是独一无二的）。 wait() 当线程执行wait方法时，会使该对象进入等待池，释放锁资源，让其他线程执行。 notify() 当线程执行notify时，会唤醒等待的线程。 clone() 对象的浅拷贝（描述我是从哪来） finalize() 垃圾回收不再被引用的对象，释放内存(描述我要到哪去)。 2. sleep()与wait()方法的区别？ 答： sleep是Thread的静态方法，使得调用线程进入休眠状态，休眠的时候依然占据对象锁，其他线程拿不到锁会阻塞，但是会让出CPU资源给其他线程，等到休眠时间结束，线程就进入到就绪状态，和其他线程一起竞争CPU。 而wait是Object类中的方法，当一个线程执行到wait方法时，它就进入一个和该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll()方法来唤醒等待的线程。 3. 说一下“==”与equals()的区别？ 答： “==”对于基本类型来说，比较的是内容（比如int类型，比较的是数值大小）。如果是引用类型，则比较的是对象的引用地址。 equals是Object基类中的方法，实现是比较引用地址（==），如果被覆盖，则比较的是内容。 4. equals与hashcode的区别？ 答： 这两个方法主要用于Set,HashTable中，如果对象要用Set(去重)，HashTable存储(散列)，则应该考虑重写hashCode方法。 如果两个对象的equals方法相等，则调用hashCOde返回的哈希码值也相等。 但是，hashCode相等，不一定equals方法相等。 注意，通常需要在重写hashCode()方法时重写equals方法，以便维护hashCode方法的 general contract，该方法声明equals相等的对象必须具有相等的散列代码。(看Object对象的源码) 5. 抽象类与接口的区别，本质区别是什么？ 答：抽象类是为了实现代码的重用（复用），而接口是为了降低代码的耦合度。 6. java中打印HelloWorld的执行流程？ 答： javac编译HelloWorld.java,得到HelloWorld.class字节码文件。 JVM将字节码文件加载进内存中(即方法区的类代码区中)。 JVM找到HelloWorld的main方法，传递String类型参数的地址到主方法的args中去，并在栈区为args开辟内存空间，返回一个void的返回值。 创建一个“HelloWorld”对象，对象在方法区的常量数据区开辟空间，其属性值为“HelloWorld”。 定义一个String类型的变量s(在栈区开辟空间)，变量s存放对象“HelloWorld”的地址。 JVM找到标准类库中的System.class类并加载到内存中(即方法区的类代码区中),System初始化时会创建PrintStream标准字节输出流对象，调用println()方法将变量s的值打印到屏幕上。 流程图如下所示 7. linux熟悉的命令 答： 如果自己部署过服务器，那这个问题还不是so easy.可以参考这篇 终端命令小入门 pwd 打印当前所在目录 cat 打印文本文件内容 vim 编辑文本 tar 压缩文件 ssh 登录服务器 sudo 以系统管理者的身份执行指令 chmod 修改文件权限 mkdir 创建文件夹 mv 移动 cp 拷贝 rm -rf 强制删除 查看服务器上跑的服务 ps -ef|grep sssc|grep jar 模糊搜索日志 cat sssc-soa-app_applicationLog_2019-07-25-3.log | grep “startup” 8. 为什么组合优先于继承？ 答： 继承耦合度高，组合使用java多态的特性降低耦合度。 比如，采用继承的方式，当父类需要发生变动时，而其所有的子类都会反映出这种变动。而组合却可以抽象出一个共有的接口，然后传入指定的实现类，让其他不相关类避免受影响。 数据结构1. List元素实现删除有哪些注意的？ 答：Collection集合相关类做删除操作时，不能边遍历边删除，因为内部维持了expectedModCount这么一个字段，如果modCount != expectedModCount并不等于，则会抛出ConcurrentModificationException异常。 2. 讲一下HashMap与HashTable的区别？HashMap的扩容方式，get()方法和put()方法，最好能写出代码。ConCurrentHashMap的实现原理？ 答： 3. 数组和链表的区别，ArrayList的扩容方式？ 答： 4. 队列与栈的区别，介绍常见的使用场景？ 答： 5. 手写一个Hashmap的遍历？ 答： 6. HashSet是怎么实现的？ 答： 7. 手写二叉树的遍历。 答： 算法1. 快排与冒泡的区别？手写一个试试？ 答： 2. 手写一个二分查找和归并排序？ 答： 3. 单链表的反转？迭代与递归的实现方式？ 答： JVM1. 按照你的理解，讲讲JVM内存结构？ 答： 2. 讲讲垃圾回收，常见的垃圾回收算法有什么？ 答： 3. 什么情况下会触发FULL GC?什么情况下会触发Mini GC？ 答： 网络1. 输入URL到页面加载发生了什么？ 答： 2. 讲一讲TCP三次握手,四次挥手，画一下 答： 3. 悲观锁与乐观锁的区别？ 答： 4. servlet API中forward()与redirect()的区别？ 答： 5. 讲一下get与post的区别？ 答： 6. 常见http的协议状态有哪些？ 答： 7. TCP与UDP的区别？ 答： 8. 讲讲序列化的底层实现原理。 答： 数据库1. 讲一讲数据库的优化有哪些？ 答： 主从同步，读写分离 分库分表 水平分表 垂直分表 建立索引，提高查询性能 缓存，减少对数据库的访问 2. 数据库怎么建立索引，索引有哪几种？ 答：参考文章Mysql创建索引 在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。 主键索引，普通索引，唯一索引 ALTER TABLE（用来创建普通索引、UNIQUE索引或PRIMARY KEY索引） ALTER TABLE table_name ADD INDEX index_name (column_list) ALTER TABLE table_name ADD UNIQUE (column_list) ALTER TABLE table_name ADD PRIMARY KEY (column_list) CREATE INDEX （对表增加普通索引或UNIQUE索引） CREATE INDEX index_name ON table_name (column_list) CREATE UNIQUE INDEX index_name ON table_name (column_list) 注：不能用CREATE INDEX语句创建PRIMARY KEY索引 注：PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引 删除索引 DROP INDEX index_name ON talbe_name ALTER TABLE table_name DROP INDEX index_name ALTER TABLE table_name DROP PRIMARY KEY 注：如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。 注：如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 查看索引 show index from tblname 字段解析 Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。 Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE） Seq_in_index 索引中的列序列号，从1开始。 Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 Cardinality 索引中唯一值的数目的估计值。 使用索引注意事项 查询较多，修改较少适合创建索引，经常插入、删除、修改的表不适合 建立索引会有相应的存储消耗 复合索引效率更高 3. 对redis了解吗？Redis有哪些数据结构？用来干什么？使用场景？ 答： Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合) String（字符串）：set与get Hash(哈希)：hmset与hgetall list（列表) : lpush与lrange set（集合）：sadd与smembers zset(sorted set：有序集合):zadd与zrangbyscore 4. 手写创建表，给表添加字段，修改字段的sql语句 答： 给表添加字段 alter table t_cloud_user add salemoney DECIMAL(12,2) DEFAULT ‘0’ COMMENT ‘销售额’; 修改字段 alter table t_cloud_user change m1 button VARCHAR(200) DEFAULT NULL COMMENT ‘button按钮’; 新建索引 alter table t_sssc_salary add index Code_WAGENO(code,WAGENO); create index Code_WAGENO on t_sssc_salary(code,WAGENO); 删除索引 DROP INDEX index_name ON talbe_name; ALTER TABLE table_name DROP INDEX index_name; 5. 主从同步延时的解决方案 缩小延时时间 修改主从库的配置参数，提高sql的执行效率 数据库的版本（5.6.3之后采取多线程同步） 提高从服务器的硬件性能（CPU，内存，SSD磁盘） 网络（局域网缩小同步延时时间） 不选择走从库 对于不经常更新的表，查询的时候配置直接走从库。 对于常更新的表（比如薪资表），更新之后放入缓存，查询的时候查缓存 ​ 多线程1. 并发与并行，同步与异步，线程与进程的区别？ 答： 2. 谈一谈线程池，常用的线程池有哪几种？线程池有什么作用？ 答： 3. 线程池怎么使用？如何设置核心线程数，队列长度，以及最大线程数。 答： 4. 创建线程有哪几种方式？ 答： 5. 线程有哪几种状态，如何进行转换的？ 答： 6. synchronized的底层是怎么实现的？ 答： 7. 手写生产者，消费者代码 答： 8. 如何避免死锁？ 答： 框架与模式1. 讲一下熟悉的设计模式？单例模式有哪几种？手写一个单例模式 答： 2. 单例模式和工厂模式的本质区别在哪里？ 答： 3. 简单介绍一下springMVC的执行流程？ 答： 4. 简单介绍一下Spring的两大核心？ 答： 5. 看过spring的源码吗？说说底层是怎么实现的？ 答： –]]></content>
      <categories>
        <category>interview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机：计算机系统漫游]]></title>
    <url>%2F2019%2F09%2F01%2Fcsapp%2Fcs-tour%2F</url>
    <content type="text"><![CDATA[一个C语言程序的产生 之前在 走近计算机，走进二进制，爪哇国的诞生讲到一个java程序是怎么执行的，然而依然是知其然，而不知其所以然。今天特意来用C语言写一个程序，看看它是怎么在计算机上跑起来的。 源码 hello.c 12345#include &lt;stdio.h&gt;int main()&#123; printf("%s\n", "Hello,world!");&#125; 编译 源代码通过编译器编译得到目标程序 这个时候会在桌面生成目标程序hello【可直接运行】 目标程序文件里面都是 二进制 编译系统 编译时分工是这样的 计算机体系结构 总线 总线是贯穿整个系统的一组电子管道，它携带信息字节并负责在各个部件间传递。 按照部件之间信息传递划分：系统总线，存储器总线，I/O总线 按照功能划分：控制总线、数据总线、地址总线 I/O设备 输入/输出（I/O)设备是系统与外部世界的联系通道 一共有五种：鼠标、键盘、显示器、磁盘、扩展槽（常见的网卡） 主存 主存是一个临时存储设备，在处理器执行程序是，用来存放程序和程序处理的数据。 除去高速缓存使用SRAM外，主存一般使用的是DRAM硬件技术 CPU处理器 中央处理单元（CPU）,简称处理器，是解释（或执行）存储在主存中指令的引擎。 由三部分组成：控制器，运算器和寄存器 体系结构图 目标程序的执行 现在我们目标程序有了，那么怎么执行呢，从用户输入字符到打印结果到屏幕上，计算机到底经历了什么？ 执行时对话是这样的 存储设备层次结构 从上面的过程可以看到，hello程序初始时在磁盘上，当程序加载时，它又被复制到主存中，当处理器运行程序时，指令又从主存复制到处理器，当程序执行完时，“hello，world”又得复制回显卡，这一系列过程中都涉及数据的复制，如果复制的速度跟不上，那么计算机就可能会瘫痪。 我们知道，寄存器与CPU信息传递速度是主存的数百倍级别，是磁盘的百万倍级别，可是，寄存器能存的数据太小，并且同样大小存储造价比磁盘贵得不知道多少个数量级。为了提升计算机性能同时，又不想有太多的造价负担，高速缓存应运而生。 高速缓存的原理 空间局部性 就是说内存上如果某一地址空间的数据频繁的被CPU访问，那么其旁边的存储单元也有可能被访问。 时间局部性 在某一段时间内，内存上如果某一地址空间的数据频繁的被CPU访问，那么在未来很可能会再次访问。 存储设备层次结构 操作系统的抽象 基本功能 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备 抽象 文件是对I/O设备的抽象，虚拟存储器是对主存和磁盘I/O设备的抽象，进程则是对处理器、主存和I/O设备的抽象，虚拟机，提供对整个计算机（包括操作系统、处理器和程序）的抽象。 结构图： 进程与线程 进程 进程是操作系统对一个正在运行的程序一种抽象. 在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件. 而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的，操作系统实现这种交错执行的机制称为上下文切换。 实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。 线程 一个进程可以包含多个线程，但至少包含一个线程。 书上是这样说的，在现代系统中，一个进程实际上是可以由多个吗称为线程的执行单元，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。 并且多线程之间比多进程之间更容易共享数据，线程一般来说比进程更高效。 并发与并行 并发 使计算机做得更多 单核处理器在某时间段（宏观上）处理多个任务。 注，是指宏观上（即某一时间段），其实从微观看来（在任何一个时刻），单处理器系统都只能执行一个进程的代码。 并行 使计算机处理的更快 同一个进程里面的任务可以在多个处理器上运行。 并发与并行对比图 参考资料: 学习笔记深入理解计算机系统（原书第二版）]]></content>
      <categories>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SHELL命令汇总]]></title>
    <url>%2F2019%2F04%2F10%2Fshell-commands%2F</url>
    <content type="text"><![CDATA[SHELL命令汇总在Mac使用小技巧中提到了终端命令操作，但是概括得不全，加上之前没有接触过linux命令，面试时问到时很是慌得一批，不过现在有了Mac本，终于有理由逼自己一把了，哈哈，让我们一起来学习吧！ 查看隐藏文件夹defaults write com.apple.finder AppleShowAllFiles TRUE killall Finder不想显示被隐藏的文件defaults write com.apple.finder AppleShowAllFiles FALSE killall Finder使文件不隐藏chflags nohidden /Users/alongso_pro/Desktop（只对隐藏文件/文件夹有用）使文件隐藏chflags hidden /Users/alongso_pro/Desktop（只对可见文件或文件夹有用）sudo命令为系统超级管理员755 代表用户对该文件拥有读，写，执行的权限。创建文件touch .aa打开文件open .aa配置环境变量source .aa开启tomcat进入tomcat的bin目录，键入sudo sh startup.sh关闭tomcat服务sh ./shutdown.sh查看端口被哪个程序占用sudo lsof -i tcp:8080根据进程的PID，可以将进程杀死sudo kill -9 1659如何查看系统中每个进程:ps -A ps -e命令提供了运行中系统动态的视图top查看当前目录的路径pwd /Users/alongso_pro/Desktop使用绝对路径进入文件夹，不改变当前目录:cd / 使用相对路径进入文件夹，改变当前目录cd Users/alongso_pro/Desktop qianmoyushengMacBook-Pro:Desktop alongso_pro$ 查看当前目录下的所有文件夹,不改变当前目录(list directory contents)： ls -l/-R/-a 绝对路径/相对路径 -l,查看目录中每个文件的权限 -R,显示目录下所有的文件夹和文件 -a,显示目录下所有的文件夹和隐藏文件 man+所有命令可以查看该命令的信息介绍(format and display the on-line manual pages)： man ls、 man open 、man chflags 也可以敲下该命令直接回车。 man ls: 命令后在最后出现一个end,返回继续输入命令:q或者ctr+c将所有截图保存为JPG，而不是系统默认的PNGdefaults write com.apple.screencapture type -string “jpg&quot;文件的拷贝ln -s ~/Desktop/党员党费详情.xlsx ~/workfile/ ln [-Ffhinsv] source_file [target_file] ln [-Ffhinsv] source_file ... target_direcho,相当于println--write arguments to the standard outputsay 语音say -f /Users/alongso_pro/Desktop/《三国演义》罗贯中.txtcat 打印文本内容-- concatenate and print files cat /Users/alongso_pro/Desktop/《三国演义》罗贯中.txthead-- display first lines of a filetail-- display the last part of a filenl-- line numbering filter一个有趣的ASCII版动漫:“星球大战：新希望”telnet towel.blinkenlights.nl chrome的小恐龙游戏：在没连网的情况下在Chrome地址栏输入：`chrome://dino/`]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac使用小技巧]]></title>
    <url>%2F2019%2F03%2F10%2Fmac-skills%2F</url>
    <content type="text"><![CDATA[Mac使用小技巧 最近新入手了一台Mac笔记本，发现Mac OS使用起来特别人性化，Mac系统是基于Unix内核的图形化操作系统.对于一位开发者而言，我最欣赏的是能在终端上随心所欲，对电脑进行任何操作，当你实现了某个功能时候，心中不油而然生出一种莫名的成就感，长此以往，也能激发我对程序开发的热情。我一直相信，Mac笔记本不只是开发工具，当它摆在你面前，它更像一件艺术品。为了快速上手Mac，这里总结了一些小技巧。 快捷键篇拷贝文件的路径option+command+C根据路径打开文件command+shift+G快速进入硬盘最高目录command+shift+C快速关闭app或者tab页窗口command+w/command+Q最小化窗口Commmand+m(相当于点击窗口的最小化&apos;-&apos;)窗口最大化Command + control + F快速隐藏command+H新建应用程序窗口command+N刷新网页Command+R撤销/重做command+Z/command+Shift+Z返回文件上一级Command + 方向全面截屏快捷键command+shift+3部分截屏快捷键command+shift+4（这个挺麻烦，我还是喜欢用wechat截图工具）录屏（快速打开屏幕快照）Shift + Command + 5快速查看/操作您不仅可以预览文件，现在还可以进行各种编辑操作，如裁剪照片、签名 PDF 表单和修剪视频片段，以标记图像。轻松搜索Command + 空格键 如果想查看文件所在路径，可按住command（但是我想打开文件的所在目录怎么办呢？）拷贝文件command+C&amp;&amp;command+V移动文件先拷贝文件， 然后进入你要拷贝到的文件夹，空白处右键，按住alt键，点击将项目移动到这里新建浏览器窗口command+shift+n使用浏览器定位地址栏command+L缩放字体command加上+/-键打开偏好设置command+,缩放快捷键（相当于缩放镜）option+command+(-/+)清空废纸篓shift+command+delete直接清倒废纸篓shift+option+command+delete打开某个文件command+O(=双击)重命名回车键（=间隔的两次点击）查看某个文件夹中隐藏的文件shift+command+.恢复之前是否被隐藏的状态shift+command+.新的tab页中打开链接按住command，点击链接tab页之间的切换shift+command+左右方向键操作篇桌面分屏在同一个桌面的两个窗口，按住窗口最大化按钮拖动到左上角，然后点击另外一个窗口。如果不再同一个桌面，先将一个窗口最大化，然后将另外一个桌面的窗口拖进来手机遥感keynote播放ppt时可以用手机来进行遥控新建检索索引点击文件/文件夹—简介，修改注释alis，然后通过comand+space输入注释的文本英文提示快捷键F5或者带bar中显示的提示（智能选取-pages,keynote，wechat也适用）对磁盘权限进行检查和修复sudo periodic daily weekly monthly自带输入法使用技巧拼音分词，打开键盘可以设置快捷键，（omw-on my way!）shift+6可以输入表情符号移动底下的窗口时为了上面的窗口被遮挡按住command进行拖动文件检查器选中文件，右键按住alt，点击show inspector，查看几个文件，操作，图片还能幻灯片显示屏幕共享操控设置 &gt; 共享中开启「屏幕共享」，之后进入访达 &gt; 点按「网络」&gt; 连接要共享的 Mac，然后点按「共享屏幕」参考链接 终端命令篇查看文件/文件夹占用的存储空间du -sh */dir/file查看活动监视器top htop终端颜色装饰的命令(需自己安装) 安装参考链接 查看所有执行过的命令history 打开文件夹，文件，应用程序和网址open / || open http://baidu.com查看剪切板内容pbpaste 也可以通过可视化窗口查看：finder—&gt;edit—&gt;show cliboard软件推荐篇截屏软件XnipXnip——截屏了以后可以选择保存到哪个目录下视频播放器IINAQuickTim是Mac自带的视屏播放器，可以打开mp4、mov等格式的视频，却无法打开rmb、rm、flv等格式的视频，我用IINA了一段时间，感觉体验不错。印象笔记在笔记这块，我用的是印象笔记，功能相当强大，支持markdown和mindMap格式,用习惯了相当不错。]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F1994%2F10%2F02%2Fmyresume%2Fmyresume%2F</url>
    <content type="text"><![CDATA[个人信息 陈建蓉/男/1994 工作年限：2年 技术博客：https://alongsocjr.github.io 微信公众号：阡陌余生 学历：西南大学(211)/本科/计算机专业 期望职位：Java中级工程师 期望薪资：15K 联系方式 手机：17718480976 Emal：alongsocjr@163.com QQ/Wechat：1553557551/alongsocjr 技能清单以下均为我熟练使用的技能 主力语言：java 基础：多线程、并发锁机制、JVM、集合框架、算法和设计模式 框架：Spring/SpringMVC/Mybatis/SpringBoot/Dubbo 中间件：Zookeeper/Redis/RabbitMq/OneProxy 数据库相关：MySQL/Oracle 版本管理、文档和自动化部署：Svn/Git/Jenkins 服务器：Linux常用命令，基本的Shell编写 工作经历阳光保险科技中心 （ 2018年7月~至今 ）实时算薪计算引擎项目描述：计算引擎是我们为了解决代理人实时算薪的一款流式计算框架，为解决原薪资计算滞后、反复查询、重复计算而设计的。计算引擎采用 组件化 设计，以 消息驱动 实现薪资实时计算。根据不同类型的消息体，会重算代理人不同层级的指标。每一层级的指标进行 原子化拆分，实现计算中间结果利用 最大化，减少重复计算。 主要负责： 实时提数与计算引擎的对接 参与薪资项的开发，主要负责代理人增才奖、个税、团队DIY聘才的开发 阳光层与个人层的消息对接，阳光层所有薪资的计算实现 项目亮点： 采用redis记录消息状态，管理消息生命周期，方便消费异常的消息处理。 引入指标引擎思想，计算采取分层（横分）和分序（竖分）的方式，保证同一层的指标计算顺序。 通过消息的流转，动态驱动薪资计算，采用中间件（MQ、Redis）保证消息不丢失，顺序消费。 采用多线程机制进行并行计算，利用ZK锁保证一个四级机构只有一个线程消费消息，多个四级机构可同时消费该四级机构队列的消息。 考勤大屏实时追踪项目描述：这是代理人出勤实时追踪全国代理人出勤情况，从全国、二级、三级和营业区不同维度，根据职级和子渠道进行统计。可监控当日代理人出勤打卡情况，数据统计可追溯至当月，历史六个月。app、pc、ipad端均可调用接口监控营业区代理人职场画面。 主要负责： 负责模块梳理，考勤大屏数据抽象、接口设计以及缓存设计 负责公司集团内部系统对接，对来自不同平台请求进行加解密处理 项目亮点： 以每十分钟一跑批处理的方式处理后台数据，保证考勤数据的实时性，实现数据的可视化达到鼓舞代理人积极考勤，至上线以来全国代理人考勤率提升5个百分点。 系统集成多个重要指标，从不同的维度统计数据，给公司高层领导反馈全国代理人出单情况便于内部战略决策。 消息推送平台项目描述：这是一个消息推送平台的管理系统，可配置不同的薪资指标项，生成消息推送模板，向不同的平台(app端，企业微信、PC端），对公司代理人实时/定时的推送消息。 主要负责： 前端增删改查开发实现，MQ延时队列配置。 消息监听器，消息处理器，消息发送中心，持久化定时任务的实现。 项目亮点： 通过数据库的配置，灵活实现指标值，消息类型的配置，无需改动代码。 使用MQ延时插件 rabbitmq_delayed_message_exchange，灵活解决定时发送问题。 使用redis双级缓存-队列和hash的结构，实现待更新主键和持久化数据的分离，提高程序高可用性。 使用策略模式，一个推送平台对应一个具体实现，实现系统设计的低耦合性。 代理人实时提数项目描述：这是一个对公司原先PL/SQL package 批处理的改造，将业务迁移至新系统的一个服务 。代理人出单后，数据写入老核心系统，新系统会实时的每5分钟轮询一次，将数据直接提到MySQL数据库。 主要负责： 设计批处理日志记录表，书写新系统批处理管理规范文档。 实现提数业务逻辑，提交数据库后，向rabbitMQ 计算引擎发送消息，触发薪资实时计算。 项目亮点：采用多并发线程机制，大大提升提数性能，将营销渠道的提数延迟时间由之前的隔日缩短至五分钟。 北京银客集团全能数据中心微博借钱平台（ 2017年12月~2018年4月 实习）项目描述：本项目是一款由微博渠道提供用户入口，基于大数据平台进行风控审核的金融互联网借贷平台。 主要负责：参与后台管理系统的开发，协调公司内部工作。]]></content>
      <categories>
        <category>resume</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F1994%2F10%2F02%2Fmyresume%2Fmyresume_version1%2F</url>
    <content type="text"><![CDATA[个人信息 陈建蓉/男/1994 工作年限：2年 技术博客：https://alongsocjr.github.io 微信公众号：阡陌余生 学历：西南大学(211)/本科/计算机专业 期望职位：Java中级工程师 期望薪资：15K 联系方式 手机：17718480976 Emal：alongsocjr@163.com Wechat：alongsocjr 技能清单 掌握 多线程 编程，分布式锁 的使用，对 线程池 和 锁 的原理做过深入研究。 对 class文件 做过深入研究，了解class文件的详细信息，熟悉常用的 字节码指令集。 熟悉 java内存模型 ，JVM的 双亲委派加载机制 以及 JVM内存分配。 熟悉 GC常用算法，熟悉常用的 垃圾收集器，具有实际的 JVM调优 实战经验。 具备 敏捷式 开发实战经验，掌握 结对编程 和 测试驱动开发 相关理念，追求严格的代码质量开发规范。 熟悉 面向对象设计，掌握基本的 设计原则 和 设计模式，有一定的系统架构设计能力。 熟悉常用的 数据结构 和 算法 ，具有一定的代码性能优化能力。 了解常用的开源 分布式中间件，掌握RabbitMq、Redis、Zookeeper、Dubbo的使用。 熟悉Linux常用命令，使用shell命令进行 版本管理 和 服务发布部署。 工作经历阳光保险科技中心 （ 2018年7月~至今 ）实时算薪计算引擎项目描述：计算引擎是我们为了解决代理人实时算薪的一款流式计算框架，为解决原薪资计算滞后、反复查询、重复计算而设计的。计算引擎采用 组件化 设计，以 消息驱动 实现薪资实时计算。根据不同类型的消息体，会重算代理人不同层级的指标。每一层级的指标进行 原子化拆分，实现计算中间结果利用 最大化，减少重复计算。 主要负责： 实时提数与计算引擎的对接 参与薪资项的开发，主要负责代理人增才奖、个税、团队DIY聘才的开发 阳光层与个人层的消息对接，阳光层所有薪资的计算实现 项目亮点： 采用redis记录消息状态，管理消息生命周期，方便消费异常的消息处理。 引入指标引擎思想，计算采取分层（横分）和分序（竖分）的方式，保证同一层的指标计算顺序。 通过消息的流转，动态驱动薪资计算，采用中间件（MQ、Redis）保证消息不丢失，顺序消费。 采用多线程机制进行并行计算，利用ZK锁保证一个四级机构只有一个线程消费消息，多个四级机构可同时消费该四级机构队列的消息。 考勤大屏实时追踪项目描述：这是代理人出勤实时追踪全国代理人出勤情况，从全国、二级、三级和营业区不同维度，根据职级和子渠道进行统计。可监控当日代理人出勤打卡情况，数据统计可追溯至当月，历史六个月。app、pc、ipad端均可调用接口监控营业区代理人职场画面。 主要负责： 负责模块梳理，考勤大屏数据抽象、接口设计以及缓存设计 负责公司集团内部系统对接，对来自不同平台请求进行加解密处理 项目亮点： 以每十分钟一跑批处理的方式处理后台数据，保证考勤数据的实时性，实现数据的可视化达到鼓舞代理人积极考勤，至上线以来全国代理人考勤率提升5个百分点。 系统集成多个重要指标，从不同的维度统计数据，给公司高层领导反馈全国代理人出单情况便于内部战略决策。 消息推送平台项目描述：这是一个消息推送平台的管理系统，可配置不同的薪资指标项，生成消息推送模板，向不同的平台(app端，企业微信、PC端），对公司代理人实时/定时的推送消息。 主要负责： 前端增删改查开发实现，MQ延时队列配置。 消息监听器，消息处理器，消息发送中心，持久化定时任务的实现。 项目亮点： 通过数据库的配置，灵活实现指标值，消息类型的配置，无需改动代码。 使用redis双级缓存-队列和hash的结构，实现待更新主键和持久化数据的分离，提高程序高可用性。 使用策略模式，一个推送平台对应一个具体实现，实现系统设计的低耦合性。 代理人实时提数项目描述：这是一个对公司原先PL/SQL package 批处理的改造，将业务迁移至新系统的一个服务 。代理人出单后，数据写入老核心系统，新系统会实时的每5分钟轮询一次，将数据直接提到MySQL数据库。 主要负责： 设计批处理日志记录表，书写新系统批处理管理规范文档。 实现提数业务逻辑，提交数据库后，向rabbitMQ 计算引擎发送消息，触发薪资实时计算。 项目亮点：采用多并发线程机制，大大提升提数性能，将营销渠道的提数延迟时间由之前的隔日缩短至五分钟。 北京银客集团全能数据中心微博借钱平台（ 2017年12月~2018年4月 实习）项目描述：本项目是一款由微博渠道提供用户入口，基于大数据平台进行风控审核的金融互联网借贷平台。 主要负责：参与后台管理系统的开发，梳理需求文档，协调公司内部工作。]]></content>
      <categories>
        <category>resume</category>
      </categories>
      <tags>
        <tag>resume</tag>
        <tag>job</tag>
      </tags>
  </entry>
</search>
